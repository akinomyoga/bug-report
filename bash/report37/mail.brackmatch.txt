> If someone wanted to do this, I would take a look at incorporating the
> results, as long as it didn't add dependencies on, say, pcre or gnulib
> regex.

Instead of translating the pattern to a regular expression and
compiling it by regcomp (<regex.h>), I have experimentally implemented
a new extglob engine based on a naive DFA and was comparing the
behavior and the performance with the current implementations of
devel.  [Note: In this report hereafter, ``the current
implementation/engine'' always means the implementation of strmatch
(lib/glob/{strmatch,smatch,sm_loop.c}) in the current devel 31f4d468.]

However, I noticed two strange behaviors of the current engine.
Before adjusting the behavior of the new engine and submitting it for
review, I would like to confirm the (expected) behavior of the current
engine in the current devel.

These two behaviors finally turned out to be both related to the
matching of bracket expression by the function `BRACKMATCH'
(lib/glob/sm_loop.c).

----------------------------------------------------------------------
1. pattern [[=B=]][c] matches with c

  $ bash-devel --norc
  $ [[ Bc == [[=B=]][c] ]]; echo $?
  0      <-- OK. This is expected.
  $ [[ c == [[=B=]][c] ]]; echo $?
  0      <-- This is unexpected.

  See the attached [r0037.brackmatch1.equivalence-class.patch] for the
  fix.  The problem is caused because [[=B=]][c] is treated as a
  single bracket expression [ « [=B=]][c » ] when the equivalence
  class [=B=] does not match.  This is because `]' after `[[=B=]' is
  treated as if it is the first `]' in the bracket expression (such as
  `]' after `[' in the pattern « []aaa] »).  In the patch, when the
  next character after a failing equivalence class [=B=] is `]', the
  bracket expression has been changed to fail just the same as the
  case for a failing character class [:alpha:]
  (lib/glob/sm_loop.c:530; line number is that in the current devel
  31f4d468).

----------------------------------------------------------------------
2. bracket expression sometimes match or unmatch the slash with
  FNM_PATHNAME.

  FNM_PATHNAME is only used in two places in the Bash codebase.  1)
  One is for the glob matching for the filenames in the directory
  (lib/glob/glob.c).  However, this actually does not seem to have an
  actual effect because FNM_PATHNAME only causes differences in the
  matching when the target string contains a slash but the filenames
  do not contain any slashes.  2) The other is the filtering of the
  pathname-expansion results with GLOBIGNORE (pathexp.c).  So the only
  way to test the behavior of Bash's strmatch with FNM_PATHNAME
  (without writing a C program to directly use the function
  `strmatch') is to use GLOBIGNORE.

  To demonstrate the behavior of the current implementation, I attach
  a script [fnmpath.sh], which utilizes GLOBIGNORE for the Bash
  implementation.  It compares the result with fnmatch(3).  The result
  in my environment (x86_64-redhat-linux-gnu [Fedora Linux 36 (Server
  Edition)]) is this:

  $ bash-devel fnmpath.sh
  #1: pat=ab/cd/efg        yes/yes
  #2: pat=ab[/]cd/efg      yes/no
  #3: pat=ab[/a]cd/efg     yes/no
  #4: pat=ab[a/]cd/efg     no/no
  #5: pat=ab[!a]cd/efg     yes/no
  #6: pat=ab[.-0]cd/efg    yes/no
  #7: pat=*/*/efg          yes/yes
  #8: pat=*[/]*/efg        no/no
  #9: pat=*[/a]*/efg       no/no
  #10: pat=*[a/]*/efg       no/no
  #11: pat=*[!a]*/efg       no/no
  #12: pat=*[.-0]*/efg      no/no
  #13: pat=ab@(/)cd/efg     yes/yes
  #14: pat=*@(/)cd/efg      no/no
  #15: pat=*/cd/efg         yes/yes

  This tests whether each pattern matches the string "ab/cd/efg".  Two
  results by Bash's strmatch and fnmatch(3) are connected with
  `/'. "yes" means the pattern matches the string "ab/cd/efg" and "no"
  means it does not match.  Some observations are

  * In fnmatch(3), a bracket expression never matches a / with
    FNM_PATHNAME.

  * In Bash's strmatch, a bracket expression sometimes matches `/' and
    sometimes does not.  In the codebase, `/' is excluded only when it
    explicitly appears after another character in the bracket
    expression (lib/glob/sm_loop.c:574) even though the comment
    mentions [/].  This is the reason that only [a/] fails with Bash's
    implementation in cases #2..#6 in the above result.

  * What is happening with Bash's implementation in cases #7..#12 is
    related the assumption of the backtracking trick for `*': The
    trick for `*' backtracking explained in the code comment
    lib/glob/sm_loop.c:320---"This is a clever idea from
    glibc"---relies on the behavior that the bracket expression never
    matches a slash that `*' cannot match.  [Note: The exact
    requirements for this trick is actually slightly weaker: each
    bracket expression needs to match a fixed number of `/', 0 or 1,
    when FNM_PATHNAME is specified; it should never match a slash if
    it can match other characters, and it should never match other
    characters if it can match a slash.] Otherwise, backtracking for a
    different number of slashes would unexpectedly fail.

    It is hard to modify the current implementation so that it does
    not use the "clever idea (lib/glob/sm_loop.c:320)" which requires
    the assumption on the bracket expressions; it would be another
    re-implementation of the engine.  In addition, the time complexity
    of the current implementation is linear with respect to the string
    length O(len) as far as extglob is unused, but, if we allow
    bracket expressions to consistently match `/', the time complexity
    would become O(len^n) at the worst where n is the number of `*' as
    far as the backtracking algorithm is used.

    For this practical reason in addition to the compatibility with
    fnmatch(3), I think we should just follow fnmatch(3) to reject `/'
    for any bracket expressions with FNM_PATHNAME.

  * There is a similar inconsistency caused by the same trick with the
    extglob as observed in cases #13..#15.  For these cases, even
    fnmatch(3) behaves in a somewhat unpredictable way, so I would not
    try to fix this behavior in this report.

  The attached patch [r0037.brackmatch2.slash.patch] fixes this.  I
  move the check for the slash outside the loop of the bracket
  expression.  In particular, I moved the check outside the function
  BRACKMATCH because it is more consistent with the other similar
  checks for `?' (lib/glob/sm_loop.c:108) and `*'
  (lib/glob/sm_loop.c:179).

----------------------------------------------------------------------

By the way, the third patch [r0037.brackmatch3.unused-assign.patch] is
just a cosmetic fix that removes the assignments of unused values to
the variable `cend'.  The values are unused because they will be
overwritten by a later line (lib/glob/sm_loop.557) without being
referenced.

If you would like to keep the current assignments because it is
harmless, it also works for me, but in that case I think we should
also assign the value to `cend' in lib/glob/sm_loop.c:546 as `cstart =
cend = ...' for consistency with the other lines
lib/glob/sm_loop.c:442 and lib/glob/sm_loop.c:554.


--
Koichi

=======================================================================================================================

> fnmatch with FNM_PATHNAME only has to avoid matching the slash with a
> bracket expression. The shell has an additional constraint: a slash that
> appears in a bracket expression renders the bracket expression void and
> requires the `[' to be matched explicitly. That's why there have to be
> tests for slash in BRACKMATCH. There are two bugs: the off-by-one error
> you note and matching the open bracket explicitly.

Thank you for the explanation.  I did not know the special rule for
the slash in the bracket expression.  I assumed that that part of the
code in BRACKMATCH is related to the behavior of the bracket
expression never matching a slash so just removed it, which was wrong.

> I attached the patch I applied. I didn't include your fix to issue 1 above.

Thank you for the patch.  I applied it locally and tried it.  I attach
a test script that I used: [bracket-slash.sh].  Now I switched to a
loadable builtin that directly calls strmatch instead of hacking
GLOBIGNORE.  Here are the results:

  ---Tests for a slash in bracket expressions---
  #1: pat=ab[/]ef          str=ab[/]ef          yes/yes
  #2: pat=ab[/]ef          str=ab/ef            no/no
  #3: pat=ab[c/d]ef        str=ab[c/d]ef        yes/yes
  #4: pat=ab[c/d]ef        str=abcef            yes/no
  #5: pat=ab[.-/]ef        str=ab[.-/]ef        no/yes
  #6: pat=ab[.-/]ef        str=ab.ef            yes/no
  #7: pat=ab[[=/=]]ef      str=ab[[=/=]]ef      yes/yes
  #8: pat=ab[[=/=]]ef      str=ab/ef            no/no
  #9: pat=ab[[=c=]/]ef     str=ab[=/]ef         yes/yes
  #10: pat=ab[[=c=]/]ef     str=abcef            yes/no
  #11: pat=ab[[:alpha:]/]ef str=ab[:/]ef         yes/yes
  #12: pat=ab[[:alpha:]/]ef str=abxef            yes/no
  #13: pat=ab[/[abc]]ef     str=ab[/c]ef         yes/yes
  #14: pat=ab[/[abc]]ef     str=abc]ef           no/no
  #15: pat=ab[c[=/=]]ef     str=ab[c[=/=]]ef     yes/yes
  #16: pat=ab[c[=/=]]ef     str=abc[=/=]ef       no/no
  #17: pat=ab[c[=/=]]ef     str=abcef            yes/no
  ---Tests for incomplete bracket expressions---
  #18: pat=ab[c             str=ab[c             yes/yes
  #19: pat=ab[c             str=abc              no/no
  #20: pat=ab[c[=d=         str=ab[c[=d=         yes/yes
  #21: pat=ab[c[=d=         str=abc              no/no
  #22: pat=ab[c[.d          str=ab[c[.d          yes/yes
  #23: pat=ab[c[.d          str=abc              no/no
  #24: pat=ab[c[:alpha:     str=ab[c[:alpha:     yes/yes
  #25: pat=ab[c[:alpha:     str=abc              no/no
  #26: pat=ab[c-            str=ab[c-            no/yes
  #27: pat=ab[c-            str=abc              no/no
  #28: pat=ab[c\            str=ab[c\            no/yes
  #29: pat=ab[c\            str=abc              no/no
  #30: pat=ab[[\            str=ab[[\            no/yes
  #31: pat=ab[[\            str=ab[              no/no

"yes" and "no" on the left of / in the fourth column are the results
after applying the patch you provided. "yes" and "no" on the right of
/ are the results that *I* expect (see below paragraphs).

The new treatment seems to only handle a slash that directly appears
as an independent character in bracket expressions (cases
#1,#2,#13,#14), but if I literally read the standard you quoted, I
feel we should also handle other slashes (#3..#6,#9..#12,#15..#17).
Cases #7 and #8 seem to be already processed in the current devel.  I
think we can understand the rule of the standard by a mental
processing model to first split the pattern with `/' and then to match
each segment with the corresponding segment of the target string.
Thinking in that way, we can actually just replace the NUL test for
the string end with a similar test for NUL or a slash.  I attach a
possible patch for the additional fix
[r0037.brackmatch4.slash-terminated.patch.txt], which applies after
your patch [bracket-slash.patch].

Also, I have a suggestion of changes for more consistent handling of
incomplete bracket expressions.  Currently, incomplete bracket
expressions sometimes fails unconditionally (#26..#31) and sometimes
fallbacks to a literal `[' plus remaining pattern (#18..#25).  I
attach another patch for this:
[r0037.brackmatch5.incomplete-bracket.patch.txt].

--
Koichi

===============================================================================

> The cleverness is due to Russ Cox, a really smart guy who figured this
> stuff out first:
>
> https://research.swtch.com/glob
>
> (https://swtch.com/~rsc/regexp/ is a collection of his writing on regular
> expressions. It's well worth reading.)

Thank you for the references to interesting readings!  Ah, so he is
the developer of re2.  I think this is the first time for me to read
articles written by the developer of re2.  I have looked inside the
codes there.  The idea of my new implementation [1] is closer to the
implementation "bounded-memory DFA" [2] linked from the regexp page
[3] (though I allocate a sufficient memory block calculated by the
length of the pattern string instead of using a fixed size of static
storage).  These do not require the full ``compilation'' of the DFA so
it requires a minimal preprocessing time, but instead, these are not
as fast as compiled DFAs (when we focus on the proportional
coefficients of the linear time complexity).  The new implementation
is still work-in-progress, so I later write the reasoning for the
choice of the implementation strategy when I submit the version ready
for review.

[1] https://gitlab.com/akinomyoga/bash/-/merge_requests/1; If some of
  you want to try it, you can clone it by

  $ git clone https://gitlab.com/akinomyoga/bash.git -b extglob

  but be careful that this is now a moving target occasionally squashed
  and force-pushed.
[2] https://swtch.com/~rsc/regexp/dfa1.c.txt
[3] https://swtch.com/~rsc/regexp/

I attach some benchmarks of the current state [dfaglob.pdf], where
"strmatch_ex" shown by solid lines is the new implementation.  Now
everything is linear with respect to the input string length, but I
would like to add some optimizations for simple patterns after
settling bracket-expression matters.  Also, I think I'd later add the
cases used in https://research.swtch.com/glob to the benchmarks.

--
Koichi

===============================================================================

2022年11月18日(金) 2:11 Chet Ramey <chet.ramey@case.edu>:
> "If a pattern ends with an unescaped <backslash>, it is unspecified whether
> the pattern does not match anything or the pattern is treated as invalid."
>
> Bash uses the former interpretation. If "the pattern is treated as invalid"
> means trying to literally match the open bracket and going on from there,
> your interpretation is valid as well. The standard doesn't use that
> language in other places it specifies to treat the bracket as an ordinary
> character to be matched literally, however.

There seem to be still remaining issues.  It is fine for me if Bash
chooses the former, ``the pattern does not match anything'' with a
backslash followed by NUL, but the following cases (see the attached
[reduced3.sh]) with a backslash followed by a slash should still be
fixed:

  #1: pat=a[b\/c]          str=a[b/c]           no/yes
  #2: pat=a[b\/c]          str=ab               no/no
  #3: pat=a[b\/c]          str=ac               yes/no
  [...]

Where the fourth column <xxx/yyy> shows the result of the current
devel 407d9afc with FNM_PATHNAME (xxx) and the result I expect
(yyy). "yes" means the pattern matches to the string, and "no" means
the pattern does not match.

* I expect "yes" for #1 because the bracket expression contains a
  slash before its closing right bracket `]' and thus the beginning
  `[' should be matched literally.  However, the actual behavior is
  "no".

* I expect "no" for both #2 and #3 because the beginning bracket `['
  should be matched literally.  Even when an escaped slash would be
  allowed in the bracket expression so that [b\/c] forms a complete
  bracket expression, the results of #2 and #3 being "no" and "yes",
  respectively, are inconsistent.

  This difference is caused because the slash after the backslash is
  only checked after a matching character is found
  (lib/glob/sm_loop.c:703).  The same check should be applied also
  before a matching character is found (lib/glob/sm_loop.c:573).  I
  attach a patch for this [].

----------------------------------------------------------------------

There is another related inconsistency.  I just modified my new
extglob engine to follow the Bash's choice described above, but then
the behavior became different from that of the actual implementation
of Bash of the current devel.

> "If a pattern ends with an unescaped <backslash>, it is unspecified whether
> the pattern does not match anything or the pattern is treated as invalid."
>
> Bash uses the former interpretation.

The corresponding sentence in the POSIX standard describes the
unescaped backslashes in the general context of the pattern instead of
that in the bracket expression, so I applied this to the new extglob
engine.  However, ``the former interpretation'' that Bash adopts
turned out to be only applied to the unescaped backslashes *inside a
bracket expression*.  This is the remaining part of the output of the
attached [reduced3.sh] with the current devel 407d9afc:

  [...]
  #4: pat=a\               str=a\               yes/???

So the pattern terminated with unescaped backslash actually matches a
string, where the backslash is treated as a literally-matching
backslash.

a. Is this difference between outside and inside of the bracket
  expressions intensional? I.e., the former interpretation "the
  pattern does not match anything" seems to only applies to the inside
  of bracket expressions.

b. If this is the behavior for the unescaped backslashes outside the
  bracket expressions, which is intensionally different from those in
  the bracket expressions, would it be possible to change the
  treatment of the unescaped backslashses inside the bracket
  expression the same as that of outside so the bracket `[' matches
  literally (as expected in cases #28..#31 of my previous reply [1])?
  The attached [] is the corresponding patch.

  [1] https://lists.gnu.org/archive/html/bug-bash/2022-11/msg00070.html

c. If the behavior of the unescaped backslash of the outside should
  also be modified to follow the former interpretation "the pattern
  does not match anything", another patch is [].  However, the current
  behavior outside the bracket expression seems to be explicitly
  required by the tests on tests/glob2.sub:32 and tests/glob2.sub:41.

I prefer option b, which keeps the behavior required by
tests/glob2.sub and also consistent between the inside and the outside
of bracket expressions.  It is also consistent with the behavior for
the string end inside bracket expressions.

----------------------------------------------------------------------
