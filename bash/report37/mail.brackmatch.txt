> If someone wanted to do this, I would take a look at incorporating the
> results, as long as it didn't add dependencies on, say, pcre or gnulib
> regex.

Instead of translating the pattern to a regular expression and
compiling it by regcomp (<regex.h>), I have experimentally implemented
a new extglob engine based on a naive DFA and was comparing the
behavior and the performance with the current implementations of
devel.  [Note: In this report hereafter, ``the current
implementation/engine'' always means the implementation of strmatch
(lib/glob/{strmatch,smatch,sm_loop.c}) in the current devel 31f4d468.]

However, I noticed two strange behaviors of the current engine.
Before adjusting the behavior of the new engine and submitting it for
review, I would like to confirm the (expected) behavior of the current
engine in the current devel.

These two behaviors finally turned out to be both related to the
matching of bracket expression by the function `BRACKMATCH'
(lib/glob/sm_loop.c).

----------------------------------------------------------------------
1. pattern [[=B=]][c] matches with c

  $ bash-devel --norc
  $ [[ Bc == [[=B=]][c] ]]; echo $?
  0      <-- OK. This is expected.
  $ [[ c == [[=B=]][c] ]]; echo $?
  0      <-- This is unexpected.

  See the attached [r0037.brackmatch1.equivalence-class.patch] for the
  fix.  The problem is caused because [[=B=]][c] is treated as a
  single bracket expression [ « [=B=]][c » ] when the equivalence
  class [=B=] does not match.  This is because `]' after `[[=B=]' is
  treated as if it is the first `]' in the bracket expression (such as
  `]' after `[' in the pattern « []aaa] »).  In the patch, when the
  next character after a failing equivalence class [=B=] is `]', the
  bracket expression has been changed to fail just the same as the
  case for a failing character class [:alpha:]
  (lib/glob/sm_loop.c:530; line number is that in the current devel
  31f4d468).

----------------------------------------------------------------------
2. bracket expression sometimes match or unmatch the slash with
  FNM_PATHNAME.

  FNM_PATHNAME is only used in two places in the Bash codebase.  1)
  One is for the glob matching for the filenames in the directory
  (lib/glob/glob.c).  However, this actually does not seem to have an
  actual effect because FNM_PATHNAME only causes differences in the
  matching when the target string contains a slash but the filenames
  do not contain any slashes.  2) The other is the filtering of the
  pathname-expansion results with GLOBIGNORE (pathexp.c).  So the only
  way to test the behavior of Bash's strmatch with FNM_PATHNAME
  (without writing a C program to directly use the function
  `strmatch') is to use GLOBIGNORE.

  To demonstrate the behavior of the current implementation, I attach
  a script [fnmpath.sh], which utilizes GLOBIGNORE for the Bash
  implementation.  It compares the result with fnmatch(3).  The result
  in my environment (x86_64-redhat-linux-gnu [Fedora Linux 36 (Server
  Edition)]) is this:

  $ bash-devel fnmpath.sh
  #1: pat=ab/cd/efg        yes/yes
  #2: pat=ab[/]cd/efg      yes/no
  #3: pat=ab[/a]cd/efg     yes/no
  #4: pat=ab[a/]cd/efg     no/no
  #5: pat=ab[!a]cd/efg     yes/no
  #6: pat=ab[.-0]cd/efg    yes/no
  #7: pat=*/*/efg          yes/yes
  #8: pat=*[/]*/efg        no/no
  #9: pat=*[/a]*/efg       no/no
  #10: pat=*[a/]*/efg       no/no
  #11: pat=*[!a]*/efg       no/no
  #12: pat=*[.-0]*/efg      no/no
  #13: pat=ab@(/)cd/efg     yes/yes
  #14: pat=*@(/)cd/efg      no/no
  #15: pat=*/cd/efg         yes/yes

  This tests whether each pattern matches the string "ab/cd/efg".  Two
  results by Bash's strmatch and fnmatch(3) are connected with
  `/'. "yes" means the pattern matches the string "ab/cd/efg" and "no"
  means it does not match.  Some observations are

  * In fnmatch(3), a bracket expression never matches a / with
    FNM_PATHNAME.

  * In Bash's strmatch, a bracket expression sometimes matches `/' and
    sometimes does not.  In the codebase, `/' is excluded only when it
    explicitly appears after another character in the bracket
    expression (lib/glob/sm_loop.c:574) even though the comment
    mentions [/].  This is the reason that only [a/] fails with Bash's
    implementation in cases #2..#6 in the above result.

  * What is happening with Bash's implementation in cases #7..#12 is
    related the assumption of the backtracking trick for `*': The
    trick for `*' backtracking explained in the code comment
    lib/glob/sm_loop.c:320---"This is a clever idea from
    glibc"---relies on the behavior that the bracket expression never
    matches a slash that `*' cannot match.  [Note: The exact
    requirements for this trick is actually slightly weaker: each
    bracket expression needs to match a fixed number of `/', 0 or 1,
    when FNM_PATHNAME is specified; it should never match a slash if
    it can match other characters, and it should never match other
    characters if it can match a slash.] Otherwise, backtracking for a
    different number of slashes would unexpectedly fail.

    It is hard to modify the current implementation so that it does
    not use the "clever idea (lib/glob/sm_loop.c:320)" which requires
    the assumption on the bracket expressions; it would be another
    re-implementation of the engine.  In addition, the time complexity
    of the current implementation is linear with respect to the string
    length O(len) as far as extglob is unused, but, if we allow
    bracket expressions to consistently match `/', the time complexity
    would become O(len^n) at the worst where n is the number of `*' as
    far as the backtracking algorithm is used.

    For this practical reason in addition to the compatibility with
    fnmatch(3), I think we should just follow fnmatch(3) to reject `/'
    for any bracket expressions with FNM_PATHNAME.

  * There is a similar inconsistency caused by the same trick with the
    extglob as observed in cases #13..#15.  For these cases, even
    fnmatch(3) behaves in a somewhat unpredictable way, so I would not
    try to fix this behavior in this report.

  The attached patch [r0037.brackmatch2.slash.patch] fixes this.  I
  move the check for the slash outside the loop of the bracket
  expression.  In particular, I moved the check outside the function
  BRACKMATCH because it is more consistent with the other similar
  checks for `?' (lib/glob/sm_loop.c:108) and `*'
  (lib/glob/sm_loop.c:179).

----------------------------------------------------------------------

By the way, the third patch [r0037.brackmatch3.unused-assign.patch] is
just a cosmetic fix that removes the assignments of unused values to
the variable `cend'.  The values are unused because they will be
overwritten by a later line (lib/glob/sm_loop.557) without being
referenced.

If you would like to keep the current assignments because it is
harmless, it also works for me, but in that case I think we should
also assign the value to `cend' in lib/glob/sm_loop.c:546 as `cstart =
cend = ...' for consistency with the other lines
lib/glob/sm_loop.c:442 and lib/glob/sm_loop.c:554.


--
Koichi

=======================================================================================================================

> fnmatch with FNM_PATHNAME only has to avoid matching the slash with a
> bracket expression. The shell has an additional constraint: a slash that
> appears in a bracket expression renders the bracket expression void and
> requires the `[' to be matched explicitly. That's why there have to be
> tests for slash in BRACKMATCH. There are two bugs: the off-by-one error
> you note and matching the open bracket explicitly.

Thank you for the explanation.  I did not know the special rule for
the slash in the bracket expression.  I assumed that that part of the
code in BRACKMATCH is related to the behavior of the bracket
expression never matching a slash so just removed it, which was wrong.

> I attached the patch I applied. I didn't include your fix to issue 1 above.

Thank you for the patch.  I applied it locally and tried it.  I attach
a test script that I used: [bracket-slash.sh].  Now I switched to a
loadable builtin that directly calls strmatch instead of hacking
GLOBIGNORE.  Here are the results:

  ---Tests for a slash in bracket expressions---
  #1: pat=ab[/]ef          str=ab[/]ef          yes/yes
  #2: pat=ab[/]ef          str=ab/ef            no/no
  #3: pat=ab[c/d]ef        str=ab[c/d]ef        yes/yes
  #4: pat=ab[c/d]ef        str=abcef            yes/no
  #5: pat=ab[.-/]ef        str=ab[.-/]ef        no/yes
  #6: pat=ab[.-/]ef        str=ab.ef            yes/no
  #7: pat=ab[[=/=]]ef      str=ab[[=/=]]ef      yes/yes
  #8: pat=ab[[=/=]]ef      str=ab/ef            no/no
  #9: pat=ab[[=c=]/]ef     str=ab[=/]ef         yes/yes
  #10: pat=ab[[=c=]/]ef     str=abcef            yes/no
  #11: pat=ab[[:alpha:]/]ef str=ab[:/]ef         yes/yes
  #12: pat=ab[[:alpha:]/]ef str=abxef            yes/no
  #13: pat=ab[/[abc]]ef     str=ab[/c]ef         yes/yes
  #14: pat=ab[/[abc]]ef     str=abc]ef           no/no
  #15: pat=ab[c[=/=]]ef     str=ab[c[=/=]]ef     yes/yes
  #16: pat=ab[c[=/=]]ef     str=abc[=/=]ef       no/no
  #17: pat=ab[c[=/=]]ef     str=abcef            yes/no
  ---Tests for incomplete bracket expressions---
  #18: pat=ab[c             str=ab[c             yes/yes
  #19: pat=ab[c             str=abc              no/no
  #20: pat=ab[c[=d=         str=ab[c[=d=         yes/yes
  #21: pat=ab[c[=d=         str=abc              no/no
  #22: pat=ab[c[.d          str=ab[c[.d          yes/yes
  #23: pat=ab[c[.d          str=abc              no/no
  #24: pat=ab[c[:alpha:     str=ab[c[:alpha:     yes/yes
  #25: pat=ab[c[:alpha:     str=abc              no/no
  #26: pat=ab[c-            str=ab[c-            no/yes
  #27: pat=ab[c-            str=abc              no/no
  #28: pat=ab[c\            str=ab[c\            no/yes
  #29: pat=ab[c\            str=abc              no/no
  #30: pat=ab[[\            str=ab[[\            no/yes
  #31: pat=ab[[\            str=ab[              no/no

"yes" and "no" on the left of / in the fourth column are the results
after applying the patch you provided. "yes" and "no" on the right of
/ are the results that *I* expect (see below paragraphs).

The new treatment seems to only handle a slash that directly appears
as an independent character in bracket expressions (cases
#1,#2,#13,#14), but if I literally read the standard you quoted, I
feel we should also handle other slashes (#3..#6,#9..#12,#15..#17).
Cases #7 and #8 seem to be already processed in the current devel.  I
think we can understand the rule of the standard by a mental
processing model to first split the pattern with `/' and then to match
each segment with the corresponding segment of the target string.
Thinking in that way, we can actually just replace the NUL test for
the string end with a similar test for NUL or a slash.  I attach a
possible patch for the additional fix
[r0037.brackmatch4.slash-terminated.patch.txt], which applies after
your patch [bracket-slash.patch].

Also, I have a suggestion of changes for more consistent handling of
incomplete bracket expressions.  Currently, incomplete bracket
expressions sometimes fails unconditionally (#26..#31) and sometimes
fallbacks to a literal `[' plus remaining pattern (#18..#25).  I
attach another patch for this:
[r0037.brackmatch5.incomplete-bracket.patch.txt].

--
Koichi
