# -*- fill-column: 79 -*-


------------------------------------------------------------------------------
  Memo
------------------------------------------------------------------------------

2021-05-11

* fish は全然いい言語ではないという事

  https://www.oilshell.org/blog/2021/01/why-a-new-shell.html#whats-the-difference-between-oil-and-fish
  https://github.com/pirate/fish-utils/blob/master/README.md

  様々な人が自分のシェルを作っている
  https://github.com/oilshell/oil/wiki/Alternative-Shells
  https://github.com/oilshell/oil/wiki/ExternalResources#posix-shells
  POSIX list にも何か自分のシェルを作っている人が居た。


2020-05-15

* ${ list; } に対応するには何処をどうすれば良いのか。
  https://lists.gnu.org/archive/html/help-bash/2020-05/msg00077.html

  Chet が patch があれば受け入れると言っている。
  気になる。然しすでに何日か経ってしまったし、mmap を使った実装などを要求されると大変である。
  というより一時ファイルを作成して其処に出力させるなど面倒が多い気がする。

  最初は文法を見ていたがどうも ${...} の中は括弧の対応だけとってその場では解釈しない様子だ。
  実際に ${} を処理しているのは subst.c:8743 parameter_brace_expand である。
  その場で中の構造を決定して実行している様に見える。この関数を弄れば良いという事だろうか。

  * ${ の直後にどの文字が来たら ${ list;} と解釈するか。

    空白の場合にだけ特別な処理をするのか、
    或いは { ...; } と同様に単語の区切りとなる文字
    ($IFS, <>, |&;, ()) を要求するか。

    - ${} の中身を独立した行にしたい場合や ${< file} という記述をした
      いという事を考えると、単語区切りの文字を要求したい気がする。

    - "(" に関しては zsh の parameter expansion の flags と被る。これ
      に対応してしまうと将来的に zsh と同様の展開をサポートしたい時に
      困る。既に Bash には ${var@ops} もあるがこれは他の ${a##pat} 等
      と組み合わせる事ができない。また、zsh ユーザに対して混乱をきたす
      可能性がある。

    - "|&;)" に関しては明らかに文法の誤りである。因みに ksh の場合には
      & で始まる文法が存在する。

    - ksh の振る舞いを確認すると 空白以外にも <> や () を特別扱いして
      いる様に見える。|;& も同様の気がするが実際には良くわからない。

    選択肢は三種類ある。(1) $IFS のみ (2) $IFS 及び <> のみ (3) 全ての
    単語区切り空白のみというのはやはり変なので $IFS は対応するべきであ
    る。(2) 位なら未だOK。(3) は文法的に明らかに許容できない物も含むが
    言語の設計としては自然。ksh は (3) の様な気がする。取り敢えず
    " \t\n<>" もしくは " \t\n<>|&;()" だろう。

  コマンド置換は subst.c:9716 において extract_command_subst を呼び出して範囲を切り出し、
  subst.c:9778 において command_substitute を呼び出して実行している。中では色々関数を呼び出している。
  これらは ${ ... } の切り出しには使えないだろう。それよりは寧ろ、${ ... } の関数を使う方が自然。
  然し、${ ... } は SX_POSIXEXP | SX_WORD なのか SX_WORD なのか。というより、SX_POSIXEXP は何だろう。

  * parse.y はやはり修正する必要がある。${} の解析は {} の入れ子を数えずに、
    単に } が現れた所で終了する様になっている。つまり、
    echo ${a##{} }xxx は echo "${a##{}" "}xxx" と解釈されるし、
    echo ${ echo {} } は echo "${ echo {}" "}" と解釈される。

  * 更に単に {} の入れ子だけ数えれば良いという訳ではない。
    } が単独文字の単語を為しているかどうかを判定する必要がある。
    その様に色々と考えて行くと {} による切り出しというのは新しい関数を書く必要が出てくる。
    一方で ksh の実装を見ると結構いい加減の気もする。} の前に
    くっついて来る単語があるかないかだけ判定すれば良い?

    其処まで行くのであれば実は ;()&| の直後の } という様にしてしまっても良い?
    然し、$()} というパターンを考えると ) の直後というのは駄目。
    ${ echo hello; } ${ type cmd; } vs ${ type cmd } うーん。
    やはり、[;&|\n][ \t]+\} が現れる迄を読み取る?
    time } だとか a=1 } だとかはどう取り扱うべきか。

    a=1 } に関しては } は通常のコマンド名として解釈される様だ。
    time } に関しては構文エラーになる。time 改行 } に関しては大丈夫。
    他に 行頭以外に } が来る状況は在るだろうか。例えば < file } は試したらエラーだった。
    | } とした場合でもエラーになる。その他 case 関連の ;; ;;& ;& や
    && や || もその次に } が来ることはない。
    色々考え合わせるにやはり /[;&\n][ \t]+\}/ 的な判定で良い気がする。
    然し、実際のところそんな実装で良いのかという問題も在る。

    {} の入れ子を実装する為には実は { も数える必要がある。
    色々考えるとやはり parse.y のレベルで { ... } を解析する仕組みがある筈。
    そうでないと関数定義の切り出しも難しくなってしまう。
    実際に調べてみると function_body : shell_command,
    shell_command: group_command, group_command: '{' compond_list '}' となっている。
    更によく見てみると $() も ${} も parse.y では解析していない。

* man ksh を見ると ksh には未だ未だ色々な機能がある事が分かる。
  色々便利そうな拡張があるが現実にこれらを利用するスクリプトは存在するのだろうか。

  * namespace varname { list ;} ... 変数の名前空間
  * & name args...; list &      ... ジョブプール名を指定してコマンドを実行
  * ${ ... }                    ... 同じプロセス内のコマンド置換。
  * $(1<#)                      ... ftell(fd) の結果に置換される。
  * ${arr[1][2]} 配列の配列 etc.
  * ${$param} ... 間接参照 (Bash ${!param} に同じ) (Zsh とは意味が異なる)
  * ${@vname} ... 属性 (Bash ${vname@a} に同じだろうか)
  * ${!vname} ... nameref の参照先変数名 (Bash と意味が異なる)

  extglob
  * {n}(...), {n,m}() ... 繰り返し。
  * %({}Q"E\)         ... 入れ子括弧の読み取り。
  * ~(options:...)    ... オプション。

  算術式
  * 浮動小数点が使える。数学関数も使える。数学定数が用意されている。
    ユーザ定義の関数も指定できる。ユーザ定義関数では配列参照も引数に指定できる。

  リダイレクション
  * >; word <>; word ... 一時ファイルに出力してコマンドが成功してから word に改名
  * <#((expr)) >#((expr)) ... fseek
  * <#pattern <##pattern  ... 行検索 (## の時はスキップした行は標準出力へ)

  * 関数: func() 形式の場合はスコープを作らない。function func 形式の場合は作る。
  * 変数: get/set/append/unset 等の操作を定義できる。

  * set -sK COLS arr             ... 配列のソート
  * test -R                      ... nameref かどうかのテスト
  * . funcname                   ... 同じスコープで関数を実行
  * enum name=(value1 value2...) ... 新しい列挙型を作成する。

2020-04-15

* tempenv が絡んだ時の unset の振る舞いが変だ。
  以下は unset の状態になると期待するが実際には global が見えてしまう。
  Bash-4.2 までは期待通りの動作だが、Bash-4.3 以降でこうなってしまっている。

  f1() {
    local v=local
    unset -v v
    echo "v=${v- (unset)}"
  }
  v=global
  v=tempenv f1

  そもそも何処でこの処理をしているのかについて確認する。
  先ず初めに builtins/set.def (builtin_unset) が呼び出される。
  そして variables.c (unbind_variable(name)) が呼び出される。
  其処から variables.c (makunbound(name, variable_context)) が呼び出される。
  この関数の中で localvar_unset 等の判定が行われている。
  variable_context と比較して一致するかどうかを判定している。

  うーん。ここで別の文脈という事になってしまっているという事だろうか。
  然し、不思議なのは local builtin で variable_context に値が設定される訳ではないという事。

  * 取り敢えず本当にここで違う物が得られているのかという事を確認するのが最初。
    と思って実際に試してみた所、ちゃんと両者は一致していて 1 になっている。
    此処で確認しておいてよかった。もうすぐで variable_context が何処で設定されているか
    調べ始めてしまうところであった。だとするともっと別の場所で判定が行われている。
  * 別の条件 local_p によってスキップしているのだろうかと思ったがそうでもなかった。
  * 更に nofree_p が設定されていない事によって勝手に削除されてしまうのだろうか、
    と思ったが確認してみた所、普通のローカル変数でも tmpenv でも nofree_p は 0 だった。
  * 駄目だ FREE する所まで振る舞いが一致している。という事はまた別の場所で何か処理が行われている?
    試しに dynamic unset の時の path で出力する様にして見たが、
    其処は通過していない様だ。という事は何か別の経路で変数が削除されてしまっている。
  * 因みに tempvar_p についてはちゃんと有効になっている。
    或いは export 属性がついていると変数が即座に削除されてしまう等の事があるのだろうか。
    もしくは tempvar が export 属性を持っていない場合には無視されてしまうというバグがあるのか。

  とここで気づいてしまったのだが bash-dev では直っている。
  突き止めた。f65f3d54 で修正されている。以下の ChangeLog がこれに対応する物だ。

  |             2/6
  |             ---
  | variables.c
  |   - make_local_variable: make sure local variables that have the same
  |     names as variables found in the temporary environment are marked as
  |     local. From Grisha Levit <grishalevit@gmail.com> back in 12/2018


2020-03-21

* "local -p" で flags が出力されない。
  local の man を見ると declare のオプションは全て使えると書いてある。
  (使えるとは書いてあるが振る舞いが同じとは書かれていないが…。
  然し、何も書いていないという事であれば同様に振る舞うと期待するのが自然である。)

* "local -p var" / "readonly -p var" で何も出力されない。
  manual を見ても何とも言えない。自然に考えたら対応していても良さそうなのに。
  "export -p var" に関しては manual にも書いていない。
  というより "export var" と同じ効果になっているが、これはおかしいのでは。

* "declare -p dict" で余分な空白が出力される
  declare -A dict=([1]=2 )

* "declare -p a=b" では "a=b" という名前の変数を探索するが、
  "declare -p a=(1 2 3)" では a=(1 2 3) を実行した上で
  更に declare -p a を実行するという振る舞いになる。

* "echo 6>&5-" とすると、閉じたままになっている。

2019-12-18

* Bash 仕様: n key目の timeout は n-1 key目がある時にのみ起こる。

  これは元々 keymap-timeout の機能自体が vi モードで ESC と
  矢印キーを区別するための物だからであろう。
  ESC [ まで受信してその次が暫く来なかった時に、
  CSI シーケンスが終了するのを待つ方が自然である。
  従って timeout して "ESC" + "[" に分解される事はない。

  然し、ユーザが abc と a に対して束縛している時に
  ab まで入力して止まった時に幾ら待っても動かないという事になる。
  この状況でどう振る舞うのが良いのかというのについては非自明である。

2019-02-11

* バグ報告の仕方

  git format-patch devel 等とする。


-------------------------------------------------------------------------------
  Bugs
-------------------------------------------------------------------------------

2025-02-17

* BUG: set -- "" "" ""; IFS=; $* が "" "" になる。

  % 他の ${a[*]} 等では発生しない。
  % →これはテストコードの誤りだった。常にこの様に発生するという事が分かった。

  bash のソースコードを見に行くと $* はどうやら一旦 xx の様に IFS で連結されて、
  更にその後で word splitting の対象となる様だ。しかし、word splitting は末尾の
  x は無視する為に一個単語が減少する事になる。

  一方で ${a[*]} は正しく動作しているがどの様に実装されているのだろうか。或いは
  ${a[*]} の場合には文字列化せずに処理されているのかもしれない。

  と思って色々試したが変だ。実はテストの為に書いたコードが間違っていて、同じ現
  象が ${a[*]} でも発生するという事が分かった。

  bash のソースコードを確認する限り、IFS= の時にだけ特別の振る舞いをする様であ
  る。では IFS=' ' の場合にはどうして問題が発生していなかったのだろう…。IFS='
  ' の場合には ' ' になるが、これは IFS の先頭が空白の時の特別ルールとして全て
  の単語が消えるのだった。'xx' の場合に二つの要素を生成するのとは対照的である。

  うーん。これは結局変な振る舞いではあるがバグと主張するほどでもない様にも思わ
  れる。影響範囲も広くはないだろう。しかし、少なくとも他の shell たちとは全く異
  なる振る舞いである。

* BUG: ${!prefix_*} word splitting bug

  unquoted * array expansion should not join the elements even if IFS
  is empty.

  $ bash --norc
  $ prefix_1= prefix_2= IFS=
  $ printf '<%s>\n' ${!prefix_*}
  <prefix_1prefix_2>
  $ a=("${!prefix_@}")
  $ printf '<%s>\n' ${a[*]}
  <prefix_1>
  <prefix_2>

2024-12-27

* assoc ${a[@]}:offset:count} is inconsistent

  * offset is shifted by one
  * Even if one sets count = 0, it generates one element

* How the failglob fails seems inconsistent. There might be other failures that
  fails in a similar way.

  $ bash -c 'shopt -s failglob; echo a*b*c*d; echo hello'
  bash: line 1: no match: a*b*c*d

  $ cat failglob.sh
  echo a*b*c*d; echo same line
  echo failglob.sh 1
  function f { echo a*b*c*d; echo yes; }; echo hello; f; echo world
  echo failglob.sh 2
  $ bash -c 'shopt -s failglob; source ./failglob.sh; echo hello'
  ./failglob.sh: line 1: no match: a*b*c*d
  failglob.sh 1
  hello
  ./failglob.sh: line 3: no match: a*b*c*d
  failglob.sh 2
  hello

* ${!A[@]-}

  $ (echo ${!undef-xxx})
  bash: undef: invalid indirect expansion
  $ (echo ${!undef[@]-xxx})
  bash: undef[@]: invalid indirect expansion
  $ (a=(); echo ${!a[@]-xxx})
  xxx
  $ (a=(); echo ${!a[0]-xxx})
  xxx
  $ (a=(); echo ${!a-xxx})
  xxx

  The first two cases were actually fixed in Bash 5.0

  $ bash-4.4
  $ (echo ${!undef-xxx})
  xxx
  $ (echo ${!undef[@]-xxx})
  xxx
  $ exit

  So the array cases should be leftovers.

* array indirection and empty test

  $ a=('')
  $ ref='a[@]'; echo "a[@]: ${a[@]:-(empty)}; !ref: ${!ref:-(empty)};"
  $ ref='a[*]'; echo "a[*]: ${a[*]:-(empty)}; !ref: ${!ref:-(empty)};"
  $ a=("" "") IFS=
  $ ref='a[@]'; echo "a[@]: ${a[@]:-(empty)}; !ref: ${!ref:-(empty)};"
  $ ref='a[*]'; echo "a[*]: ${a[*]:-(empty)}; !ref: ${!ref:-(empty)};"
  a[@]: '(empty)'; !ref: '';
  a[*]: '(empty)'; !ref: '';
  a[@]: ' '; !ref: ' ';
  a[*]: '(empty)'; !ref: '';

  これらは同じ結果を返すべきではないのか。

2021-09-10

* ./configure --with-bash-malloc=no にしたら改善するのだろうか

  bash-malloc を使う理由は何だろうか。速度に問題があるのだろうか。実際に二種
  類で比較してみたが大した違いはない。bash-malloc は初回の確保には時間がかか
  る。二回目については両者とも改善して速度的には同程度である。

  そして振る舞いに関しては同様。解放する気はやはり全然ないようだ。

  うーん。Google Chrome がタブごとにプロセスを分けたというのもこういう事なの
  かもしれない。ページごとにアロケータを作るにしてもうっかりするとページを跨
  る参照を作り兼ねないから、それなら完全にプロセスを分けてしまって弱参照を徹
  底するという事。

2021-05-25

* set -e; builtin eval false || true で駄目になるという事

  この問題は実は report20 のすぐ上で起こっている問題で、起こっている原因も似た
  ような物である様に思われる。実装を見てみると eval/source/command の場合に
  parse_and_execute を呼び出す事によって set -e の効果が回復してしまうのを、前
  後で状態を保存する事によって防いでいる様である。

  ? この実装方法だと他にも問題が生じる様な気がする。eval の内部で set -e した効
    果が外に現れないのではないだろうか。或いはコマンドが終わる度に -e が設定し
    直されるのだろうか。

    $ eval set -e; false; true   # OK
    $ set -e; eval set +e; false # OK

    これらはちゃんと期待される動作をしている。何故だろうか。実装の詳細がよく分
    からない。

2021-02-08

* bash: ${a[@]} も何らかの条件で N^2 で遅くなるが普通に再現しようとしても駄目。
  中に含まれている値に依るという事なのだろうか。

2020-12-21

* report20: builtin eval pipeline の中で tempenv が消える

  A=1 builtin eval ':|echo $A'

  試したが bash-3.0..5.1 で再現する。
  更に遡って見ると bash-2.01 以降で現在の振る舞いになっている。
  bash-2.0 では builtin が外れていても $A が消滅する振る舞いになっている。
  2.0..2.01 の間の変更で問題を解決しようとしたが部分的な解決に留まったという事か。

  bash-2.0..2.01 の diff で見つけた。
  うーん。builtin_builtin の場合も条件分岐に加えるか、
  或いは builtin_builtin の時には builtin で呼び出されるコマンドも確認する。

  | diff -bwur bash-2.0/execute_cmd.c bash-2.01/execute_cmd.c
  | --- bash-2.0/execute_cmd.c  2020-04-23 14:26:09.000000000 +0900
  | +++ bash-2.01/execute_cmd.c  2020-04-23 14:14:23.000000000 +0900
  | @@ -2344,12 +2448,15 @@
  |        begin_unwind_frame ("eval_builtin");
  |        unwind_protect_int (exit_immediately_on_error);
  |        exit_immediately_on_error = 0;
  | +      eval_unwind = 1;
  |      }
  | +  else
  | +    eval_unwind = 0;
  |
  |    /* The temporary environment for a builtin is supposed to apply to
  |       all commands executed by that builtin.  Currently, this is a
  | -     problem only with the `source' builtin. */
  | -  if (builtin == source_builtin)
  | +     problem only with the `source' and `eval' builtins. */
  | +  if (builtin == source_builtin || builtin == eval_builtin)
  |      {
  |        if (subshell == 0)
  |   begin_unwind_frame ("builtin_env");
  | @@ -2369,18 +2476,18 @@
  |
  |    result = ((*builtin) (words->next));
  |
  | -  if (subshell == 0 && builtin == source_builtin)
  | +  if (subshell == 0 && (builtin == source_builtin || builtin == eval_builtin))
  |      {
  | -      /* In POSIX mode, if any variable assignments precede the `.' builtin,
  | -  they persist after the builtin completes, since `.' is a special
  | -  builtin. */
  | +      /* In POSIX mode, if any variable assignments precede the `.' or
  | +  `eval' builtin, they persist after the builtin completes, since `.'
  | +  and `eval' are special builtins. */
  |        if (posixly_correct && builtin_env)
  |   merge_builtin_env ();
  |        dispose_builtin_env ();
  |        discard_unwind_frame ("builtin_env");
  |      }
  |
  | -  if (subshell == 0 && builtin == eval_builtin && (flags & CMD_IGNORE_RETURN))
  | +  if (eval_unwind)
  |      {
  |        exit_immediately_on_error += old_e_flag;
  |        discard_unwind_frame ("eval_builtin");

  該当箇所は今では以下の様になっている。

  | +++ bash-2.01/execute_cmd.c  2020-04-23 14:14:23.000000000 +0900
  | @@ +4755,10 @@
  |   /* The temporary environment for a builtin is supposed to apply to
  |      all commands executed by that builtin.  Currently, this is a
  |      problem only with the `unset', `source' and `eval' builtins.
  |      `mapfile' is a special case because it uses evalstring (same as
  |      eval or source) to run its callbacks. */
  |   /* SHOULD_KEEP is for the pop_scope call below; it only matters when
  |      posixly_correct is set, but we should propagate the temporary environment
  |      to the enclosing environment only for special builtins. */
  |   isbltinenv = (builtin == source_builtin || builtin == eval_builtin || builtin == unset_builtin || builtin == mapfile_builtin);
  |   should_keep = isbltinenv && builtin != mapfile_builtin;

  実装について色々疑問が出てくる。

  command eval をした時にはどうなるのか。builtin builtin eval をした時にどうなるか。
  そもそも条件によって特別な処理をしたりしなかったりする理由は何か。
  振る舞い的にそうしなければならない必要があるからなのか、
  或いは、単に実行効率の為なのか。

  - builtin builtin eval NG
  - command builtin eval NG
  - builtin command eval OK

  - f1() { :|declare -p A; } という関数を定義して
    A=1 builtin eval f1 などとした場合には問題なく動く。
    つまり、eval の文脈で直接実行した時にのみ問題が発生する。

  - compgen -F 経由で呼び出した関数の中で :|declare -p A としても問題
    は起こらない。

  該当部分の判定には mapfile 等も列挙されているが、実のところ mapfile
  等が此処に追加された経緯が全く同じ問題による物なのかは怪しい。また別
  の種類の問題があった可能性もある。変更履歴を追跡する価値はある。

  ad4aef083 (Chet Ramey 2013-02-05 16:43:03 -0500 4763)
    isbltinenv = (builtin == source_builtin || builtin == eval_builtin || builtin == unset_builtin || builtin == mapfile_builtin);

    >            1/11
    >            ----
    > execute_cmd.c
    >   - execute_builtin: since mapfile uses evalstring() to run its callbacks
    >     internally, just like eval, so it needs to handle the case where the
    >     temp environment given to mapfile persists throughout the entire
    >     set of callback commands.  This might be a problem with trap also, but
    >     trap isn't run in the same way.  Fixes bug reported by Dan Douglas
    >     <ormaaj@gmail.com>

    https://lists.gnu.org/archive/html/bug-bash/2013-01/msg00039.html

  19e1dd936 (Chet Ramey 2011-12-03 13:47:06 -0500 4264)
    isbltinenv = (builtin == source_builtin || builtin == eval_builtin || builtin == unset_builtin);

    > execute_cmd.c
    >   - fix execute_builtin so the `unset' builtin also operates on the
    >     temporary environment in POSIX mode (as well as source and eval),
    >     so that unsetting variables in the temporary environment doesn't
    >     leave them set when unset completes.  Report by Eric Blake
    >     <ebb9@byu.net>

    https://lists.gnu.org/archive/html/bug-bash/2005-05/msg01417.html

  7117c2d22 (Jari Aalto 2002-07-17 14:10:11 +0000 3054)
    isbltinenv = (builtin == source_builtin || builtin == eval_builtin);
  d166f0488 (Jari Aalto 1997-06-05 14:59:13 +0000 2795)
    if (builtin == source_builtin || builtin == eval_builtin)
  726f6388 (Jari Aalto 1996-08-26 18:22:31 +0000 2352)
    if (builtin == source_builtin)

  どうも全く同じケースで修正に至った訳ではなくて
  それぞれでそれぞれに変な現象が起こっていた様子である。
  此処で気になるのは何故 eval だと問題になって関数呼び出しだと問題にならないのかという事。

  x A=1 declare -i a='x[$(:|declare -p A >&2)]'
  o f1() { :|declare -p A >&2; }
    A=1 declare -i a='x[$(f1)]'

  % x ps1='$(:|declare -p A>&2)'
  %   A=1 echo "${ps1@P}"
  %   ... と思ったがこれは評価順序的に失敗するのが正しい?

  o A=1 unset 'a[$(:|declare -p A >&2)]'
  x A=1 let 'a[$(:|declare -p A >&2)]'
  x A=1 declare -a a=(['$(declare -p A >&2)']=1)

  x A=1 builtin eval ':; declare -p A'
    何とこれでも駄目という事が判明した。pipe は実は関係なくて、
    一回でもコマンドを実行すると tempenv が消滅してしまうという事の様だ?

    つまり本来は tempenv を設定した文脈で tempenv を削除するべき所が、中でコマ
    ンドを実行した時にそのコマンドの tempenv と勘違いして tempenv が削除されて
    いるという事?

  ? そもそも何がどうなって変数が消滅するのだろうか

    | 実際に変数を探し出す関数は find_variable である。更に
    | find_variable_internal を呼び出している。調べると tempenv を確認する条件
    | があって、search_tempenv という変数等を初期化している。文脈によって
    | tempenv を確認する条件が異なっていて tempenv を普通の変数に昇格し忘れてい
    | ると tempenv が見えなくなるという事なのかと思ったが違う様だ。
    | search_tempenv の条件はちゃんと満たされていて然し tempenv 自体が null に
    | なっているのが問題の様だ。

    find_variable_internal の中で temporary_env == NULL になっている。

    | temporary_env が空になる箇所を特定したい。空にしている箇所は以下の通り:
    | flush_temporary_env, dispose_temporary_env. 他に trap.c の中で一時的に
    | tempenv を 0 にしている箇所があるが、これは現在は関係ないと思って良いだろ
    | うという気がする。
    |
    | - subst.c: flush_temporary_env は subst.c の中からコマンド置換・プロセス
    |   置換が redirection の中で実行されている時に実行されている様だ。試してみ
    |   ると確かにその様に振る舞っている気がする (本当にこの部分のコードによっ
    |   てそれが実現されているのかは分からないが)。
    |
    | - execute_cmd: 問題の箇所で NULL を代入している。これは builtin の呼び出
    |   しに関連する所である。問題は pipe の中の位置によって tempenv が NULL だっ
    |   たりそうでなかったりする事なので、実はここで NULL が代入されている事は
    |   関係ない気がする。或いは、何処かの時点で tempenv が復元されている?
    |
    | - execute_cmd: 関数呼び出しの箇所でも NULL を代入している。但し、その直前
    |   で push_context を呼び出している。これが何を目的とした物なのかは謎であ
    |   る。
    |
    | 調べると dispose_temporary_env で tempenv が空になってそのまま変数が見つ
    | からないという事の様に見える。何れにしても tempenv=new して tempenv=NULL
    | していて、
    |
    | 1 tempenv=new は assign_in_env の中で実施され、assign_in_env は
    |   expand_word_list_internal の中から呼び出されている。
    |   expand_word_list_internal は eflags & WEXP_VARASSIGN の時に変数への代入
    |   も実行している。そして、tempenv は必要になった時にその時点で作成される
    |   様だ。
    |
    | 2 tempenv=NULL は dispose_temporary_env で起こり、dispose_temporary_env
    |   は dispose_used_env_vars から呼び出される。dispose_used_env_vars は
    |   execute_command_internal の中で呼び出される。つまり、現在のコマンドに対
    |   応する tempenv かどうかに関係なくコマンドを実行する度に tempenv は削除
    |   されてしまうという事。

    tempenv は必要になった時に、変数代入の処理の際に勝手に作成される。変数代入
    の処理は単語展開のコードの中で行われているので、コマンド実行側では tempenv
    生成は関知しない。コマンドが終了する度に tempenv は削除される。

    多分、これで何が起こっているのか大体分かった。

  ? この様な設計になっているという事は、実のところ eval を実行する段階で
    tempenv を待避しておくべきなのではないだろうか。

    /* The temporary environment for a builtin is supposed to apply to
       all commands executed by that builtin.  Currently, this is a
       problem only with the `unset', `source' and `eval' builtins.
       `mapfile' is a special case because it uses evalstring (same as
       eval or source) to run its callbacks. */

    この部分を読む限りに於いては source/eval/mapfile に関しては、
    evalstring を実行する段階で待避を実行しておけば良いのではないか。

    - evalstring は parse_and_execute を内部的に用いている。

      | ./builtins/eval.def:56:  return (list ? evalstring (string_list (list), "eval", SEVAL_NOHIST) : EXECUTION_SUCCESS);
      | ./builtins/mapfile.def:132:  return evalstring (execstr, NULL, flags);
      | ./trap.c:437:         evalstring (savestring (trap_list[sig]), "trap", SEVAL_NONINT|SEVAL_NOHIST|SEVAL_RESETLINE);
      |
      | eval.def は eval の実行。mapfile.def は mapfile の実行。
      | これらは明示的に execute_cmd で tempenv に対する対策がされている。
      | trap.c に関しては前後で tempenv を退避している。

    - 配列添字の展開もコマンド置換を通して parse_and_execute を用いている。

      | let や declare の配列添字の展開に関してはコマンド置換を確認すれば良いの
      | では。コマンド置換のコードを確認すると parse_and_execute を用いている。
      | subst.c で parse_and_execute を用いているのはコマンド置換とプロセス置換。
      | と思ったが $() 及び <() に関しては temporary_env に対して何かしていた様
      | な…  と思ったが、それは $() 及び <() が redirection の中にいる時に
      | tempenv を見えない様にするという処置だったので parse_and_execute で
      | tempenv を固定する事は関係ない。

    - parse_and_execute は中で execute_command_internal を呼び出している。

      | parse_and_execute の呼び出し元は以下の様にたくさんある。が滅茶苦茶沢山という訳でもない。
      |
      | ./bashline.c:973:  r = parse_and_execute (command, (editing_mode == VI_EDITING_MODE) ? "v" : "C-xC-e", SEVAL_NOHIST)
      | ./bashline.c:4343:  r = parse_and_execute (savestring (cmd), "bash_execute_unix_command", SEVAL_NOHIST);
      | ./builtins/evalfile.c:285:    result = parse_and_execute (string, filename, pflags);
      | ./builtins/evalstring.c:745:    r = parse_and_execute (string, from_file, flags);
      | ./builtins/fc.def:294:      return (parse_and_execute (command, "fc", SEVAL_NOHIST));
      | ./builtins/fc.def:490:  retval = parse_and_execute (command, "fc", SEVAL_NOHIST);
      | ./jobs.c:4286:      parse_and_execute (savestring (trap_command), "trap", SEVAL_NOHIST|SEVAL_RESETLINE);
      | ./parse.y:2737:  parse_and_execute (savestring (command), vname, SEVAL_NONINT|SEVAL_NOHIST);
      | ./shell.c:1440:   return (parse_and_execute (savestring (command), "-c", SEVAL_NOHIST|SEVAL_RESETLINE));
      | ./subst.c:6145:      rc = parse_and_execute (string, "process substitution", (SEVAL_NONINT|SEVAL_NOHIST));
      | ./subst.c:6505:   rc = parse_and_execute (string, "command substitution", pflags|SEVAL_NOHIST);
      | ./trap.c:954:     parse_and_execute (trap_command, "exit trap", SEVAL_NONINT|SEVAL_NOHIST|SEVAL_RESETLINE);
      | ./trap.c:1067:    parse_and_execute (trap_command, tag, flags);
      | ./variables.c:404:          parse_and_execute (temp_string, tname, SEVAL_NONINT|SEVAL_NOHIST|SEVAL_FUNCDEF|SEVAL_ONE
      |
      | - tempenv が存在しない様な条件下での実行
      |   - "C-x C-e" による編集結果の実行
      |   - "bind -x" によるコマンドの実行
      |
      |   実は上記の2つに関しては read -e の中で問題になる可能性があったが、
      |   read_builtin の時に tempenv を退避しているので実は問題にならない?
      |
      |   - parse.y: これは execute_variable_command であり、
      |     execute_variable_command は PROMPT_COMMAND の実行に使われている。
      |     PROMPT_COMMAND は tempenv は関係ない。
      |
      |   - shell.c: これは -c で指定されたコマンドを実行するのに使っている。
      |
      |   - evalfile.c: force_execute_file (bashdb-main.inc),
      |     maybe_execute_file (bashrc, profile, etc). これらは本当に tempenv
      |     が存在しないと断言できるか不明。多分大丈夫。
      |
      |   - variables.c: initialize_shell_variables
      |     これは環境変数からの関数定義の import の時に使う parse_and_execute である。
      |   - trap.c (run_exit_trap)
      |
      | - tempenv を明示的に退避している環境での実行
      |   - jobs.c: これは trap SIGCHLD の呼び出しである。
      |     前後で明示的に tempenv を退避している。
      |   - trap.c: これも前後で tempenv を退避している。
      |
      | - execute_command の側の対策により tempenv が固定されているケース
      |
      |   - fc.def: ここでの parse_and_execute は FCEDIT の実行に使っているだけ。
      |     但し、FCEDIT の中で変数を参照しても良いのではないかという説もある。
      |     が普通に考えたら FCEDIT には単純なコマンド名を指定するべきである。
      |
      |     然し、fc_builtin を実行する時に tempenv を固定しているので、これに
      |     ついては実際には問題は起こり得ない。
      |   - evalfile.c: fc, source
      |
      | - 問題が起こると判明しているケース
      |   - subst.c: プロセス置換 及び コマンド置換。declare や let 等の添字で
      |     問題になる。
      |   - evalstring.c: これは別途確認する。
      |
      | ? ok: fc は bash-5.0 では fc_builtin に対する対策が追加されている。
      |
      |   | fc に関してはそもそも普通に tempenv が無効化されている? 何故? 実際
      |   | に実行に使っているのは fc_execute_file で source と実質的に同じ筈。
      |   | 不思議である。fc.def や evalfile.c の中では temporary_env に対して
      |   | 一切触れていない。それにも関わらず tempenv が見えないのは不思議。
      |   |
      |   | うーん。bash-5.0 で試してみたらちゃんと fc の中からも tempenv が見
      |   | えていて、コマンドを実行する時に消滅してしまうという悲しい現象も起
      |   | こっていない様に見える。と思ったら fc_builtin に関しては明示的に対
      |   | 策が追加されていた。

      parse_and_execute の呼び出し元で問題が起こりそうな物は、
      既知の declare, let しか存在しなかった。

    - execute_command の呼び出し元を確認する。

      | ./builtins/command.def:140:  result = execute_command (command);
      | ./builtins/jobs.def:206:  result = execute_command (command);
      | ./eval.c:170:         execute_command (current_command);
      | ./execute_cmd.c:2707:      execute_command (command->value.Connection->first);
      | ./execute_cmd.c:2778:      exec_result = execute_command (command->value.Connection->first);
      | ./execute_cmd.c:2794:     exec_result = execute_command (second);
      | ./execute_cmd.c:2934:      retval = execute_command (for_command->action);
      | ./execute_cmd.c:3096:      body_status = execute_command (arith_for_command->action);
      | ./execute_cmd.c:3434:      retval = execute_command (select_command->action);
      | ./execute_cmd.c:3577:             retval = execute_command (clauses->action);
      | ./execute_cmd.c:3639:      return_value = execute_command (while_command->test);
      | ./execute_cmd.c:3666:      body_status = execute_command (while_command->action);
      | ./execute_cmd.c:3698:  return_value = execute_command (if_command->test);
      | ./execute_cmd.c:3708:      return (execute_command (if_command->true_case));
      | ./execute_cmd.c:3717:      return (execute_command (if_command->false_case));
      |
      | 殆どは execute_cmd.c からの内部的な呼び出しである。
      |
      | - command.def については command_builtin からの呼び出し。これはその場で単
      |   一のコマンドの実行の為に生成されたコマンドを実行するのに使われている。
      |   単一のコマンドなので tempenv が消える等の事は気にしなくて良い。
      | - jobs.def は jobs -x という機能による単一コマンド実行の様である。
      |   bash のマニュアルを見た。jobs -x ... は command ... と同様だが、
      |   ... に含まれる jobspec をジョブの group id (pid) に置き換えてから実行する様だ。
      |   これも command.def の仲間である。
      | - eval.c reader_loop での実行は普通にユーザからの入力を読み取って実行する
      |   時に使う様である。然し、readline による読み取りとはまた別の様である。直
      |   接 yyparse を呼び出しているので。何れにしてもこれについては reader_loop
      |   関数が main からしか呼び出されていないので、外側で tempenv が設定されて
      |   いるという状況は考えにくい。他にloadable builtin で reader_loop を呼び
      |   出している物もあるが気にしなくて良い。
      |
      | execute_cmd.c 内部からの呼び出しはどうも構文の呼び出しの様である。
      | 構文の呼び出しの場合には中で複数のコマンドを実行する時に tempenv が消滅すると困るが、
      | 実のところ、構文キーワードに tempenv を設定する事はできないので問題ない。
      |
      | - A;B 全体に対する tempenv はない。
      | - A&&B や A||B 全体に対する tempenv もない。
      | - その他の for while select while if { に対する tempenv もない。

      これらについては特に tempenv の固定は実行しなくても良い。

    - やはり execute_command_internal で tempenv を push/pop するべきか?
      と思ったが、parse_and_execute は中で沢山のコマンドを実行する。
      毎回 push/pop していたら効率が悪いのでやはり parse_and_execute の側で
      tempenv の push/pop を行うべきの様な気がする。

      | ./execute_cmd.c:736:      exec_result = execute_command_internal (command, 1, pipe_in, pipe_out, fds_to_close);
      | ./execute_cmd.c:990:     execute_command_internal again with asynchronous still set to 1,
      | ./execute_cmd.c:1006:       execute_command_internal (command, 1, pipe_in, pipe_out,
      | ./execute_cmd.c:1014:       execute_command_internal (command->value.Group->command,
      | ./execute_cmd.c:1377:      rv = execute_command_internal (command, asynchronous, pipe_in, pipe_out, fds_to_close)
      | ./execute_cmd.c:1686:    return_code = execute_command_internal ((COMMAND *)tcom, asynchronous, NO_PIPE, NO_PIPE,
      | ./execute_cmd.c:2544:      execute_command_internal (cmd->value.Connection->first, asynchronous,
      | ./execute_cmd.c:2594:  exec_result = execute_command_internal (cmd, asynchronous, prev, pipe_out, fds_to_close);
      | ./execute_cmd.c:2677:      exec_result = execute_command_internal (tc, 1, pipe_in, pipe_out, fds_to_close);
      | ./execute_cmd.c:2689:     exec_result = execute_command_internal (second, asynchronous, pipe_in, pipe_out, fds_to
      | ./execute_cmd.c:2709:      execute_command_internal (command->value.Connection->first,
      | ./execute_cmd.c:2716:      exec_result = execute_command_internal (command->value.Connection->second,
      | ./execute_cmd.c:2760:        execute_command_internal again.  Leave asynchronous on
      | ./execute_cmd.c:2764:     exec_result = execute_command_internal (command, 1, pipe_in, pipe_out, fds_to_close);
      | ./execute_cmd.c:2780:      exec_result = execute_command_internal (command->value.Connection->first, 0, NO_PIPE,
      | ./execute_cmd.c:5099:     result = execute_command_internal (fc, 0, NO_PIPE, NO_PIPE, fds_to_close);
      | ./execute_cmd.c:5107:      result = execute_command_internal (fc, 0, NO_PIPE, NO_PIPE, fds_to_close);
      |
      | - A &
      | - time
      | - ()
      | - A&B, A;B, A&&B, A||B
      | - 関数本体の実行: 関数呼び出しについては tempenv を固定している。

      これらは全て文法的に tempenv が存在しないので気にしなくて良い。

    - execute_command_internal
      - parse_and_execute
        - コマンド置換・プロセス置換
        - evalstring
          - eval, mapfile, EXIT trap
      - execute_command

    * loadable builtin push の reader_loop で変な事が起こる気がする。

    * 結論から言って parse_and_execute で tempenv の固定を行うべき気がする。

      | 然し、VC_BLTENV という種類のスコープであるという事を設定している。これは
      | 何処で使われるのか。vc_isbltnenv, vc_istempenv, vc_istempscope の判定で参
      | 照している。vc_istempenv については BLTENV の時には false になる。
      |
      | ./variables.c:3277:      if (vc_isfuncenv (vc) || vc_isbltnenv (vc))
      |   これは変数に値を代入する時に一番上のスコープの変数を探す時に、
      |   そのスコープが有効な物かどうかの判定に使っている。
      |
      | ./variables.c:5273:      if ((vc_isfuncenv (shell_variables) || vc_istempenv (shell_variables)) && shell_variables->
      |   push_posix_tempvar_internal の中で。一番上のスコープに変数を作成する時に、
      |   func/tempenv の時にはちゃんと hash_table が != NULL である事を確認する時に判定している。
      |   bltenv の場合には shall_variables が NULL だとずっと NULL である。
      |
      |   | というか逆にそれ以外の文脈だったらどうなるのか謎である。変数を作成する
      |   | 事ができない? memleak になる気がする。或いは実際にその様な状況にはなら
      |   | ないと考えて良いのだろうか。
      |   |
      |   | pop_scope
      |   |   push_func_var/push_builtin_var
      |   |     push_posix_tempvar_internal (*, 0)
      |   |       bind_variable_internal (name, value, (HASH*) NULL, 0, 0)
      |   |         make_new_variable (name, (HASH*) NULL)
      |   |           hash_insert (name, (HASH*) NULL, HASH_NOSRCH)
      |   |
      |   | 一つの可能性は non-POSIX モードで push_builtin_var が呼び出される場合。
      |   | push_builtin_var は pop_scope からしか呼び出されない。そして pop_scope
      |   | では shell_variables から変数を拾って、shell_variables を一段 pop して
      |   | から push_builtin_var を書き出している。
      |   |
      |   | * うーん。調べると push_scope しているのは VC_BLTNENV だけであり、そし
      |   |   て VC_BLTNENV が実行されているのは一箇所のみである。つまり、問題の
      |   |   execute_cmd で builtin を実行する箇所。この時、必ず non-empty な
      |   |   tempenv を指定しているので、VC_BLTNENV に対して table が NULL である
      |   |   という状況は起こり得ない。
      |   |
      |   | memleak が起こるとすれば funcenv でも tempenv でも bltnenv でもない何ら
      |   | かの文脈の上でこれが起こらなければならないが…。辿っていくと、
      |   | new_variable_context という関数で variable context が作成され、この時に
      |   | vctx の flags が設定される。
      |   |
      |   | * new_variable_context を調べると global context を作成する時に
      |   |   create_variable_tablesが呼び出されるがこの時は table は即座に新しい
      |   |   hash テーブルが割り当てられる。
      |   |
      |   | * 他に、maybe_make_export_env という関数でも が設定される。
      |   |   new_variable_context (name, 0) 呼び出されるが、この時にも table は即
      |   |   座に割当がある。
      |   |
      |   | という訳で、そもそも vc_isfuncenv/vc_istempenv 以外で table == NULL に
      |   | なっている状況は存在しないと見て良い。
      |
      |   memleak がある様に見えるが、FUNCENV/TEMPENV 以外の時には
      |   shell_variables->table は常に最初から初期化されているので NULL になって
      |   いる事はない。なので、5273-5274 を通過した時点で table != NULL が保証さ
      |   れている。なので memleak は存在しない。
      |
      | ./variables.c:5424:  if (vc_istempscope (vcxt) == 0)
      |   pop_scope で。これは tempscope 以外は pop できない様にする措置。
      |   tempscope は VC_TEMPENV|VC_BLTNENV である。
      |
      | ./variables.c:5429:  is_bltinenv = vc_isbltnenv (vcxt); /* XXX - for later */
      |   これは使われていない変数である。

      うーん。VC_BLTNENV という種類の文脈があるという事を考えると、
      parse_and_execute の中で勝手に scope を作りにくい。
      やはり、execute_cmd の中で頑張る?

    ??? hash_insert で table に NULL を渡した時に内部で table を作成しているが、
      これはおかしいのではないか。memleak なのではないか。然し、実際に NULL を
      渡さない様に気をつけていれば実際的な問題は生じない。

    ??? declare で tempenv を固定する様にした時に、A=1 declare -x A (A が外の環
      境に propagate する) 等の動作が変わってしまうかもしれない。確認が必要であ
      る。

      →うーん。A=1 declare -x A はちゃんと動くけれども、A=1 export A 及び A=1
      readonly A は動かなくなってしまう。何故だろう。

      うーん。実装を確認すると att_propagate を付加する時に、declare では tv &&
      tempvar しかチェックしていないけれども、readonly/export ではそれに加えて
      posix || compat <= 44 もチェックしている。

      またその他の疑問として VC_BLTNENV に待避しない限りに於いては
      readonly/export は共に tempenv が漏れているという事。

  ? command だと大丈夫で builtin だと駄目な理由は?

    builtin は直接中で builtin 関数ポインタを呼び出している。
    一方で command は execute_command を用いて実行しているので、
    最初の単語に基づいて tempenv の固定が行われる。

  ? should_keep 等のフラグで何かしているがこれは一体何だろうか。

2019-12-17

* shadow がそのままになってしまう。
  というかこれについては既にコメントが書かれている。

  $ bind '"\C-t\C-t\C-t\C-t":"hello"'
  $ bind -x '"\C-t":echo world'
  $ bind -r '\C-t\C-t\C-t\C-t'
  $ #<-- <C-t> 500ms 後に world が表示される

  ■これは保留

2016-11-09

* sv_isrchterm

  - さて rl_translate_keyseq を使っている箇所を見てみたが、折角 len で長さを受け取っても
    結局それを null-terminated string に変換している。これだと意味ないのではないか。
    例えば sv_isrchterm という関数で _rl_isearch_terminators の更新を行っている。

  ★isearch-terminator に C-@ を指定しても使えない気がする。
  ★emacs-mode-string, vi-cmd-mode-string, vi-ins-mode-string にも似たような問題がある気がするが、
    これは単に出力するだけなので NUL がある場合に其処で途切れていても問題は生じない。


-------------------------------------------------------------------------------
  Done
-------------------------------------------------------------------------------

2022-09-30

* reply7: https://lists.gnu.org/archive/html/bug-bash/2022-09/msg00059.html [#D0035]

  (gdb) bt
  #0  0x00007ffff7d5b7fd in __strlen_avx2 () from /lib64/libc.so.6
  #1  0x00000000004cff6e in sh_backslash_quote ()
  #2  0x000000000047837c in expand_word_internal ()
  #3  0x000000000047ddba in expand_arith_string ()
  #4  0x000000000043fd06 in execute_command_internal ()
  #5  0x00000000004ae8c1 in parse_and_execute ()
  #6  0x000000000042417a in run_one_command.isra ()
  #7  0x0000000000422bda in main ()
  (gdb)

  tag: patch.r007-subst-handle-null-substring

2022-07-18

* report31: 2021-08-24 ${param//pat/&} [#D0034]

  https://lists.gnu.org/archive/html/bug-bash/2021-08/msg00165.html
  https://lists.gnu.org/archive/html/bug-bash/2021-08/msg00166.html
  https://lists.gnu.org/archive/html/bug-bash/2021-01/msg00215.html

  ここで ${param//pat/&} で & が一致文字列に変換されるとしている。
  然し実際に試してみるとこれはかなり際どい変更の様な気がする。

  ./bash --norc
  $ a='(&)' b='XXX,YYY,ZZZ'
  $ echo "${b//[X-Z][X-Z][X-Z]/(&)}"
  (XXX),(YYY),(ZZZ)
  これは良い。
  $ echo "${b//[X-Z][X-Z][X-Z]/$a}"
  (XXX),(YYY),(ZZZ)
  これもまあ分からなくはない。

  $ echo "${b//[X-Z][X-Z][X-Z]/'(&)'}"
  (XXX),(YYY),(ZZZ)
  $ echo "${b//[X-Z][X-Z][X-Z]/"$a"}"
  (XXX),(YYY),(ZZZ)

  これは困る。更に、literal & を含める手段が存在しない気がする。

  $ echo "${b//[X-Z][X-Z][X-Z]/\&}"
  XXX,YYY,ZZZ
  $ echo "${b//[X-Z][X-Z][X-Z]/'&'}"
  XXX,YYY,ZZZ
  $ echo "${b//[X-Z][X-Z][X-Z]/"&"}"
  XXX,YYY,ZZZ
  $ echo "${b//[X-Z][X-Z][X-Z]/"\&"}"
  \&,\&,\&

  まあ、未だ有効にはしていないし不完全な実装という事なのだろう。何れもっとちゃ
  んとした実装になるのだろうと思う。"tagged" というのは後でちゃんと実装する予定
  という意味なのだろうという気がする。

* report22: [2021-12-21] trap handler の中で jobs を実行すると偽情報が表示される [#D0033]
  ble.sh #D1435 で判明した事。

  具体的には trap handler の中で fork をすると、
  その fork したプロセスの情報が jobs に登録されている。
  trap handler の中、または、bind -x の中で jobs を実行すると、
  そのプロセスの情報が出力される。
  ユーザコマンドとして jobs を実行した場合には何も起こらない。

  再現1
    $ trap '(true); jobs' WINCH
    [resize]

  再現2
    $ trap '(true); jobs' INT
    [C-c]

  再現3
    $ trap '(true)' WINCH
    $ bind -x '"\C-t": jobs'
    [resize][C-t]

  再現4 (再度してみたが再現しない?)
    $ trap '(true)' INT
    $ bind -x '"\C-t": jobs'
    [C-c][C-t]

  | jobs_builtin を見ると jobs.c の中の関数を呼び出している。
  | jobs という配列が存在してそこにジョブ一覧を記録している様子である。
  | ジョブの情報を更新している箇所を調べる。
  |
  | $ grc '\bjobs\[.* = '
  | ./jobs.c:577:   jobs[i] = (JOB *)NULL;
  | ./jobs.c:625:   jobs[j] = (JOB *)NULL;
  | ./jobs.c:675:      jobs[i] = newjob;
  | ./jobs.c:1414:  jobs[job_index] = (JOB *)NULL;
  | ./jobs.c:3018:            jobs[job]->state = JDEAD;
  | ./jobs.c:4039:      jobs[job]->state = JSTOPPED;
  | ./jobs.c:4048:      jobs[job]->state = JRUNNING;
  | ./jobs.c:4053:      jobs[job]->state = JDEAD;
  | ./jobs.c:4068:    jobs[job]->j_cleanup = (sh_vptrfunc_t *)NULL;
  | ./jobs.c:4172:  for (i = 1, p = jobs[j]->pipe; p->next != jobs[j]->pipe; p = p->next, i++)
  | ./jobs.c:4828:  jobs[i]->state = JDEAD;
  |
  | うーん。newjob だろうか。stop_newline という関数でこれは代入されている。
  | この stop_newline という関数がどのタイミングで呼び出されるのか調べる必要がある。
  | 確認した所、全てのパイプラインの実行で stop_newline 経由でジョブが登録される様子だ。
  | つまり何が問題になっているかというと jobs を実行するタイミングで
  | 既に削除されているべき jobs が残ってしまっているのが原因という事。
  |
  | jobs を削除している箇所について調べる。
  | ジョブの列挙は nonzero jobs[i] に対して行われている。
  | つまり、jobs[i] = NULL を代入している箇所でジョブが削除されている物と思って良い。
  | 577, 625 は新しくスロットを追加した時に初期化するのに使っている。
  |
  | どうやら振る舞いを観察すると、
  | 通常の文脈で (true);jobs を実行すると
  | (1) ジョブ追加 (2) ジョブ削除 (3) jobs実行 の順序で実行されるが、
  | trap handler の内部で実行すると
  | (1) ジョブ追加 (2) jobs 実行 (3) ジョブ削除の順で実行される様である。
  | この順番の制御は意図的な物である可能性が高い。
  |
  | delete_job の呼び出し元を観察する? delete_job は jobs.c 自身から呼び出される。
  | 4箇所から呼び出されている。
  |   - cleanup_dead_jobs
  |   - delete_old_job
  |   - wait_for_any_job これは関係ない
  |   - delete_all_jobs これも関係ない
  | 調べると両者とも cleanup_dead_jobs が呼びされている。
  | cleanup_dead_jobs の呼び出し元を調べると色々な所で呼び出されている。
  | というより stop_pipeline からも呼び出されている。
  | 然し、これまでの結果より複数の fork があると複数の job が累積する。
  | という事を考えると cleanup_dead_jobs 自体を呼び出すかどうかではなくて、
  | cleanup_dead_jobs を呼び出しても job が削除されない条件を調べるべき。
  |
  | そして実際に cleanup_dead_jobs の実装を確認すると、
  | jobs_list_frozen という変数が true の時には job が削除されない様になっている様だ。
  | これの振る舞いについて確認する。と思って振る舞いを確認したが、
  | jobs_list_frozen は常に 0 になっていた。これは関係ない。
  | 結局別の条件によって削除が抑制されているという事が分かった。
  |
  | IS_NOTIFIED(i) が false になるとジョブが削除されずに残る。
  | 然し、後で削除されるところを見ると IS_NOTIFIED(i) の状態は変化する?
  | IS_NOTIFIED は ((jobs[j]->flags & J_NOTIFIED) != 0) に展開される。
  | J_NOTIFIED で検索すると至る所で J_NOTIFIED が付加される。
  | J_NOTIFIED の書き換えを追跡する事にする。
  |
  | 通常の文脈だと notify_of_job_status によって
  | J_NOTIFIED が付加されてジョブが削除される。
  | trap handler の中だとこれが実行されずに、
  | jobs が実行された時に初めて J_NOTIFIED が付加される。
  |
  | notify_of_job_status 自体は3箇所 jobs.c で内部的に呼び出されている。
  | 関係がありそうなのは、notify_and_cleanup で呼び出し元は以下の通り。
  |
  |   $ grc '\bnotify_and_cleanup\b'
  |   ./jobs.c:3239:      notify_and_cleanup ();
  |   ./parse.y:2340:   notify_and_cleanup ();
  |   ./trap.c:1166:      notify_and_cleanup ();
  |
  | notify_and_cleanup 自体が内部で対話モードかどうか等を見て
  | notify_of_job_status を呼び出すかどうか判定している。これが怪しい。
  | OK. この条件で振る舞いが変わっているという事が分かった。
  | 具体的には interactive という変数の値が 0 の時にはジョブ一覧が消去されない。

  此処までの纏め。

  * Bash では全てのパイプライン (サブシェル or 外部コマンド呼び出し)
    は取り敢えずジョブに登録される
  * 通常の文脈では notify_and_cleanup (恐らく parse より呼び出される)
    が呼び出された時に、終了したパイプラインは "通知済み" とマークされ、
    次の出力の前に速やかにジョブリストから削除される。
  * 非対話文脈 (trap 及び bind -x を含む) では、notify_and_cleanup は
    終了したパイプラインの削除を行わない。特に trap handler の中では、
    interactive == 0 になっている為にパイプラインが "通知済み" 状態にならない。

  * 少なくとも "パイプラインのジョブ情報は trap handler の中では通知す
    る" というのは意図的な実装ではなさそうである。然し、そうは言っても
    これを自然な振る舞いにしようと思うとコードを色々加えなければならない。
    それだと Chet に確実に蹴られる。もっとコードの構造を理解して、
    より自然な処理になる様に "コードの改良" という形にしないと適用されないだろう。

  ? 通常の文脈では何故終了したパイプラインが通知される事もなく消えるのか?
    →どうやら fg job の場合は以下の条件を満たした時にだけ通知する様だ。
      termsig && WIFSIGNALED (s) && termsig != SIGINT && termsig != SIGPIPE
      要するに何らかのシグナルによって終了した時にだけ通知を行う。

  ? bind -x の中で (true);jobs を実行した場合にも問題は起こっていない。何故?

  2021-02-09 この notify_and_cleanup について理解したい。

  > void notify_and_cleanup () {
  >   if (jobs_list_frozen) return;
  >   if (interactive || interactive_shell == 0 || sourcelevel) notify_of_job_status ();
  >   cleanup_dead_jobs ();
  > }

  interactive は現在の実行が対話モードかどうかを表す。これは bind や
  trap の中では 0 になる。一方で interactive_shell は現在のシェルが対
  話シェルかどうかを表す。ble.sh の環境では恐らく常に 1 である。
  sourcelevel は恐らく source スクリプトの中で 1 以上の値になる。

  つまり、対話シェルでかつ非対話な状況でかつ source の外でのみ
  cleanup_dead_jobs の実行がスキップされる。

  ? この様な状況は具体的には bind/trap 以外にどの様な場合が考えられる
    だろうか。

    関数の中や eval の中では外の状況がそのまま伝播する。対話モードは対
    話モードのままなのだろう。確かめた。関数呼び出しや eval では対話モー
    ドのままである。然し、一方で source の時には対話モードが解除される。
    という具合になっている。なので、interactive || sourcelevel という
    形になっているのである。

  * 非対話シェルや source の中ではちゃんと cleanup_dead_jobs は実行さ
    れる。然し、そうすると jobs を実行した時に色々と変なメッセージが出
    ないのは何故だろうか。

    うーん。単にジョブコントロールが off になっているからという事なの
    だろうか。終了したジョブは JDEAD になっているのは確かである。他に
    は stopped から running しかない。或いは mixed(?)。JDEAD の時、(1)
    シグナルを受け取ったか (2) バックグラウンドジョブかつジョブコントー
    ル有効時のみにジョブが出力される。

    そうすると bind/trap の中で走った fg ジョブが出力される機会はない
    気がするが、何故これが出力されてしまうのだろうか。不思議な事である。
    と思ったがよく考えたら違う。実際に出力されるのは jobs コマンドを実
    行したときで当てt、notify_and_cleanup によって為される訳ではない。

  問題は、何故 jobs コマンドが fg dead ジョブを出力するのかという事で
  ある。fg dead ジョブは出力しなくても良いのではないだろうか。

  jobs の実装は以下の関数を呼び出している。

  | void list_all_jobs (int format) {
  |   cleanup_dead_jobs ();
  |   map_over_jobs (print_job, format, -1);
  | }

  うーん。此処は cleanup_dead_jobs は fg dead は !notified でも削除す
  る、という具合に変更してしまっても良いのではないかという気がする。

  J_NOTIFIED が設置される箇所を列挙しておく。

  - notify_of_job_status, pretty_print_job
    これは出力したらもう出力しなくて良いという事。
    この場合には fg dead については出力しなくても notified が付加される。
  - wait_for_job, wait_for_signle_pid, kill_job
    これは wait/kill したらもう出力しなくて良いという事。
    一種の fg に変換するのに近いような操作であるので理解できる。
  - mark_dead_jobs_as_notified うーん。これは意図的な操作なので関係ない。
  - start_job これは分からない

  これは余り確認しても意味がない気がして来た。

  * wait_for_any_job にも怪しい部分がある。
    コメントには最初に終了した background job と書かれているが、
    実際には fg dead (unnotified) でも即座に終了してしまう気がする。

  この関数は何処から呼び出されている? wait -n から呼び出されている様だ。
  wait -n とは何だろうか。

  うーん。再現した。これも一緒に report するべきである。

  trap '(sleep 1;exit 11)&(exit 22);wait -n;echo "wait status: $?"' INT

  というか二箇所の修正が本当に必要だろうか→cleanup_dead_jobs の側の修
  正だけで直った。

  ----------

  然し、本当に foreground dead jobs を無条件に削除してしまっても良いの
  だろうか。foreground job であっても、何かで使う機会があるのではない
  か。うーん。使うというと notify_of_job_status か各種 print のコマン
  ドのみの気がする。各種 print で特に必要になるとは考えにくい。そうす
  ると notify_of_job_status において何らかのエラーを出力する場合に限ら
  れる。改めてコードを見ると、

    > s = raw_job_exit_status (job);
    > termsig = WTERMSIG (s);
    >
    > // これは foreground dead job には関係ない。
    > if (startup_state == 0 && WIFSIGNALED (s) == 0 &&
    >       ((DEADJOB (job) && IS_FOREGROUND (job) == 0) || STOPPED (job)))
    >   continue;
    >
    > // これは関係あるかもしれないが何か操作をするとしても J_NOTIFIED
    > // を付加して後で削除される様にする。そうでなければ何もしない。
    > if ((job_control == 0 && interactive_shell) ||
    >     (startup_state == 2 && (subshell_environment & SUBSHELL_COMSUB)) ||
    >     (startup_state == 2 && posixly_correct && (subshell_environment & SUBSHELL_COMSUB) == 0))
    >   {
    >     if (DEADJOB (job) && (interactive_shell || (find_last_pid (job, 0) != last_asynchronous_pid)))
    >       jobs[job]->flags |= J_NOTIFIED;
    >     continue;
    >   }
    >
    > switch (JOBSTATE (job))
    >   {
    >   case JDEAD:
    >     // interactive_shell == 0 ではないのでこれは関係ない
    >     if (interactive_shell == 0 && termsig && WIFSIGNALED (s) &&
    >         termsig != SIGINT &&
    >         termsig != SIGTERM &&
    >         termsig != SIGPIPE &&
    >         signal_is_trapped (termsig) == 0)
    >       {
    >         ...
    >       }
    >     else if (IS_FOREGROUND (job))
    >       {
    >         // 取り敢えず foreground dead job の時は此処に入って来る
    >         // WIFSIGNALED 状態の時には何か出力する
    >         if (termsig && WIFSIGNALED (s) && termsig != SIGINT && termsig != SIGPIPE)
    >           {
    >             ...
    >           }
    >       }
    >     else if (job_control)
    >       {
    >         ...
    >       }
    >     jobs[job]->flags |= J_NOTIFIED;
    >     break;

    そうすると foreground dead job に対しては (1) 何もしない (2)
    J_NOTIFIED をつけるだけ (3) WIFSIGNALED を出力して J_NOTIFIED をつ
    けるの三種類の操作しかない。うーん。(3) に該当する場合には残して置
    いた方が良い? 但し、foreground の時には print しない。

2021-10-06

* ok: 2021-09-10 巨大配列を unset してもメモリが解放されない [#D0032]

  これは libc の振る舞いが元からそうなっているので仕方がない。

  ----

  proc 29029 が "read -t" まで入力した時点で cpu 100% になって暫く固まる。最
  新版 ble.sh を reload しても再現する。新しく bash を起動すると再現しない。
  これはこのセッション特有の問題だろうか。

  →これは履歴を再読込したら発生しなくなった。 read -t で待たされた後に過去の
  履歴が autosuggestion で表示される事なども考えると履歴補完で何か時間がかかっ
  ていたという事なのかもしれない。

  と思ったがプロセスのメモリ使用量が物凄い事になっている。790MB も使用してい
  る。どういう事かと思ったら物凄く巨大な配列や変数が定義されているみたいだ。
  declare -p > a.txt とすると他の Bash インスタンスは 3MB 程度なのに対して
  29029 は 41MB の結果になっている。100M要素の配列や変数が沢山あるみたいだ。
  A, a, u, v 等の変数を削除して行ったら、2.7MBにまで減少した。然しメモリ使用
  量はそれでも 580MB のままである。何かメモリリークでもあるのだろうか。

  うーん。巨大配列を作るとその配列を削除してもメモリが開放されないバグがある
  みたいだ。bash-5.0, bash-dev で確認した。

  $ bash-dev --norc
  $ A=({000000..999999})
  $ unset A

  うーん。或いはヒープ管理の都合で断片化してしまって開放できない状態になって
  いるという可能性もある? 然し、配列を作成して削除した時にそれ以外に何か覚え
  ておくべきデータが残ったりするのだろうか。不思議である。うーん。やはりそう
  いうデータがあるとしても高々数十ぐらいだろうと思われてだとすれば開放できな
  いブロックも高々数十ぐらいの筈で、数百MB残るというのも変だし、何よりほんの
  少したりとも解放されていないのはかなり怪しい。

  bash-4.4 だとそもそも 100 万要素の配列を作るのに滅茶苦茶時間がかかる。2分17
  秒かかった。bash-4.4 でも全く解放されないという事が確認できた。うーん。

  更に bash-5.0 で eval 'A=({000000..999999}); unset A' としてもメモリを食っ
  たままになっている。なのでコマンド実行に関係する問題ではないと思われる。

  * 不思議な事に bash-5.0 で1回目の A=({000000..999999}) は一瞬で終わるが2回
    目の A=({000000..999999}) には滅茶苦茶時間がかかるという事に気づいた。や
    はり heap の問題だろうか。。

    $ time A=({000000..999999}); unset A

    real    0m0.665s
    user    0m0.578s
    sys     0m0.086s
    $ time A=({000000..999999}); unset A

    real    1m45.415s
    user    1m45.130s
    sys     0m0.077s

    変数名が違っていてもやはり長い時間がかかる様になってしまう。

    何か独自のアロケータを使っている可能性もある気がする。と思ったが bash の
    実装だと free を呼んでいるだけの気がするのでアロケータは使っていない様な
    気がする。然し分からないので後でちゃんと確認する。

    と思ったらこの問題に関しては bash-5.1 で修正されたみたいだ。

    bash-dev$ time A=({000000..999999}); unset A

    real    0m0.893s
    user    0m0.723s
    sys     0m0.169s
    bash-dev$ time A=({000000..999999}); unset A

    real    0m0.634s
    user    0m0.628s
    sys     0m0.005s

    bash-5.1$ time A=({000000..999999}); unset A

    real    0m0.863s
    user    0m0.711s
    sys     0m0.150s
    bash-5.1$ time A=({000000..999999}); unset A

    real    0m0.738s
    user    0m0.724s
    sys     0m0.013s

  * 具体的に調べてみることにする。とにかく unset でメモリが解放されないという
    事。unset は unbind_variable を呼び出している。unbind_variable は
    makunbound を呼び出している。makunbound は array_dispose を呼び出している。
    array_dispose (array.c) は array_dispose_element を呼び出している。
    array_dispose_element は最初の要素だけを削除している???? と思ったがその前
    の array_flush が実際には殆どの要素を削除している様だ。うーん。中身を見る
    とちゃんと free している様に見える。FREE(x) は何かと思ったら if(x)
    free(x) の事らしい。然し、そうだとしても少しも解放されないというのは確か
    におかしな事である。うーん。

    念の為に array_dispose_element の呼び出し回数を確認してみた。ちゃんと1M回
    呼び出されている。つまり、free を呼び出してもちゃんとメモリがシステムに返
    されるとは限らないという事。以下にも記述がある。

    https://stackoverflow.com/questions/15139436/why-free-doesnt-really-frees-memory

    うーん。使っている領域の数と確保されている領域の数が圧倒的に違ってきたら、
    いい感じに確保されている領域を開放していくという具合の実装を期待したがそ
    うでもない様だ。うーん。基本的に一度確保した小さなブロックはもう解放され
    ないと考えるべきなのだろうか。

    因みに大きな単一の文字列についてはちゃんと解放された。これは余りに大きな
    領域の場合にはシステムから直接確保して直接解放するからなのだろうと思われ
    る。

    これは結局 Linux/glibc の malloc の問題の様な気がする。一方で何故
    bash-5.0 と 5.1 で二回目以降の巨大配列の確保にかかる時間の差があるのかと
    いう疑問は未だ残っている。

    bisect すると 37adc8b9 らしい。本当だろうか? と思って中を確認した所
    lib/malloc/malloc.c を変更している。つまり bash は自前の malloc/free を実
    装してそれを使っているという事。メモリが全然解放されないのもこの実装が原
    因なのではないか。

    実際に internal_free の実装を確認すると単にリストの末尾に要素を追加してい
    るだけである。解放する気は全くない様だ。

    /* Put this block on the free list.  */
    CHAIN (p) = nextf[nunits];

2021-10-05

* r0032: unset -v 'a[`echo 1`]' で bad array subscript エラーが出る [#D0031]

  #D0029 において完全に直ったと思ったら今度は

    $ bash-dev -c "declare -A a; unset 'a[\`echo [0]\`]'"

  が動かない。これについては bash-4.0 でも駄目。

    $ bash-4.0 --norc
    $ declare -A a; unset 'a[`echo hello`]'
    bash-4.0: unset: a[`echo hello`]: bad array subscript

  というよりそもそも配列でも動作が怪しい。以下は bash-4.0, 5.1 で再現した。

    $ a[123]=123; declare -p a
    declare -a a='([123]="123")'
    $ unset 'a[`echo 123`]'; declare -p a
    bash-4.0: unset: a[`echo 123`]: bad array subscript
    declare -a a='([123]="123")'
    $ unset 'a[`echo`]'; declare -p a
    bash-4.0: unset: a[`echo`]: bad array subscript
    declare -a a='([123]="123")'
    $ unset 'a[`echo`123]'; declare -p a
    bash-4.0: unset: a[`echo`123]: bad array subscript
    declare -a a='([123]="123")'
    $ unset 'a[123`echo`]'; declare -p a
    declare -a a='()'
    $ a[123]=123
    $ unset 'a[123`echo`456]'; declare -p a
    declare -a a='([123]="123")'
    $

  どうも最初の ` までしか見ていない様な気がする。` が入っていたら一律でエラーに
  なるのかと思いきや、何か添字の後に ` があった場合には特に問題にならない。

  うーん。次の結果を見ると最初の ` までしか見ていないという訳でもない? 何故か `
  が閉じていないと何のエラーも発生しないが、それでも動かない。

    $ a[123]=123
    $ unset 'a[`echo]'; declare -p a
    declare -a a=([123]="123")
    $ unset 'a[`echo`]'; declare -p a
    bash-5.1: unset: a[`echo`]: bad array subscript
    declare -a a=([123]="123")
    $ unset 'a[123`echo]'; declare -p a
    declare -a a=([123]="123")

  算術式や printf -v の中ではちゃんと動いている。なので `...` が入っていても動
  いてしかるべき。

    $ x='arr[`echo 123`]=111'
    $ ((x))
    $ declare -p arr
    declare -a arr=([123]="111")

    $ printf -v 'a[`echo 123`]' hello
    $ declare -p a
    declare -a a=([123]="hello")

  これは別枠の問題の気がするけれども同時に修正する事にする。PATCH 報告は分ける
  かもしれない。

  [絞り込み]

  取り敢えず変な事が何処で起こっているのかについて確認する。unset から迫る事に
  する。以下のコマンドで振る舞いを調べる。

  $ ./bash -c 'a=(); unset -v "a[1\`echo\`2]"'

  skipsubscript を実行した段階ではちゃんと 1`echo`2 を抜き出す事ができている。

  assoc の時は expand_subscript_string を呼び出している。array の時には
  array_expand_index を呼び出している。と思ったらうーん。ちゃんと動いている。???
  改めて動かない例について確認する必要がある。以下が動かない。

  $ ./bash -c 'a=(); unset -v "a[\`echo 1\`]"'

  これについては…うーん。どうやら skipsubscript が、最初の文字が ` の時にだけ
  変な振る舞いをするという事の様である。2文字目以降の場合には特に問題は生じてい
  ない気がする。取り敢えずこれは修正する事にする。

  ...  i = start + 1;                /* skip over leading bracket */

  うーん。これだ。。。つまり、skipsubscript は [ をスキップする事を想定している。
  一方で unbind_array_element は [ の直後にポインタがある事を要求している。それ
  にも関わらず、unbind_array_element は直接ポインタを渡しているが為に、最初の文
  字が無視されているという事。

  ? ok: 然し、ここで疑問が生じる。何故 unset -v 'a[${x[0]}]' が動くのか? という
    事。或いは実は動いていなかった? →うーん。どうやら算術式では [] の入れ子を
    数える為に、{x[0]} となっていてもちゃんと [...] をスキップしてくれてちゃん
    と終端を探す事ができていたという事の様だ。

  とにかく skipsubscript で +1 するのをやめる様に実装するべきである。
  skipsubscript の flags として 2 に意味を持たせるのが一つの手である。但し既に
  使用している箇所で skipsubscript に flag 2 が混入し得る様では大変である。追跡
  する必要がある。というかその前に skip_matched_pair の呼び出し元から確認する必
  要がある。

  - ./subst.c:1849 (skipsubscript):  return (skip_matched_pair (string, start, '[', ']', flags));

    と思ったがこの skipsubscript の一箇所しか存在しなかった。

    - ./arrayfunc.c:1077:    len = skipsubscript (sub, 0, flags&VA_NOEXPAND); /* XXX */
    - ./arrayfunc.c:1240:     len = skipsubscript (t, 0, flags&VA_NOEXPAND);  /* VA_NOEXPAND must be 1 */
    - ./general.c:467:          newi = skipsubscript (string, indx, (flags & 2) ? 1 : 0);
    - ./expr.c:361:  flags = (isassoc && assoc_expand_once && already_expanded) ? VA_NOEXPAND : 0;
      ./expr.c:362:  return (skipsubscript (cp, 0, flags));

      これらは明示的に 1 or 0 なので OK

    - ./arrayfunc.c:1336 (array_variable_name):  ni = skipsubscript (s, ind, flags);        /* XXX - was 0 not flags */
      これは array_variable_name (s, flags, subp, lenp) からの呼び出しである。

      - ./arrayfunc.c:333:  vname = array_variable_name (name, (flags & ASS_NOEXPAND) != 0, &sub, &sublen);

        これは明示的に 1 or 0 である。

      - ./expr.c:1179:      value = (e == ']') ? array_variable_name (tok, tflag, (char **)0, (int *)0) : tok;
        tflag = assoc_expand_once && already_expanded;        /* for a start */

        うーん。これは現在の所は問題ないが、将来的に tflag に余分な物が含まれる様になった時に怖い。
        なので明示的に tflag ? 1 : 0 とする事にする? うーん。でも必要ないかもしれない。

      - ./arrayfunc.c:1372 (array_variable_part):  t = array_variable_name (s, flags, subp, lenp);

        - ./arrayfunc.c:1414:  var = array_variable_part (s, (flags&AV_NOEXPAND) ? 1 : 0, &t, &len);      /* XXX */
        - ./variables.c:3447:      v = array_variable_part (lhs, (flags & ASS_NOEXPAND) != 0, (char **)0, (int *)0);

          これは明示的に 1 or 0 である。

        - ./expr.c:1169:  v = (e == ']') ? array_variable_part (tok, tflag, (char **)0, (int *)0) : find_variable (tok);

          これは既に見た tflag であり、 assoc_expand_once && already_expanded なのでやはり 1 or 0 である。

  修正した。結局これは独立な問題である様に思われるので、別の patch として提出する事にする。

  →どうやら修正箇所に r0029 と重複がある様なので r0029 の方がついてから調整し
  て提出する。

2021-09-22

* report30: [bash-5.2] kP/kN bound to history-search-{backward,forward} 65822e50 [#D0030]
  prior が動かないと思ったら思い切りミスっている。。。

  lib/readline/terminal.c
    - look in terminfo for key sequences for page up (kP) and page down
      (kN) and bind them to history-search-{backward,forward},
      respectively. From a patch from Xose Vazquez Perez
      <xose.vazquez@gmail.com>

  @@ -415,6 +419,8 @@ static const struct _tc_string tc_strings[] =
     { "kD", &_rl_term_kD },^I/* delete */
     { "kH", &_rl_term_kH },^I/* home down ?? */
     { "kI", &_rl_term_kI },^I/* insert */
  +  { "kN", &_rl_term_kN },^I/* page down */
  +  { "kN", &_rl_term_kP },^I/* page up */
     { "kd", &_rl_term_kd },
     { "ke", &_rl_term_ke },^I/* end keypad mode */
     { "kh", &_rl_term_kh },^I/* home */

  これは報告した。直った。

* report29: 2021-09-08 declare -A a; unset 'a[${b[0]}]' で　segfault する [#D0029]

  ./bash -c "declare -A a; unset 'a[\${b[0]}]'"
  ./bash -c "declare -A a; unset 'a[\`echo [0]\`]'"

  #0  0x00007ffff7de4e35 in raise () from /lib64/libc.so.6
  #1  0x00007ffff7dcf895 in abort () from /lib64/libc.so.6
  #2  0x0000000000452fbf in programming_error ()
  #3  0x00000000004fd4d7 in internal_free.isra ()
  #4  0x0000000000474c10 in expand_word_internal.isra ()
  #5  0x00000000004774e0 in expand_subscript_string ()
  #6  0x000000000048890a in unbind_array_element ()
  #7  0x00000000004b0ed5 in unset_builtin ()
  #8  0x000000000043ad4b in execute_builtin.isra ()
  #9  0x000000000043f69f in execute_command_internal ()
  #10 0x0000000000442ac3 in execute_connection ()
  #11 0x000000000043dfd9 in execute_command_internal ()
  #12 0x00000000004a7191 in parse_and_execute ()
  #13 0x0000000000423f8b in run_one_command ()
  #14 0x0000000000422c0a in main ()

  問題が起こっているのは expand_word_internal の中である。実装を見ていると引数
  に渡している word->word は実はエラーの時には free されるという事を想定してい
  る様に見える。

  一方で、b19658360 で導入された expand_subscript_string からの
  expand_word_internal 呼び出しについては、呼び出し元で単に単語を word->word に
  設定して呼び出しを行っている。これは新しく文字列をコピーしてそれから呼び出す
  べきなのではないか。


  * そもそも unset で ${v[...]} が中途半端に抜き出されるのは変な気がする。

    a 修正案1: VA_ONEWORD を builtins/set.def (unset_builtin) で設定するか、或
      いは builtins/common.def (builtin_arrayref_flags) で設定するかすれば良い
      気がする。配列名を渡されている時点で assoc_expand_once であろうとなかろう
      と同様に処理するべきなのだという気がする。

      →これだと printf -v 'assoc[aaa]]' 等が普通に accept されてしまって不自然
      なので駄目という事なのだろう。この方針は却下。VA_ONEWORD は nameref で展
      開した後に assoc[aaa]] みたいになっているのを処理するための物の様に見える。
      この様な物を明示的に accept する為に assoc_expand_once を使うという事なの
      だろう。

    うーん。然し何故中途半端な位置まで切り取ってしまうのだろうか。これだと中途
    半端な位置で切り取られた場合には残りの文字列は無視されて処理されてっしまう
    気がする。或いは無視させる様な使い方があるのだろうか。と思って
    dict=([hello]=world); unset -v 'dict[hello]=1234' だとか unset -v
    'dict[hello]=1234]' だとかで試してみたが "有効な識別子ではありません" と表
    示されて何も操作はされない。うーん。既にチェックが走るのであればそもそも何
    故条件付きで ONEWORD の動作をしているのか分からないし、チェックが走っている
    のにも関わらず dict[${a[0]}] が中途半端に通過してクラッシュするのかも分から
    ない。"有効な識別子" かどうかを判定しているコードを使って添字を抜き出す事も
    できるのではないか。そしてその方が正確なのではないか。

    →これは valid_array_reference という関数で先に配列変数かどうかをチェックし
      ているからである。

    ? skipsubscript (subst.c) はどういう動作をするのだろうか。

      skipsubscript は skip_matched_pair を呼び出していて flags 引数 (特に
      flags&1) が 0 の時に、様々な quote や ${} $() を処理する様になっている。
      つまり、flags は "フラットに入れ子も何も考えずに処理します" という宣言な
      のだと思われる。

    ? valid_array_reference (arrayfunc.c:1187) の flags には何を指定するのか。

      (1) assoc かつ flags が VA_NOEXPAND|VA_ONEWORD を含んでいれば、既に展開済
        みと考えられるので、'arr['*']' の形をしていれば何でも良い事にする。

      (2) assoc の場合には skipsubscript を呼び出す。

        flags が VA_NOEXPAND を含んでいれば、'arr['/[^]]*/']' の形を全て受け付
        ける。但し skipsubscript を使って mbchar を考慮に入れて ']' を認識する。

        flags が VA_NOEXPAND を含んでいなければ入れ子を考慮に入れて対応する終端
        ']' が抽出される。然し、コメントには VA_NOEXPAND が指定されていなければ
        ならないという具合に書かれている。然し、この条件が崩れていたとしても
        (3) に進んで結局同じ処理になる。

        ■ここでの疑問は assoc の時に "flags が VA_NOEXPAND を含んでいなければ
        ならない" という想定が何か実装途中の時の一時的な可能性だったのか、或い
        は実際にそうなる様にコーディングしなければならない筈だったのかという事
        である。

      (3) それ以外の時には入れ子を考慮に入れて対応する ']' まで読み飛ばす。

    うーん。と思ったら。skipsubscript の呼び出しに於いても ${} $() を処理するか
    どうかを第三引数で指定する事ができる様になっている様だ。という事はこの
    skipsubscript に於いて適切な処理を実行するべきなのではないか?

    b 修正案2 skipsubscript (at unbind_array_element arrayfunc.c:1048) の呼び出
      しで flags 引数を調整する。

      上の valid_array_reference の実装と合わせるのであれば

      -len = skipsubscript (sub, 0, (flags&VA_NOEXPAND) || (var && assoc_p(var))); /* XXX */
      +len = skipsubscript (sub, 0, flags&VA_NOEXPAND); /* XXX */

      で十分の気がする。2つ目の条件指定については valid_array_reference のコメ
      ント "assoc では VA_NOEXPAND が指定されている" というのが対応しているのだ
      ろう。然し、assoc だからと言って常に literal に ] を見つけるというのは変
      だし、ちゃんと入れ子を考慮して終端を見つける様にするべきの気がする。

      ? うーん。この変更の side effect としては dict[v[0]] も accept される様に
        なるという事。確かに index array であればこそ [] の入れ子が考慮に入れら
        れるのであって、assoc の場合には [] の入れ子は考慮に入れないのだという
        考え方もあるのである。

        →${dict[v[0]]} は常にちゃんと処理される。という事を考えるとやはり
          assoc であっても [] を考慮に入れるべきなのだという気がする。

  * 他にも skipsubscript を呼び出している箇所はたくさんある。類似の問題が他にも
    あるのではないか。大抵の場所は 0 で呼び出している。これは入れ子を処理すると
    いう方向なのでOK。気にするべきは "入れ子を処理しない" という状況が使われる
    箇所である。

    ./arrayfunc.c:1048:    len = skipsubscript (sub, 0, flags&VA_NOEXPAND); /* XXX */
      ← unbind_array_element
    ./arrayfunc.c:1210:     len = skipsubscript (t, 0, flags&VA_NOEXPAND);
      ← valid_array_reference
    ./arrayfunc.c:1304:  ni = skipsubscript (s, ind, flags);        /* XXX - was 0 not flags */
      ← array_variable_name(s, flags, subp, lenp)

      ./arrayfunc.c:333:  vname = array_variable_name (name, (flags & ASS_NOEXPAND) != 0, &sub, &sublen);

        ←assign_array_element (name, value, flags)

        ./arrayfunc.c:355:  entry = assign_array_element_internal (entry, name, vname, sub, sublen, value, flags);
        ./arrayfunc.c:362:assign_array_element_internal (entry, name, vname, sub, sublen, value, flags)
        ./builtins/common.c:1007:    v = assign_array_element (name, value, bindflags);
        ./builtins/declare.def:952:       var = assign_array_element (name, value, local_aflags);       /* XXX - not aflags */
        ./subst.c:3298:      entry = assign_array_element (name, value, aflags);
        ./variables.c:3148:       entry = assign_array_element (newval, value, aflags|ASS_NAMEREF);
        ./variables.c:3305:                     return (assign_array_element (nameref_cell (nv), value, flags));
        ./variables.c:3470:    v = assign_array_element (lhs, rhs, flags);

      ./arrayfunc.c:1340:  t = array_variable_name (s, flags, subp, lenp);

        ← array_variable_part (s, flags, subp, lenp)

        ./arrayfunc.c:1382:  var = array_variable_part (s, (flags&AV_NOEXPAND) ? 1 : 0, &t, &len);      /* XXX */
        ./expr.c:1169:  v = (e == ']') ? array_variable_part (tok, tflag, (char **)0, (int *)0) : find_variable (tok);
        ./variables.c:3447:      v = array_variable_part (lhs, (flags & ASS_NOEXPAND) != 0, (char **)0, (int *)0);

      ./expr.c:1179:      value = (e == ']') ? array_variable_name (tok, tflag, (char **)0, (int *)0) : tok;

        TODO

    ./expr.c:362:  return (skipsubscript (cp, 0, flags));
      ← expr_skipsubscript(vp,cp)
        flags = (isassoc && assoc_expand_once && already_expanded) ? VA_NOEXPAND : 0;

      ./expr.c:1344:    e = expr_skipsubscript (tp, cp);              /* XXX - was skipsubscript */

    ./general.c:467:          newi = skipsubscript (string, indx, (flags & 2) ? 1 : 0);
    ./subst.c:1843:skipsubscript (string, start, flags)

    うーん。あらゆる所から呼び出されているから判断が難しい。逆に問題が起こりそ
    うな側から試していくべきなのかもしれない。

      printf -v XXX 及び read XXX は元から問題がなかった。今回の変更による影響
      もない。declare 'A[v[0]=123]=hello' の様な物に対しても今回の変更による影
      響はない。これらは何れも初めから自然な振る舞いになっていた。

  ----------------------------------------------------------------------

  完全に直ったと思ったら今度は

    $ bash-dev -c "declare -A a; unset 'a[\`echo [0]\`]'"

  が動かない。これについては独立した問題である事がはっきりしたので別項目で議論
  する → #D0031

2021-06-27

* 2021-06-09 report28: bash: 5.2 新機能 READLINE_ARGUMENT [#D0028]

  また早速バグがある様だ。M-1 M-2 etc 等として入力すると引数部分の検出に失敗し
  てまた bash_execute_unix_command 見つかりませんのエラーが表示される事になる。
  また vi-command でも同様の問題がある様だ。というか (arg: X) を表示できている
  のだからそれと同じに処理したら駄目なのだろうか。他の readline bindable
  function についても正しく引数を処理できているのだから、"bind -x" でも同様の処
  理によってちゃんと動いて然るべきなのではないのだろうか。

  そもそも根本的な修正をする為には現在の keymap entry を特定するのに使ったbyte
  数を使うべきなのではないだろうか。その情報は何処にもないのだろうか。調べたが
  digit-argument の中で次の文字を見て数字だったら処理して、そうでなければ
  _rl_dispatch を呼び出している。_rl_dispatch は単に一文字キーを読取る為の関数
  の様な気がする。但し、keymap を指定することができる。

  うーん。どうやら _rl_dispatch または _rl_dispatch_subseq を再帰的に呼び出して
  解析している様子である。そしてその都度 getkey で文字を読み取っている。一番外
  側で文字を読み出しているという訳でもない様だ。

  うーん。heuristic には M-{0..9} があったら全て取り除いてしまえば良い様な気が
  する。然し、binding が普通でない時にはどうしたら良いのか。うーん。取り敢えず
  既定の binding の場合について考える。digit-argument が呼び出された以上は、必
  ず何処かで digit-argument が始まって何処かでそれが終了すると考えられる。終了
  した時に改めて digit-argument が呼び出された時に digit-argument は前回の物に
  追記される形になる。

  うーん。最後の digit-argument の時に sequence を削除するか、或いは新しいグロー
  バル変数を用意して実際の seq に使われた keyseq 内の開始位置が分かる様にする
  か…。

* 2021-02-08 report26: bash: 沢山の行が含まれている時の ${v...} が全て N^2 で遅くなる [#D0027]

* [解消] 2021-02-08 gitstatus: gitstatus.plugin.sh が exec を上書きしている [#D0026]

  何故そんな事をする必要があるのだろうか。他に代替手段はないのだろうか。→これ
  に関しては gitstatus に Issue を立てて直して貰った。exec を上書きしない形で解
  決する事になった。

* [解消] 2021-02-08 bash-completion: #D0020 で報告した問題の返事を待っている状態 [#D0025]

  改めて尋ねた所、返答があった。

2021-03-01

* 2021-02-08 report21: Chet の Review 待ち [#D0024]

  これは結局 Chet が新しく追加した timeout.h を使って書き直した
  version が push された。

* 2021-02-08 report21: Copyright assignment をせよとの事 [#D0023]

  https://www.gnu.org/licenses/why-assign.ja.html
  https://www.gnu.org/prep/maintain/html_node/Copyright-Papers.html

  テンプレートは以下にある。

  https://git.savannah.gnu.org/cgit/gnulib.git/tree/doc/Copyright

  何故か request-assign.program と request-assign.future で宛先が異な
  る。情報が古いのだろうか。或いは管轄が異なるのだろうか。両方に送って
  みたが future の方しか返事がない。或いは、future は program を含んで
  いるので余計に assign する必要はないと判断されて future だけ返事が来
  たのだろうか。

  何れにしてもサインして送った。検索すると FSF の Copyright assignment
  には賛否両論がある様だ。FSF はちょっと過激な団体なので色々微妙かもし
  れないが、まあ、Bash で将来どうのこうのするという予定はないので大丈
  夫だろう。

  それから新しい Copyright Assignment についてアナウンスしても良いかと
  いう質問があったので OK と返答しておいた。

  microbloggin と言っているので調べたが恐らく GNU Social の様だ。調べ
  ると個人でやっているサーバーばかりで、自分でサーバーを建てる程でもな
  いし、知らない人の個人サーバーにアカウントを作る気もならない。そもそ
  も FSF は他人を信用しないので個人サーバーなのだろう。寧ろ大企業が大
  規模インスタンスを作ってる Mastodon の状況がおかしいのである。そして
  FSF が GNU Social で垂れ流している情報は恐らく以下のページで並んでい
  る物だろうと。。

  https://status.fsf.org/fsf

  Copyright assignment した人がいるとメッセージが機械的に流されている。
  味気も何もない物である。そして次から次へと流れている。多分、誰か偉い
  人が確認している訳でもないし、それどころか誰も気にしていない。これな
  ら別に了承しなくても良かった気がする。

  2021-02-26 copyright assignment のサイン付きの返事を貰った。というか、
  明らかに機械的に挿入されたサインである。こんなので良いのだろうか。

  > To check whether papers have been received, look in
  > /gd/gnuorg/copyright.list.  If you can’t look there directly,
  > fsf-records@gnu.org can check for you.  Our clerk can also check for
  > papers that are waiting to be entered and inform you when expected
  > papers arrive.
  >
  > The directory /gd/gnuorg mentioned throughout this document is
  > available on the general GNU server, currently fencepost.gnu.org.
  > If you are the maintainer of a GNU package, you should have an
  > account there.  If you don't have one already, see
  > https://www.gnu.org/software/README.accounts.html.  Such GNU login
  > accounts include email (see
  > https://www.fsf.org/about/systems/sending-mail-via-fencepost).

2021-02-15

* report21: Chet から readline の方も修正が必要との事。確かにそうだ [#D0022]
  返信をしたら readline の方もこちらで試しに実装してみる事になった。

  取り敢えずできる所から修正を加えていく事にしよう。
  interface がどうのこうのというのは実装してから修正すれば良いのである。


  Q rl_timeout_remaining: changed parameter type from `int' to
    `unsigned' following the declaration of `falarm'.

  Q 元の input.c の以下の部分はおかしくないか。empty_set に現在の
    sigmask を読み取ってそれを pselect に渡しているが、そもそも
    pselect に NULL を渡したら現在の sigmask が使われるのではないか。
    或いはそれに反する実装が存在するのだろうか。

    >       sigemptyset (&empty_set);
    >       sigprocmask (SIG_BLOCK, (sigset_t *)NULL, &empty_set);
    >       result = pselect (fileno (stream) + 1, &readfds, NULL, NULL, NULL, &empty_set);

    調べると bc3714724 で導入された物の様である。

  Q _rl_abort_internal を呼び出す方針はよくわからないので、READERR を返す事にした。

  * done: 自身でも SIGALRT を用意する事にする
    falarm は使えるのか。lib/sh の中にあるが…。
    include していない様な気がするが実の所実際にコンパイルしてみないと分からない。

  Q __MINGW32__ の時の実装?

  うーん。どうしても即終了してしまう。何故だろうか。
  と思ったが timepoint を clear していないのが問題?
  →これだった。timeout_duration は clear していたが、
  timeout_point を clear するのを忘れていた。

  Q rl_done と RL_STATE_DONE の使い分けは何だろうか。
    分からないので両方設定している。

  どうしても文章がくどくなってしまう。供養する。

  % so just calling _rl_abort_internal doesn't terminate the
  % processing. At the jump destination, some additional test, whether the
  % `longjmp' was caused by timeout or not, needs to be done. I initially
  % tried to carry the information of preferred treatment, READERR or EOF,
  % through `rl_pinding_input'. But this variable is cleared by
  % `_rl_abort_internal' so cannot be used. Next I tried to store READERR
  % or EOF to the buffer by `rl_stuff_char ()', however the buffer is a
  % sequence of unsigned char so that READERR or EOF cannot be properly
  % stuffed. Finally, I decided to add another RL_STATE flag
  % RL_STATE_TIMEOUT.
  %
  % There are a few questions. First, is there any expected behavior
  % difference of readline () when it gets READERR from rl_getc compared
  % to the case it gets EOF? They are handled in different control paths
  % but seem to behave effectively the same, that is,
  % `readline_internal_char' sets RL_STATE_DONE and rl_done and returns 1.

  実は既に同じ問題を報告している人がいた。

  https://lists.gnu.org/archive/html/bug-bash/2019-09/msg00054.html
  https://lists.gnu.org/archive/html/bug-bash/2016-11/msg00145.html
  https://lists.gnu.org/archive/html/bug-bash/2013-01/msg00138.html

  取り敢えず提出して一段落したので一旦閉じる。

2021-02-08

* 2021-02-06 report21: read -t がブロックしてしまう [#D0021]

  取り敢えず以下の構成で高確率で timeout に失敗するのが見られる。

  | #!/bin/bash
  |
  | rm -f a.pipe
  | mkfifo a.pipe
  | exec 9<> a.pipe
  | rm -f a.pipe
  | for c in {0..2000}; do
  |   (eval "echo {0..$c}" & read -u 9 -t 0.001) >/dev/null
  |   printf $'\r\e[Kok %d' "$c"
  | done
  | echo


  色々なシステムで計測してみたが少なくとも Linux, FreeBSD, Cygwin で確率的に再
  現している。Minix では再現しなかったがこれは偶々だろう。起こる頻度はシステム
  にも依存するし、bash version にも依存するし、コンパイル時の relstatus にも依
  存する。timeout の時間の長さにも依存するし、直前のプロセスが吐く標準出力の量
  にも依存する。状況に応じて特定の標準出力の量の時に起こりやすいなどの事がある
  様だ。

  | chatoyancy
  |   MACHTYPE: x86_64-unknown-linux-gnu (Fedora release 30 (Thirty))
  |   CPU: Intel(R) Core(TM) i7-7700 CPU @ 3.60GHz
  |
  |   * OK - GNU bash, 4.0.44(2)-release (x86_64-unknown-linux-gnu)
  |   * OK - GNU bash, 4.1.17(2)-release (x86_64-unknown-linux-gnu)
  |   * OK - GNU bash, 4.2.53(2)-release (x86_64-unknown-linux-gnu)
  |   * Fail - GNU bash, 4.3.48(1)-release (x86_64-unknown-linux-gnu)
  |   * Fail - GNU bash, 4.4.23(1)-release (x86_64-unknown-linux-gnu)
  |   * Fail - GNU bash, 5.0.18(1)-release (x86_64-pc-linux-gnu)
  |   * Fail - GNU bash, 5.0.7(1)-release (x86_64-pc-linux-gnu)
  |   * Fail - GNU bash, 5.0.16(1)-release (x86_64-pc-linux-gnu)
  |   * Fail - GNU bash, 5.0.18(1)-release (x86_64-pc-linux-gnu)
  |   * Fail - GNU bash, 5.1.0(1)-alpha (x86_64-pc-linux-gnu)
  |   * Fail - GNU bash, 5.1.0(1)-release (x86_64-pc-linux-gnu)
  |   * Fail - GNU bash, 5.1.4(2)-maint (x86_64-pc-linux-gnu) (Current devel fcad1d1)
  |
  | hp2019
  |   CPU: Intel(R) Core(TM) i5-8500 CPU @ 3.00GHz
  |   MACHTYPE: x86_64-unknown-linux-gnu (Fedora release 30 (Thirty))
  |
  |   * OK - GNU bash, 4.0.44(2)-release (x86_64-unknown-linux-gnu)
  |   * OK - GNU bash, 4.1.17(2)-release (x86_64-unknown-linux-gnu)
  |   * OK - GNU bash, 4.2.53(2)-release (x86_64-unknown-linux-gnu)
  |   * Fail - GNU bash, 4.3.48(1)-release (x86_64-unknown-linux-gnu)
  |   * Fail - GNU bash, 4.4.23(1)-release (x86_64-unknown-linux-gnu)
  |   * Fail - GNU bash, 5.0.7(1)-release (x86_64-redhat-linux-gnu)
  |   * Fail - GNU bash, 5.0.18(1)-release (x86_64-pc-linux-gnu)
  |   * Fail - GNU bash, 5.1.0(1)-release (x86_64-pc-linux-gnu)
  |
  | letsnote2019
  |   CPU: Intel(R) Core(TM) i5-7200U CPU @ 2.50GHz
  |   MACHTYPE: x86_64-unknown-cygwin (Cygwin)
  |
  |   * Fail - GNU bash, 4.4.12(3)-release (x86_64-unknown-cygwin)
  |
  |   MACHTYPE: x86_64-pc-linux-gnu (Arch Linux on VirtualBox)
  |
  |   * Fail - GNU bash, 5.1.4(1)-release (x86_64-pc-linux-gnu)
  |
  |   MACHTYPE: i386-portbld-freebsd12.0 (FreeBSD 12.0)
  |
  |   * Fail - GNU bash, 5.0.11(0)-release (i386-portbld-freebsd12.0)
  |
  |   MACHTYPE: i386-elf32-minix (Minix)
  |   Note: exec 9< <(sleep 60)
  |
  |   * OK - GNU bash, 4.3.0(1)-release (i386-elf32-minix)
  |
  |   MACHTYPE: i386-pc-solaris2.11 (Solaris)
  |
  |   * OK - GNU bash, 4.1.17(1)-release (i386-pc-solaris2.11)
  |
  | ln26
  |   MACHTYPE: x86_64-redhat-linux-gnu (CentOS Linux release 7.8.2003 (Core))
  |   CPU: Intel(R) Xeon(R) CPU E5-2678 v3 @ 2.50GHz
  |
  |   * OK - GNU bash, 4.2.46(2)-release (x86_64-redhat-linux-gnu)
  |   * Fail - GNU bash, 5.0.18(1)-release (x86_64-pc-linux-gnu)

  然し、再現条件がかなり特殊であることから単純にコードを見ても解決しないだろう
  という気がする。取り敢えず bisect をしかける事にしようか。bisect の使い方に浮
  いて先ずは調べる必要がある。

  | 10e784337238e6081ca5f9bdc8c21492f7b89388 is the first bad commit
  | commit 10e784337238e6081ca5f9bdc8c21492f7b89388
  | Author: Chet Ramey <chet@caleb.ins.cwru.edu>
  | Date:   Mon Mar 4 08:10:00 2013 -0500
  |
  |     commit bash-20130208 snapshot
  |
  | :100644 100644 8b579a4a679d56ebc1d7883764712356a4783295 33f721be4ad8a667c9c61114997ee5c8814380de M      CHANGES-4.3
  | :040000 040000 7835bcfa78a2e08722ed510cac2a5c21821808a8 96f9df818407352b01ed77f34139ef2d5af20f35 M      CWRU
  | :040000 040000 b9ba7671f57a49ffc7bca6820f7bd3af95fd3ed0 63edacf96a6b00e7af7de94cfecae953621f3cc3 M      autom4te.cache
  | :040000 040000 3ad1df80fbada3bf4f5ca1cd22b407fb22b4c4ab c2cc5e9932a325c450fa6c199daa324f43b29d10 M      builtins
  | :100755 100755 91c869da60ea7719d9f8b221ff39fd7d2261e34d a3ef6123574d724a9d084e50caa9fa720d729301 M      configure
  | :100644 100644 563ba2916172b09adde4f78265492104bfd08685 27aa19733651c0a05d9ef70e528a7bab0fa1247c M      configure.ac
  | :100644 100644 9227638c3c3eb56f1e1fe0394ab7db2a35911a4b 472f585fe1dd82292e6fa9ff1dad55048c4a24fa M      jobs.c
  | :100644 100644 98f62645939a72218dea89cb921a48394a64fe8d 61f0f7c5a8eeb1d0b848662bf7cc4d3961795e21 M      parse.y
  | :100644 100644 8df01e1fe9bcf3aafa0918cc54980e88a6002d72 7d447ab2b9b38cd05623a058c9e6527e22f47e61 M      quit.h
  | :000000 100644 0000000000000000000000000000000000000000 2f127da9927a053b69dde2f9bfef9a5b769eb862 A      quit.h~
  | :100644 100644 786d7f07a9f6304776eea0a01d9293fd6fab5084 016763a077d9cf8c33f3efb9b5ad0a5bf40f38a6 M      test.c
  | :100644 100644 d60a7fb45e71f484cbe105d6c14f02f4932695fd b030747ba37156b90edb4b4fc94974cf2f89efb2 M      trap.c
  | :000000 100644 0000000000000000000000000000000000000000 dcc3851d9b7dbad06e12e7e287f0d3c8c2df45b4 A      trap.c~
  | bisect run success

  でも余り信用していない。何度か試してみる事にする。

  | # bad: [df8375c37c241d6bad23d5c3af5c4233e363b7d5] commit bash-20140221 snapshot
  | # good: [987daba4c451dc7e467c26bb953a308289a6f8b6] bash-4.2 20110622 more stray file cleanup
  | git bisect start 'df8375c' '987daba'
  | # good: [f37a40a43235e39f3f24bb556293b530c106de2f] commit bash-20121102 snapshot
  | git bisect good f37a40a43235e39f3f24bb556293b530c106de2f
  | # bad: [ef5b315f179ae98665c621879ef8c43c08db2ee7] commit bash-20130705 snapshot
  | git bisect bad ef5b315f179ae98665c621879ef8c43c08db2ee7
  | # bad: [bd0a00589fe830b605aa3adca6266f1f95743a73] bash-20130222 remove leftover and stray files
  | git bisect bad bd0a00589fe830b605aa3adca6266f1f95743a73
  | # good: [279b7ea101f99f7ba052fd6f7f04f0ea388f3e55] bash-20121228 additional cleanup
  | git bisect good 279b7ea101f99f7ba052fd6f7f04f0ea388f3e55
  | # good: [4d68afdae9947822df503a6d25a82b2d6b94ca39] bash-20130125 remove leftover and stray files
  | git bisect good 4d68afdae9947822df503a6d25a82b2d6b94ca39
  | # bad: [10e784337238e6081ca5f9bdc8c21492f7b89388] commit bash-20130208 snapshot
  | git bisect bad 10e784337238e6081ca5f9bdc8c21492f7b89388
  | # good: [208fdb509e072977ae7a621e916dfcd32c76047d] commit bash-20130201 snapshot
  | git bisect good 208fdb509e072977ae7a621e916dfcd32c76047d
  | # first bad commit: [10e784337238e6081ca5f9bdc8c21492f7b89388] commit bash-20130208 snapshot

  うーん。どうもちゃんと動くようだ。取り敢えず 208fdb5 は問題ない。そして
  10e7843 はちゃんとコンパイルできて、その上で途中で止まってしまう。取り敢えず
  特に問題を引き起こしている変更まで抽出できた。

  * 元の bug-bash の議論

    そもそもこの変更が行われたのは problem reported by Mike Frysinger
    <vapier@gentoo.org> によると書かれている。以下の報告の様だ。

    https://lists.gnu.org/archive/html/bug-bash/2013-02/msg00016.html

    紹介されているスクリプトで再現しない。bash-4.1 では再現する。と思ったら、こ
    の時点の devel では再現していなかったが、代わりに timeout しないという問題
    があった様である。しかし、こちらの方が寧ろ再現しない。修正によってより
    timeout が効かなくなる様になったという形である。

    この感じだと元のテストケースは使えない。真面目にどういう事になっているのか
    調べて修正する必要があるのではないか。或いはここまで報告したら後は適当にやっ
    てくれるだろうか。

  問題が起こった時の振る舞いを見てみると、sigalrm は呼び出されるがその後の
  check_signals は呼び出されないというのが問題の様である。

  * 止まっている時のスタックの状態はどうなっているのか。
    以下の様に zread.c 51 で止まっている。

    #0  0x00007f71518f4145 in read () from /lib64/libc.so.6
    #1  0x000000000048f665 in zread (fd=9, buf=0x7fff0fd32c3a "", len=1) at zread.c:51
    #2  0x000000000047f995 in read_builtin (list=0x0) at ./read.def:513
    #3  0x00000000004328df in execute_builtin (builtin=builtin@entry=0x47ecb0 <read_builtin>,
    #4  0x00000000004363f9 in execute_builtin_or_function (flags=<optimized out>, fds_to_close
    #5  execute_simple_command (fds_to_close=<optimized out>, async=<optimized out>, pipe_out=
    #6  execute_command_internal (command=<optimized out>, asynchronous=<optimized out>, pipe_
    #7  0x0000000000434498 in execute_command_internal (command=0x2529208, asynchronous=0, pip
    #8  0x00000000004379d5 in execute_in_subshell (command=command@entry=0x25280c8, asynchrono
    #9  0x000000000043401e in execute_command_internal (command=0x25280c8, asynchronous=0, pip
    #10 0x0000000000436ba2 in execute_command (command=0x25280c8) at execute_cmd.c:390
    #11 0x0000000000438b90 in execute_connection (command=0x252b748, asynchronous=0, pipe_in=-
    #12 0x0000000000434498 in execute_command_internal (command=0x252b748, asynchronous=0, pip
    #13 0x0000000000436ba2 in execute_command (command=0x252b748) at execute_cmd.c:390
    #14 0x0000000000435420 in execute_for_command (for_command=<optimized out>) at execute_cmd
    #15 execute_command_internal (command=0x252b588, asynchronous=<optimized out>, pipe_in=<op
    #16 0x0000000000436ba2 in execute_command (command=0x252b588) at execute_cmd.c:390
    #17 0x00000000004212c9 in reader_loop () at eval.c:160
    #18 0x000000000041f927 in main (argc=2, argv=0x7fff0fd336d8, env=0x7fff0fd336f0) at shell.

    ssize_t
    zread (fd, buf, len)
         int fd;
         char *buf;
         size_t len;
    {
      ssize_t r;

      while ((r = read (fd, buf, len)) < 0 && errno == EINTR) ★
        check_signals_and_traps (); /* XXX - should it be check_signals()? */
      return r;
    }

    これを見ると check_signals が呼び出されるのはここ経由なのであろう。

  * check_signals が呼び出される時にはどのように呼び出されるのか

    $ gdb ./bash
    > set style enabled off
    > b r21bp_check_signals
    > set follow-fork-mode child
    > set detach-on-fork off
    > r bisect_read_timeout1.sh
    > inferior 1
    > c
    > inferior 1
    > c
    > inferior 1
    > c
    > inferior 5
    > c
    ここで gdb がクラッシュする→これは style enabled off にしたら動いた。
    > bt

    #0  r21bp_check_signals () at trap.c:475
    #1  check_signals () at trap.c:475
    #2  0x000000000045b9ab in check_signals_and_traps () at trap.c:465
    #3  0x000000000048f667 in zread (fd=9, buf=0x7fffffffcdfa "", len=1) at zread.c:52
    #4  0x000000000047f9a5 in read_builtin (list=0x0) at ./read.def:516
    #5  0x00000000004328df in execute_builtin (builtin=builtin@entry=0x47ecc0 <read_builtin>, flags=flags@entry
    #6  0x00000000004363f9 in execute_builtin_or_function (flags=<optimized out>, fds_to_close=0x5df1c8, redire
        words=<optimized out>) at execute_cmd.c:4717
    #7  execute_simple_command (fds_to_close=<optimized out>, async=<optimized out>, pipe_out=<optimized out>,
    #8  execute_command_internal (command=<optimized out>, asynchronous=<optimized out>, pipe_in=<optimized out
    #9  0x0000000000434498 in execute_command_internal (command=0x595508, asynchronous=0, pipe_in=-1, pipe_out=
    #10 0x00000000004379d5 in execute_in_subshell (command=command@entry=0x595708, asynchronous=asynchronous@en
        fds_to_close=fds_to_close@entry=0x5df1c8) at execute_cmd.c:1567
    #11 0x000000000043401e in execute_command_internal (command=0x595708, asynchronous=0, pipe_in=-1, pipe_out=
    #12 0x0000000000436ba2 in execute_command (command=0x595708) at execute_cmd.c:390
    #13 0x0000000000438b90 in execute_connection (command=0x596508, asynchronous=0, pipe_in=-1, pipe_out=-1, fd
    #14 0x0000000000434498 in execute_command_internal (command=0x596508, asynchronous=0, pipe_in=-1, pipe_out=
    #15 0x0000000000436ba2 in execute_command (command=0x596508) at execute_cmd.c:390
    #16 0x0000000000435420 in execute_for_command (for_command=<optimized out>) at execute_cmd.c:2668
    #17 execute_command_internal (command=0x596808, asynchronous=<optimized out>, pipe_in=<optimized out>, pipe
    #18 0x0000000000436ba2 in execute_command (command=0x596808) at execute_cmd.c:390
    #19 0x00000000004212c9 in reader_loop () at eval.c:160
    #20 0x000000000041f927 in main (argc=2, argv=0x7fffffffd898, env=0x7fffffffd8b0) at shell.c:755

    結局予想は正しかった。

  * 関係ない: sigalrm の戻り値は何も返さなくても良いのか。

    signal handler の戻り値の sighandler は何だろうか。
    set_signal_handler を調べてみると sigaction という関数でシグナルを登録している。
    うーん。sigaction の man を見る限りは void(int) の筈。
    然し sigalrm は sighandler(int) である何でエラーにならないのだろうか。

    ./sig.h:32:#define sighandler RETSIGTYPE
    ./sig.h:33:typedef RETSIGTYPE SigHandler __P((int));

    うーん。試しに SIG_DFL を返してみたがやはり問題は生じる。
    return 0 をしても問題は生じる。なので戻り値の問題ではない様に思われる。

  これはどういう事なのだろうか。多くのシステムで再現する事から何らかの理由があ
  ると期待できる? そもそも SIGALRM で read が失敗するという事が保証されていない
  可能性?

  或いは select を用いて実装し直すのがここは正しいのではないだろうか。
  https://stackoverflow.com/questions/2917881/how-to-implement-a-timeout-in-read-function-call

  色々試した。何が起こっているのかというと (1) read の外で SIGALRM を受信すると
  SIGALRM を逃して無限に待つ事になる(2) read の中であっても pipe を開いて読み取
  り始めるまでは恐らくシグナルを逃す。という事なのだろう。これの対策として read
  の直前に check_signals() の呼び出しが追加されている。然し、それでも
  check_signals と read の呼び出しの間に SIGALRM が現れる可能性もあるし、上記の
  様に read の中で pipe を用意している間に SIGALRM が現れた場合にも対応できない。

  * check_signals が read の直前に追加された経緯を調べる。

    ------------------------------------------------------------------------------

    bb70624e9 (Jari Aalto 2000-03-17 21:46:59 +0000  59)
    0275a139a (Chet Ramey 2018-02-05 10:34:47 -0500  60)   check_signals ();        /* check for signals before a blocking read */
    bb70624e9 (Jari Aalto 2000-03-17 21:46:59 +0000  61)   while ((r = read (fd, buf, len)) < 0 && errno == EINTR)
    e34adc2c3 (Chet Ramey 2020-04-06 09:52:11 -0400  62)     {
    e34adc2c3 (Chet Ramey 2020-04-06 09:52:11 -0400  63)       int t;
    e34adc2c3 (Chet Ramey 2020-04-06 09:52:11 -0400  64)       t = errno;
    e34adc2c3 (Chet Ramey 2020-04-06 09:52:11 -0400  65)       /* XXX - bash-5.0 */
    e34adc2c3 (Chet Ramey 2020-04-06 09:52:11 -0400  66)       /* We check executing_builtin and run traps here for backwards compatibility */
    e34adc2c3 (Chet Ramey 2020-04-06 09:52:11 -0400  67)       if (executing_builtin)
    e34adc2c3 (Chet Ramey 2020-04-06 09:52:11 -0400  68)         check_signals_and_traps ();     /* XXX - should it be check_signals()? */
    e34adc2c3 (Chet Ramey 2020-04-06 09:52:11 -0400  69)       else
    e34adc2c3 (Chet Ramey 2020-04-06 09:52:11 -0400  70)         check_signals ();
    e34adc2c3 (Chet Ramey 2020-04-06 09:52:11 -0400  71)       errno = t;
    e34adc2c3 (Chet Ramey 2020-04-06 09:52:11 -0400  72)     }
    df8375c37 (Chet Ramey 2014-03-07 16:10:54 -0500  73)

    ------------------------------------------------------------------------------

    Commit 64a7a6249 2016-10-19 15:13:16

    >                    9/29
    >                    ----
    >
    > trap.h
    >     - check_signals: new extern declaration
    >     - trapped_signal_received: new extern declaration
    >
    > builtins/read.def
    >     - read_builtin: if one of the zread* functions returns < 0 (which
    >       usually only happens in Posix mode), make sure we call check_signals()
    >       before eventually calling run_pending_traps() because zread() isn't
    >       going to call it
    >     - include trap.h for correct extern functions and variable declarations
    >
    > lib/sh/zread.c
    >     - zread: if executing a builtin, call check_signals_and_traps() for
    >       backwards compatibility.  If not, call check_signals() only, because
    >       we don't want to run traps during, for instance, reading command
    >       substitution output.  Fixes race condition bug reported by Luiz Angelo
    >       Daros de Luca <luizluca@gmail.com>
    > diff --git a/lib/sh/zread.c b/lib/sh/zread.c
    > index 868f9705..496f20b8 100644
    > --- a/lib/sh/zread.c
    > +++ b/lib/sh/zread.c
    > @@ -37,7 +37,10 @@ extern int errno;
    >  #  define SEEK_CUR 1
    >  #endif
    >
    > +extern int executing_builtin;
    > +
    >  extern void check_signals_and_traps (void);
    > +extern void check_signals (void);
    >  extern int signal_is_trapped (int);
    >
    >  /* Read LEN bytes from FD into BUF.  Retry the read on EINTR.  Any other
    > @@ -50,8 +53,13 @@ zread (fd, buf, len)
    >  {
    >    ssize_t r;
    >
    >    while ((r = read (fd, buf, len)) < 0 && errno == EINTR)
    > +    /* XXX - bash-5.0 */
    > +    /* We check executing_builtin and run traps here for backwards compatibility */
    > +    if (executing_builtin)
    >        check_signals_and_traps ();^I/* XXX - should it be check_signals()? */
    > +    else
    > +      check_signals ();
    >
    >    return r;
    >  }

    https://lists.gnu.org/archive/html/bug-bash/2016-09/msg00092.html

    ------------------------------------------------------------------------------

    Commit 0275a139a 2018-02-05 10:34:47

    >                    1/31
    >                    ----
    > lib/sh/zread.c
    >     - zread,zreadintr: call check_signals() before calling read() to
    >       minimize the race window between signal delivery, signal handling,
    >       and a blocking read(2). Partial fix for FIFO read issue reported by
    >       Oyvind Hvidsten <oyvind.hvidsten@dhampir.no>
    >
    > diff --git a/lib/sh/zread.c b/lib/sh/zread.c
    > index 14b66381..8b7ecedf 100644
    > --- a/lib/sh/zread.c
    > +++ b/lib/sh/zread.c
    > @@ -53,6 +53,7 @@ zread (fd, buf, len)
    >  {
    >    ssize_t r;
    >
    > +  check_signals ();^I/* check for signals before a blocking read */
    >    while ((r = read (fd, buf, len)) < 0 && errno == EINTR)
    >      /* XXX - bash-5.0 */
    >      /* We check executing_builtin and run traps here for backwards compatibility */

    https://lists.gnu.org/archive/html/bug-bash/2018-01/msg00114.html
    https://lists.gnu.org/archive/html/bug-bash/2018-01/msg00128.html

    ------------------------------------------------------------------------------

    Commit e34adc2c3 2020-04-06 09:52:11

    >                     4/3
    >                     ---
    > builtins/read.def
    >     - read_builtin: if a read in posix mode is interrupted by a signal,
    >       make sure to preserve the value of errno around calls to
    >       check_signals and run_pending_traps so any error message isn't quite
    >       as confusing. Issue reported by Stan Marsh <gazelle@xmission.com>
    >
    > lib/sh/zread.c
    >     - zread: preserve value of errno (always EINTR) around calls to
    >       check_signals or check_signals_and_traps
    >
    > diff --git a/lib/sh/zread.c b/lib/sh/zread.c
    > index 8b7ecedf..8dd78102 100644
    > --- a/lib/sh/zread.c
    > +++ b/lib/sh/zread.c
    > @@ -55,12 +55,17 @@ zread (fd, buf, len)
    >
    >    check_signals ();^I/* check for signals before a blocking read */
    >    while ((r = read (fd, buf, len)) < 0 && errno == EINTR)
    > +    {
    > +      int t;
    > +      t = errno;
    >        /* XXX - bash-5.0 */
    >        /* We check executing_builtin and run traps here for backwards compatibility */
    >        if (executing_builtin)
    >          check_signals_and_traps ();^I/* XXX - should it be check_signals()? */
    >        else
    >          check_signals ();
    > +      errno = t;
    > +    }
    >
    >    return r;
    >  }

    ------------------------------------------------------------------------------

  これを解決する方法は果たして存在するのだろうか。

  a 一つの方法は以前の様に sigalrt の中で longjmp を実行する方向で、但し様々の
    問題を解決する方法である。というか結局何が問題だったのかよく分からない。

    もしその問題について解決したら patch を受け入れてくれるのだろうか。分からな
    い。そもそも signal handler の中から longjmp した時に何が起こるのかは微妙。
    signal handler の呼び出しはシステムからの特別な呼び出しによる物ではないのか。
    それを乗っ取ってその中で動作し続けて大丈夫なのだろうか。

    と思って検索してみたら正に signal handler の中から longjmp はしては行けない
    というページがあった。この点を指摘されるともう駄目である。
    https://www.jpcert.or.jp/sc-rules/c-sig32-c.html

  b もう一つの方法は何か上手な方法で read が絶対にブロックしないという事を保証
    するという事。select があれば事前に調べる事にすれば良い。但し、この時には
    non-blocking read が必要になる。fd に non-blocking を毎回設定して大丈夫なの
    か。うーん。ソースコードを調べたが O_NONBLOCK は大して使っていない。何か別の手法があるのだったか。

    https://www.geekpage.jp/programming/linux-network/select.php

    このページを見ると blocking のままで使えると書いている。
    うーん。この方法が良いのではないだろうか。

  c reject: SIGALRM を trap したらどうなるか? と思ったが run_pending_traps は
    signal handler の中で即座に呼び出される事はない。という事を考えると SIGALRM
    を trap したとしてもどうにもならない。

    念の為 SIGALRM が呼び出されるか確認する。

    →trap '...' ALRM としても中身が実行される事は決してない。考えてみれば当た
    り前である。というのも、read.def では一時的に signal handler を置き換えるの
    であるから。read が終了しない限りは singal handler は復元されない。なので、
    trap ALRM で設置した handler が read -t の最中に呼び出されるという事はあり
    えない。

  d read の中でシグナルを取り逃がすのだとしたら例えば、sigalrt の中でもうひとつ
    のシグナルを投げて、read が catch しない限り無限にシグナルを投げ続けるのは
    どうだろう。と思ったが、SIGALRT をもう一度投げるとすると、最初の SIGALRT を
    正しく read が捕まえて signal handler を復元した後で、再び SIGALRT が受信さ
    れて元々のハンドラが実行されてしまう。

    % これを防ぐ為には SIGALRT を投げた回数と受信した回数をちゃんと数えて処理しな
    % ければならない。
    %
    % 受信した回数は sigalrt の中で数えれば良い。然し、ちゃんと数えることにしたと
    % してどの様に処理するべきなのかは謎である。うーん。sigalrt は受信する度に新
    % しく SIGALRT を投げる事にする。つまり、常に SIGALRT が飛んでいる状態にする。
    % この様にしておけば read は必ずいつかの時点で中断するのでブロックする事はな
    % くなる。問題は read からタイムアウトした時にどう振る舞うべきかという事。何
    % も考えずにそのまま抜けてしまうと復元後に SIGALRT が来て変な事になる。なので、
    % 最初に SIGALRT ループを停止して、停止を確認した後で初めて処理を抜ける事がで
    % きる。
    %
    % a 例えば sigalrt は放置する事にして、何か処理が停止した事を表すフラグを立て
    %   て、そのフラグが経っていた時に sigalrt 自身にシグナルハンドラーを復元させ
    %   る。同時にシグナルハンドラーを呼ばせる。
    %
    %   この方法を取った時には、もし次の SIGALRT が来る前に再び read -t が呼び出
    %   されたらどうするのかというのが疑問である。一応、ちゃんと状態を管理すれば
    %   問題ない筈だが面倒そうである。

    と思ったが、どうやら単に falarm(0,0) を実行しておけばちゃんと SIGALRT をキャ
    ンセルする事ができる様である。

    改めて調べるとシグナルハンドラーの中で raise を投げるのは難しそう。一回だけ
    は投げても良いかもしれないが再帰的に投げるのは駄目という事になっている。

    https://www.jpcert.or.jp/sc-rules/c-sig33-c.html

    然しこれは廃止されて SIG30-C に統合されたそうだ。

    https://wiki.sei.cmu.edu/confluence/display/c/SIG30-C.+Call+only+asynchronous-safe+functions+within+signal+handlers

    言っている事をまとめると、raise() は C では未定義 (raise によって呼び出され
    た sighandler の中で raise は駄目) だが、POSIX では raise() は
    async-sig-safe 関数として sighandler の中で呼び出してもOKという事になってい
    る。POSIX を信じれば一応呼び出しても OK という事になっている。実際のシステ
    ムがどの様に振る舞うのかは微妙である。

    うーん。実際に動くとしてもかなり危ない感じの手法になるのは確かである。

2021-01-11

* bash-completion: 変なファイルが作られる [#D0020]

  echo '$1>xxx{xxx}' とすると変なファイルが作成される。
  これは ble.sh でやると auto-complete で沢山ファイルが作られるが、
  ble.sh なしでも TAB を推すとファイルが作られる。
  bash-completion の中で行われている展開が何か問題を起こしているのだろう。

  これは bash-completion に PR を出した。

2020-08-31

* report19b: bashline.c で savestring した後で自動で free する様にしていたと思ったが [#D0019]
  実際に確認してみると SEVAL_NOFREE が指定されている。
  r = parse_and_execute (savestring (cmd), "bash_execute_unix_command", SEVAL_NOHIST|SEVAL_NOFREE);
  自分の patch ではこれを削除する様にしたと思ったが残っている。何故?
  経緯について確認する必要がある。

  これについては先ず前に自分がした報告を探す。
  https://lists.gnu.org/archive/html/bug-bash/2018-05/msg00020.html である。
  確かにこの時点では　SEVAL_NOFREE を設定している。blame してみる。

  --- dfc21851b commit bash-20090723 snapshot
  +++ 96b7e2687 commit bash-20180504 snapshot
  -  r = parse_and_execute (cmd, "bash_execute_unix_command", SEVAL_NOHIST|SEVAL_NOFREE);
  +  r = parse_and_execute (savestring (cmd), "bash_execute_unix_command", SEVAL_NOHIST|SEVAL_NOFREE);

  どうもこちらの送った patch をちゃんと適用しなかった様だ。
  或いは、意図的に SEVAL_NOFREE を残した?
  然し、やはりそれは改めて考えてみても変である。
  やっぱりちゃんと patch を見ないで適用したのだとしか考えられない。

* report19: PROMPT_COMMAND を実行中に書き換えると変な事になるという問題 [#D0018]

  スカラーの時には execute_variable_command を呼び出していて、
  この関数の中では savestring を用いて実行コマンドを
  書き換えていたので問題は起こっていなかった。
  然し、配列になると配列自体がコマンド実行によって消滅してしまう可能性があるので、
  配列の値を保存しておくべきなのではないだろうか。

  segfault を起こすことができた。これは明らかに駄目。修正した。

2020-08-28

* report18: bash-5.0 以降で不完全なコマンドを実行するとシェルが終了する [#D0017]
  { a=1 } を無理やり実行するとシェルが終了する。
  というより "for i; do echo $i" を強制的に実行してもそうなる。
  これは防ぐ事はできるだろうか。

  普通の bash セッションで eval 'for i; do echo $i' としてもシェルが終了する。
  何故この様な振る舞いなのだろうか。どうも、bash-5.0 以降の振る舞いの様である。

  先ず eval { だけでも再現する。bash-4.4 以前は終了しない。
  試しに関数の中に入れて実行してみたがそれでも駄目。

  * 取り敢えず何故このような変更がなされたのか調べる事にする。
    先ず、どの commit でこれが発生したのかを調べる。

    8a10051 犯人はこれ。
    以下の変更が怪しい。実際に試したらそうだった。

    > From 8a100514480a55ad73966e516e38778509f6ace6 Mon Sep 17 00:00:00 2001
    > From: Chet Ramey <chet.ramey@case.edu>
    > Date: Thu, 11 May 2017 14:45:50 -0400
    > Subject: [PATCH] commit bash-20170511 snapshot
    >
    > diff --git a/CWRU/CWRU.chlog b/CWRU/CWRU.chlog
    > index 7892ce94..8ea60a39 100644
    > --- a/CWRU/CWRU.chlog
    > +++ b/CWRU/CWRU.chlog
    > @@ -13840,3 +13840,18 @@ builtins/read.def
    >  	  a CTLESC the last time through the loop (skip_ctlesc == 0),
    >  	  especially if i == 0. Another fuzzing bug from Eduardo Bustamante
    >  	  <dualbus@gmail.com>
    > +
    > +				    5/9
    > +				    ---
    > +parse.y
    > +	- token_is_assignment: use the allocated buffer approach in all cases,
    > +	  not just if we're not using bash malloc. This avoids the assignment
    > +	  to t[i+1] writing beyond the end of the allocated token if
    > +	  i == token_buffer_size - 1. Another fuzzing bug
    > +	- xparse_dolparen: if parse_string returns < 0, we clear out the
    > +	  current shell_input_line before performing a longjmp, since we're
    > +	  abandoning parsing of this command.  This is consistent with how
    > +	  the parser resynchronizes after other syntax errors
    > +	- GRAMMAR: add 'error yacc_EOF' production to handle a syntax error
    > +	  that's immediately followed by an EOF after resynchronization.
    > +	  Fixes another fuzzing bug
    > diff --git a/parse.y b/parse.y
    > index 7ca4a64e..dcc628e7 100644
    > --- a/parse.y
    > +++ b/parse.y
    > @@ -411,7 +411,14 @@ inputunit:	simple_list simple_list_terminator
    >  			      YYABORT;
    >  			    }
    >  			}
    > +	|	error yacc_EOF
    > +			{
    > +			  /* EOF after an error.  Do ignoreeof or not.  Really
    > +			     only interesting in non-interactive shells */
    > +			  global_command = (COMMAND *)NULL;
    > +			  handle_eof_input_unit ();
    > +			  YYACCEPT;
    > +			}
    >  	|	yacc_EOF
    >  			{
    >  			  /* Case of EOF seen by itself.  Do ignoreeof or
    > --
    > 2.21.3

    では何故この様に振る舞うのか。

    | ? というより、コメントには
    |   "really only interesting in non-interactive shells" と書いてあるので、
    |   interative shell で振る舞いが変わってしまっているのは意図していない気がする。
    |   →と思ったが handle_eof_input_unit の実装を見ると
    |   interactive shell だけで意味のある操作をしている気がする。
    |   このコメントの non-interactive は interactive の間違いだろうか。
    |
    | ? yacc の記法がよく分からないが、error yacc_EOF と yacc_EOF の両方があるのは何故。
    |   別に error yacc_EOF と yacc_EOF の順序はどちらでも関係ないようである。
    |   うーん。error yacc_EOF とは error が生じてから yacc_EOF が来た時の動作?
    |   →実際にコメントにはその様に書かれている。
    |
    | 調べてみると中で呼び出されている handle_eof_input_unit で終了している様だ。
    | 追加された部分がない時には代わりに yacc_EOF 節が呼び出される訳でもない様だ。
    | 完全なコマンド eval '{ echo; }' 等を実行しても yacc_EOF に入るわけではない。
    | どうも C-d で抜けたりすると yacc_EOF に入る様である。
    |
    | ? そもそもこの修正は何故行われたのか。fuzzing で見つかったという事になっている。
    |   関係ありそうなのは以下のスレッドである。然しどれかは分からない。
    |   https://lists.gnu.org/archive/html/bug-bash/2017-05/msg00076.html *
    |   https://lists.gnu.org/archive/html/bug-bash/2017-05/msg00075.html
    |   https://lists.gnu.org/archive/html/bug-bash/2017-05/msg00045.html
    |   https://lists.gnu.org/archive/html/bug-bash/2017-05/msg00036.html
    |
    |   修正するにしても元々の問題が再現する様になる修正方法では駄目である。
    |   例えば、error yacc_EOF で何も実行しない様にする事で例えば無限ループになるのだと駄目。
    |
    | ここでの正しい修正方法は何だろうか。
    | eval の中で EOF が来た場合には勝手に終了する訳には行かない。

  * 調べて分かった事。対話シェルのユーザコマンドでしか発生しない。
    これは明らかに振る舞いとして不自然である。

    * 普通のスクリプト実行では eval '{' しても其処で終了したりする事はない。
    * bash --rcfile <(echo eval {) -i としても終了したりはしない。

    ? 何故通常のコマンドの時にはこのエラーが発生しないのだろうか。
      eval の中だったら起こるという訳でもない。
      何が起こっているのだろうか。
      と思ったが、唯単に終了しないというだけで通過はしているのかもしれない。
      確認してみる事にする。

      →確かめてみた所、普通のスクリプト実行時にもちゃんと error yacc_EOF は発生しているが、
      対話シェルではないという事からその場で終了したりはしないという事らしい。

      また、eval で完全なコマンドを提供した時には特に error yacc_EOF も yacc_EOF も発生しない。
      評価している文字列の末端でエラーが起こった時に error yacc_EOF が発生し、
      また評価しているスクリプトの末端で yacc_EOF が発生する。
      それ以外の末端の場合には何も発生しない、という事のようである。不思議である。

    * source の場合にも同じ問題が生じる? と思ったら何故か問題は生じない。
      対話モードを一時的に抜けているという事なのだろうか。

      調べてみると evalstring に SEVAL_NONINT または SEVAL_INTERACT を渡した時には
      対応する対話モードに一時的に変更してコマンドを実行する様である。
      source の場合には非対話モードで処理をするという事なのだろう。
      なので急に終了したりはしない。

  * 元の fuzz で発見された問題は何だったのか

    | ? No: eval { で中途半端な状態にして解析中断するとスタックに何か残って問題が起こるという事?
    |   と思って以下のコードを実行してみたが特にメモリを食らう様になるなどの事は内容に見える。
    |
    |   $ time for ((i=0;i<10000000;i++)); do eval {; done 2>/dev/null
    |
    |   メモリ使用量も増えていない。以下の1行目は上のループの実行前で、2行目は実行後。
    |
    |   $ ps uaxf | grep $$
    |   murase    8850  0.0  0.0  16784  7196 pts/3    S    06:35   0:00  |   \_ bash-4.4 --norc
    |   murase    8833 29.2  0.0  16888  7264 pts/3    S    06:32   0:44  |   \_ bash-4.4 --norc
    |
    | ? 元のメールにある報告で確認できないか。よく分からないと思ったが、
    |   base64 で表示しているのが問題のある入力だったという事のようであ
    |   る。中を見ると通常の bash スクリプトの一部を部分的に破壊した様な
    |   内容になっている。成程、こういう物が fuzz の対象となるのである。
    |
    |   実際に bash-4.4 が segfault する事を確認する事ができた。
    |   これが件の変更と関連するかどうかを調べれば良いのである。
    |   →OK segfault にはならなかったが、無限ループになるという事を確認できた。
    |   報告では確かに無限ループと書かれている。

    問題は再現した。そして単にコメントアウトすれば問題は起こらない。

  * まとめ

    ? コメントの "really only interesting in non-interactive shells"
      の意味はよく分からない。実際の動作は逆に interactive shells で何
      か特別な操作をしている様に見える。

    * "error yacc_EOF" は構文エラーの直後に EOF が来る時に発生する?
      通常のスクリプトで発生する条件と
      interactive session に於いて発生する条件が同じか確認が必要。

      * 対話シェルではトップレベルで "error yacc_EOF" が実行される事はな
        い。
      * 関数内で実行されるということもないだろう。何故なら、そもそも
        構文エラーを含む様な関数を定義できないので。
      * source の末端では error yacc_EOF が発生する様だが、source は非
        対話モードでファイルを読み込むので即座に終了するという事はない。
      * eval の末端で起きているのが今回の問題。eval は対話モードで評価
        する為に問題が発生する。

      この現在の状況でそのまま報告すると Chet はおそらく、eval は対話
      モードで評価するのだから { が来た時に終了するのは自然である等と
      変な回答をして修正しないという事が予想される。ここはちゃんと調べ
      て何が問題点でどの様に修正するべきかを提示する必要がある。

    元々の問題は以下で報告されている物である。
    当該変更によって以下の振る舞いが修正される事を確認した。
     https://lists.gnu.org/archive/html/bug-bash/2017-05/msg00076.html

    * どのように修正するべきだろうか。
      単に global_command と handle_eof_input_unit() を
      コメントアウトしただけだと eval { の終了ステータスが 0 になっている。
      handle_eof_input_unit() だけをコメントアウトしてもだめ。
      handle_eof_input_unit() の代わりに EOF_Reached = 1 を設定しても駄目。
      YYACCEPT; の代わりに YYABORT; を実行すると問題ない。

    * そもそも何故この修正で無限ループが修正されるのだろうか。
      これは解析の無限ループではなくて実行の無限ループである。

  * 問題点2: どうも元の報告に対しても bash -n の終了ステータスが変である。
    構文エラーが報告されているのにも関わらず終了ステータス 0 になっている。
    これはやはり終了ステータス 1 になるべきなのではないだろうか。
    →と思ったらこれは bash-5.0 では既に修正されている。
    つまり個の部分に対して更なる修正が追加されたという事を意味する。
    確認する必要がある。

    d7d836dfc (Chet Ramey 2017-06-20 10:38:13 -0400  424) に条件分岐で
    YYABORT と YYACCEPT を切り替える様にしている。更に、
    ab8ded9c3 (Chet Ramey 2018-12-17 14:53:06 -0500  421) で追加の条件で
    何かの処理を追加している。うーん。

    どうも prase_and_execute_level を見て振る舞いを変えれば良いのではないか?
    実際に見てみた所、確かに prase_and_execute_level を見ればトップレベルで実行されているかどうか確認できる。
    なので修正するとすれば handle_eof_input_unit を
    if (interactive && parse_and_execute_level == 0) の条件下に移動するという事。

    然し、そもそも何故 ignoreeof のチェックが evalstring の中で有効に
    なっていたのだろうか。謎である。eval の中で何らかの理由で EOF が受
    け取られた時に ignoreeof が設定されていない時には勝手に終了してし
    まうという事なのだろうか。然し、実際には eval を実行している時には
    EOF は受信されない様である。うーん。不思議である。まあ気にしなくて
    良い気がする。

  Bug report を作成する事にする。必要な情報を集める事にする。

2020-08-23

* report17: PROMPT_COMMANDS と PROMPT_COMMAND を共存させるにはどうしたら良いのか [#D0016]
  ble.sh で --attach=prompt で PROMPT_COMMANDS に対応しようとして分からなくなった。
  取り敢えずメールで質問を書いた。

2020-04-20

* report16: hash_search が線形探索しているから遅いと主張する人が現れた [#D0015]
  然し言っている事が良くわからない。実測してみた所、
  確かに途中から自乗で計算時間が増えている。

  調べてみると rehash が実装されていない。実装してみた所、高速になった気がする。
  条件を等しくして計測しなければならないので計測し直す。

  テスト用コード
  | {
  |   FILE*f=fopen("/dev/tty","a");
  |   fprintf(f,"hash_insert\n");
  |   fclose(f);
  | }

  取り敢えずファイルを整理する。

  * test1.sh は移動して編集した。計測が終わり次第移動元は削除する。
  * 計測データも移動する。 test1.txt.a と test1.txt.b である。
  * gp を編集する。

  2020-08-28 メモが書きかけになって残っていたが、これは既に merge されている。

2020-04-17

* また別の議論で Bash の変な振る舞いを見つけた [#D0014]
  https://github.com/akinomyoga/ble.sh/issues/48

  | $ test_command='f1() { false; return; }; trap "f1 && echo unexpected" WINCH; kill -WINCH 0'
  | $ bash-2.05b -c "$test_command"
  | $ bash-3.1 -c "$test_command"
  | $ bash-3.2 -c "$test_command"
  | $ bash-4.0 -c "$test_command"
  | $ bash-4.1 -c "$test_command"
  | $ bash-4.2 -c "$test_command"
  | $ bash-4.3 -c "$test_command"
  | $ bash-4.4 -c "$test_command"
  | unexpected
  | $ bash-5.0 -c "$test_command"
  | unexpected
  | $ bash-dev -c "$test_command"
  | unexpected

  Bash のソースコードを確認すると buitins/common.c (get_exitstat) に説明が書かれている。

  | if (list == 0)
  |   {
  |     /* If we're not running the DEBUG trap, the return builtin, when not
  |        given any arguments, uses the value of $? before the trap ran.  If
  |        given an argument, return uses it.  This means that the trap can't
  |        change $?.  The DEBUG trap gets to change $?, though, since that is
  |        part of its reason for existing, and because the extended debug mode
  |        does things with the return value. */
  |     if (this_shell_builtin == return_builtin && running_trap > 0 && running_trap != DEBUG_TRAP+1)
  |       return (trap_saved_exit_value);
  |     return (last_command_exit_value);
  |   }

  理由は書かれていないが、bug-bash で検索した感じだと誰かが文句を言ったという事だろうか。
  git blame で確認してみる事にする。以下のような感じである。

  939d190e0 (Chet Ramey 2014-03-21 14:15:01 -0400  559
  e2f12fdf5 (Chet Ramey 2014-04-07 10:46:02 -0400  560

  7117c2d22 (Jari Aalto 2002-07-17 14:10:11 +0000 497)   if (list == 0)
  939d190e0 (Chet Ramey 2014-03-21 14:15:01 -0400 498)     {
  e2f12fdf5 (Chet Ramey 2014-04-07 10:46:02 -0400 499)       /* If we're not running the DEBUG trap, the return builtin, when not
  e2f12fdf5 (Chet Ramey 2014-04-07 10:46:02 -0400 500)           given any arguments, uses the value of $? before the trap ran.  If
  e2f12fdf5 (Chet Ramey 2014-04-07 10:46:02 -0400 501)           given an argument, return uses it.  This means that the trap can't
  e2f12fdf5 (Chet Ramey 2014-04-07 10:46:02 -0400 502)           change $?.  The DEBUG trap gets to change $?, though, since that is
  e2f12fdf5 (Chet Ramey 2014-04-07 10:46:02 -0400 503)           part of its reason for existing, and because the extended debug mode
  e2f12fdf5 (Chet Ramey 2014-04-07 10:46:02 -0400 504)           does things with the return value. */
  e2f12fdf5 (Chet Ramey 2014-04-07 10:46:02 -0400 505)       if (this_shell_builtin == return_builtin && running_trap > 0 && running_trap != DEBUG_TRAP+1)
  939d190e0 (Chet Ramey 2014-03-21 14:15:01 -0400 506)           return (trap_saved_exit_value);
  939d190e0 (Chet Ramey 2014-03-21 14:15:01 -0400 507)       return (last_command_exit_value);
  939d190e0 (Chet Ramey 2014-03-21 14:15:01 -0400 508)     }

  939d190e0 を確認してみる。

  7117c2d22 (Jari Aalto 2002-07-17 14:10:11 +0000 497)   if (list == 0)
  939d190e0 (Chet Ramey 2014-03-21 14:15:01 -0400 498)     {
  939d190e0 (Chet Ramey 2014-03-21 14:15:01 -0400 499)       if (this_shell_builtin == return_builtin && running_trap)
  939d190e0 (Chet Ramey 2014-03-21 14:15:01 -0400 500)          return (trap_saved_exit_value);
  939d190e0 (Chet Ramey 2014-03-21 14:15:01 -0400 501)       return (last_command_exit_value);
  939d190e0 (Chet Ramey 2014-03-21 14:15:01 -0400 502)     }

  939d190e0~ ではどうだろうか。

  7117c2d22 (Jari Aalto 2002-07-17 14:10:11 +0000 496)   if (list == 0)
  7117c2d22 (Jari Aalto 2002-07-17 14:10:11 +0000 497)     return (last_command_exit_value);


  1つ目の修正の説明は以下の様に書かれている。

  >            3/11
  >            ----
  >
  > builtins/common.c
  >   - get_exitstat: when running `return' in a trap action, and it is not
  >     supplied an argument, use the saved exit status in
  >     trap_saved_exit_value.  Fixes Posix problem reported by
  >     Eduardo A. Bustamante L坦pez <dualbus@gmail.com>

  2つ目の修正は以下の様になっている。

  >            3/18
  >            ----
  >
  > builtins/common.c
  >   - get_exitstat: update fix of 3/11 to allow the DEBUG trap to use the
  >     current value of $? instead of the value it had before the trap
  >     action was run.  This is one reason the DEBUG trap exists, and
  >     extended debug mode uses it.  Might want to do this only in Posix
  >     mode


  議論は以下にある。POSIX によると return が trap action の中で呼び出された時、
  必ず trap 直前の値になるという事らしい。うーん。
  https://lists.gnu.org/archive/html/bug-bash/2014-03/msg00053.html

  恐らく2つ目の修正は以下によってなされた。
  https://lists.gnu.org/archive/html/bug-bash/2018-04/msg00047.html

  うーん。と思って他のシェルを調べたら振る舞いがばらばらである。

  | $ mksh -c "$test_command"
  | unexpected
  | $ ksh -c "$test_command"
  | unexpected
  | $ yash -c "$test_command"
  | unexpected
  | $ ash -c "$test_command"
  | $ dash -c "$test_command"
  | $ zsh -c "$test_command"
  | $ busybox sh -c "$test_command"
  | $ posh -c "${test_command//WINCH/INT}"

  https://lists.gnu.org/archive/html/bug-bash/2014-03/msg00053.html
  の議論を改めて観察してみると Eduardo は
  元々 trap action (trap の引数に指定したもの) の中にある return を意図している気がする。
  然し Chet は trap handler が動いている時は無条件で return が
  trap handler 起動直前の $? を返す様に変更した。

  うーん。trap handler に指定した一番上の return だけが影響を受けるという実装はないのか。
  zsh は例えばどの様に実装しているだろうか。
  zsh は以下の設定でシグナルでループを終わらせる事を確認した。
  $ trap 'echo TRAPINT; return 123' USR1
  $ while (($?==0)); do :; done
  と思ったがこれだと終了して当たり前なので振る舞いを確認できない。
  というより、実際に $? がどうなったかを確かめる必要がある。

  % trap 'echo TRAPINT; (exit 123); return' USR1
  % f1() { while :; do for i in {1..100}; do (exit 111); done; done; }
  % f1
  TRAPINT
  % echo $?
  123

  どうも return は普通に trap action の中での直前のコマンドを参照している様だ。

  POSIX は一体どういう意図で書かれたのだろうか。
  * trap の action に関数呼び出しなどの複雑なコマンドは指定できないという事?
    然し、関数は一単語で呼び出せるし special utility を関数で実装する事も許している。
    関数呼び出しをしてはいけないという事を考える必要があるとは思えない。
    そう思うとやはり関数呼び出しの中でも return は同様に振る舞うべきなのか。
  * 或いは f1() { 何かの処理; return; }; trap '処理色々; f1' などの様にして使うのが目的なのか。
    然し、その様な使い方は考えにくいし、その様にするぐらいであれば、
    trap 'f1; return' 等の様に書く気がする。

  取り敢えず修正案を作ってそれから報告する事にする。
  然しどの様に修正するのが良いか。

  取り敢えず trap に入る瞬間の frame を覚えておいて、
  その frame にいる時に限り return の戻り値を直前のコマンドのそれに置き換える。
  その様に実装すれば良い筈である。

  では trap に入る瞬間の frame をどの様に記録するか。
  そもそも何処で trap に入るというのを検出する事は可能か。
  取り敢えず running_trap が設定される状況について確認する。

  * jobs.c で running_trap = SIG_CHLD + 1 が設定されている。
    その後で 0 にクリアされている。
  * trap.c (run_pending_traps) において running_trap = sig + 1 が実行されている。
    trap handler は主に此処で走るということの様である。

    * 此処で $? を global trap_saved_exit_value に保存している。
      但し、この保存が行われるのは複数の handler を処理する前である。
      つまり各 handler が実行される度に更新されるのではなくて、
      何れの handler が実行されるよりも前の値が記録されている。

    * もし return の位置を記録するのだとしたら $? とは違って、
      各 handler が実行される毎に毎回記録し直す必要がある。
      そういう意味で running_trap を設定する度に設定し直す。

      一方で old_running という変数がある。
      これが示唆する事は trap handler が入れ子になって呼び出される可能性があるという事。
      そして、そうだとすると return_frame に関しても old_return_frame 等に
      記録して入れ子に対応できる様にしなければならない。

      或いは return の文脈を直接記録しなくても関数の呼び出しの
      深さのような変数があればそれでも良い。そういう意味では
      BASH_SOURCE か FUNCNAME の様な変数がどの様に更新されるのかを見ても良い。

  | FUNCNAME について調べるとこれの実体は funcname_a という配列オブジェクトの様だ。
  | * そしてこれは execute_cmd.c 4767, 4901 において array_pop, array_push されている。
  |   前者は restore_funcarray_state であり、後者は execute_function である。
  | * 他に builtins/evalfile.c で array_push が実行されている。
  |   これは source, . であろう。
  | * それから shell.c で array_push が実行されている。
  |   これは見た所は最初の初期化としてグローバルに対応する要素を設定しているだけである。
  |
  | と思ったら丁度 funcnest という変数がいい感じに管理されている。
  | 実はこれを記録すれば良いのではないだろうか。
  | * execute_cmd.c の execute_function では funcnest++ されている。
  | * shell.c では funcnest は設定されていない。
  | * evalfile.c では funcnest ではなくて sourcelevel++ が実行されている。
  |
  | よく見ると return_catch_flag++ されている様だ。
  | * evalfile.c で return_catch_flag++ されている。
  | * 実は evalstring.c でも return_catch_flag++ されている。
  |   コメントの説明によると eval の中で return をした場合には、
  |   一旦捕まえて clean up をしてから更に外側に行くとの事。

  総合すると return_catch_flag が使えそうな気がするが、
  これは実は eval も数えてしまうので使えない。
  他に funcnest, sourcenest, evalnest, sourcelevel 等の変数がある。
  evalnest は eval の数を数えるのに使えるかと思いきや、
  何だか関係ない場所でも inc/dec されている (trap.c)。
  普通に考えたら return_catch_flag で evalstring の分を除いた物を記録したい。
  然し、evalstring は eval の他にも様々な場所で使われているから evalnest は使えない。
  色々考えると funcnest + sourcenest が使えるという事の気がする。

  取り敢えず修正した。そして修正した bash を使って幾つかテストしてみた。
  どうやら期待通りに動いている様に見える。
  次にするべき事は Bash に report を書く事である。提出した。

2019-01-22

* report14: ble.sh #D1078 についても [#D0013]

  | 症状は何だったか。
  |
  | $ bash-5.0 --norc
  | $ bind -p | grep '"\\C-\\'
  | $ bind '"\C-\\": self-insert'
  | $ bind -p | grep '"\\C-\\'
  | "\C-\\\": self-insert
  |
  | $ bash-5.0 --norc
  | $ set -o vi
  | $ bind -p | grep '"\\C-\\'
  | "\C-\\": self-insert
  | $ bind '"\C-\\": self-insert'
  | $ bind -p | grep '"\\C-\\'
  | "\C-\\\": self-insert
  | "\C-\": self-insert
  |
  | これである。中々謎である。ちゃんと \C-\\ と出力される事もあるから、
  | これは何か記録のされ方が変な事になっているのだろうという気がする。
  | 取り敢えず bind -p の処理を何処でやっているかを特定する。
  |
  | rl_function_dumper から rl_invoking_keyseqs_in_map を呼び出している。
  | その中で文字列を構築している。中を確認してみると何だか怪しい。
  | \C-\ が出力されてしまう気がする。しかし blame するとここ8年間ここは動いていない。
  | うーん。ここも怪しいかもしれないが今回の事はここが原因ではない。
  |
  | うーん。実際に出力してみると何故かちゃんと \C-\\ になっている。
  | 一方で bind '"\C-\\a"' が <C-\><C-g> と解釈されていると分かった。
  | 更に bind "\C-\a" は <C-\><a> と解釈されている。
  | この振る舞いは bash 4.3 でも同様であった。つまり自分の所為ではない。
  |
  | 一方で Bash 4.3 では bind "\C-\" の " はエスケープされた物として取り扱われる。
  |
  | うーん。どうやら bind -s や bind -X は大丈夫の様だ。
  |
  | まとめ。
  |
  | bind '"\C-\":"..."' の解釈について、
  | 最初の ".." の切り出しの時には \C-\ を認識せずに単に \ だけを見て ".." を切り出す。
  | 次の解釈の時に \C-\ の単位で解釈を行う。したがって "\C-\\" は \C-\ + \ と解釈される。
  | また出力に関しては bind -sX は \C-\\ を出力するが bind -pP は \C-\ を出力する。

  状況を整理すると Bash では \C-\ と \C-\\ が混ざっている。
  単一文字の束縛に対しては bind -spPX は全て \C-\\ を出力する。

    $ ./bash-3a7c642e --norc
    $ bind '"\x1c":"hello"'
    $ bind -s
    "\C-\\": "hello"
    $ bind '"\x1c":self-insert'
    $ bind -p | grep '\\C-\\'
    "\C-\\": self-insert
    $ bind -P | grep '\\C-\\'
    self-insert can be found on "\C-\\", " ", "!", "\"", "#", ...
    $ bind -x '"\x1c":"echo hello"'
    $ bind -X
    "\C-\\": "echo hello"

  複数文字の束縛に対しては bind -pP は最後の文字以外について \C-\ を出力する。
  また shadow binding の場合は最後の文字以外の場合でも \C-\ になる。

    $ ./bash-3a7c642e --norc
    $ bind '"\x1c\x1c":"hello"'
    $ bind -s
    "\C-\\\C-\\": "hello"
    $ bind '"\x1c\x1c":self-insert'
    $ bind -p | grep '\\C-\\'
    "\C-\\C-\\": self-insert
    $ bind -P | grep '\\C-\\'
    self-insert can be found on "\C-\\C-\\", " ", "!", "\"", "#", ...
    $ bind -x '"\x1c\x1c":echo hello'
    $ bind -X
    "\C-\\\C-\\": "echo hello"

  束縛の解釈については "..." を切り出す時には \C-\" は " をエスケープする。
  然し中身を解釈する時には \C-\ が一つのまとまりと解釈される。

  % どちらが採用されるべきだろうか。
  %
  % a \C-\\ に統一する案。既存のコードに対する影響はどれほどだろうか。
  %   つまり \C-\ 前提で扱っているコードはあるだろうか。
  %   "\C-\" は使えない。何故なら \" をエスケープする為。
  %   "\C-\a" 等はどうだろうか。これは従来通りの解釈になる様にすればOK
  %   "\C-\\" はどうだろうか。従来は C-\ + \ だったのが今後は C-\ という意味に変わる。
  %   "\C-\\C-a" は C-\ C-a から "C-\ C - a" に意味が変わる。
  %
  % b 逆に \C-\ に統一する案。"\C-\" を accept する様に書き換えが必要である。
  %   また出力の際に \\ ではなく \ を出力する様に変更する必要がある。

  古い Bash での振る舞いはどうだったか。
  調べてみると出力の inconsistency は Bash 3.0 の時から変わっていない。

  | 解釈の inconsistency についてはどうだろうか。
  | というか何故古い Bash で問題が発生していなかったのか。
  |
  | どうも解釈に関しては \C-\\ から \C-\ になったのは Bash 5 からの様だ。
  | どの瞬間から変化したのだろうか。もしかして自分が噛んでいたりする?
  | 動作を確認すると rl_parse_and_bind が呼び出されてその中で
  | "..." の中身が抽出されて、それから rl_bind_seq 及び rl_macro_bind に渡される。
  | これらの関数は rl_translate_keyseq を使っている。
  |
  | うーん。不思議だ rl_translate_keyseq の中は確かに最近変更されているが、
  | 該当部分は変更されていない様に見える。だとすれば渡す側に何か変更がある?
  | 切り出し部分を確認したが全く変更はない。という事はやはり rl_translate_keyseq である。
  | うーん。昔の状態を checkout して何時からこれになったのか調べる。
  | 20190207 の時点でもう変化していた。20180309 の時点でもう変化していた。
  |   20170804 の時点では変化していた。20170601 では変化。
  |     20170505 変化。これが犯人である。
  |   20170407 の時点では未だ。20170421 未変化。20170428 未変化。
  | 20170106 の時点ででは未だ変化していない。
  |
  | commit af2a77f
  | | diff --git a/CWRU/CWRU.chlog b/CWRU/CWRU.chlog
  | | index 51e95ae3..7892ce94 100644
  | | --- a/CWRU/CWRU.chlog
  | | +++ b/CWRU/CWRU.chlog
  | | @@ -13767,3 +13767,76 @@ lib/glob/sm_loop.c
  | |            matches beyond it.  Look at https://research.swtch.com/glob for a
  | |            longer explanation. This results in a significant speedup for globs
  | |            with multiple instances of `*', especially with more than 4.
  | | +
  | | +                                    5/2
  | | +                                    ---
  | | +lib/readline/bind.c
  | | +        - rl_translate_keyseq: make sure a trailing backslash in the key
  | | +          sequence is preserved. Report from Eduardo Bustamante
  | | +          <dualbus@gmail.com>
  | | +
  | | diff --git a/lib/readline/bind.c b/lib/readline/bind.c
  | | index 117f3427..fef538b1 100644
  | | --- a/lib/readline/bind.c
  | | +++ b/lib/readline/bind.c
  | | @@ -441,7 +441,10 @@ rl_translate_keyseq (const char *seq, char *array, int *len)
  | |            c = seq[++i];
  | |
  | |            if (c == 0)
  | | +            {
  | | +              array[l++] = '\\';        /* preserve trailing backslash */
  | |                break;
  | | +            }
  | |
  | |            /* Handle \C- and \M- prefixes. */
  | |            if ((c == 'C' || c == 'M') && seq[i + 1] == '-')
  |
  | 不思議だこれで振る舞いが変わるのは不思議だ。
  | あ。分かった。テストケースが悪いんだ。
  | 前から \C-\ だったのが、中途半端な \ を無視する事によって
  | \C-\\ がたまたま \C-\ になっていただけなのだ。

  →結局、Bash 3.0 からずっとこの様な取扱いになっていたのだった。
  偶々 \C-\\ が \C-\ + \ になって \ が消滅していたから動いている様に見えたのが、
  commit af2a77f によって顕在化したという事なのである。
  この修正の元になった議論を確認したが恐らく以下のものである。
  https://lists.gnu.org/archive/html/bug-bash/2017-04/msg00139.html
  振る舞い自体については議論に上っていない。何だかよく分からない。
  或いはこの後で ML に関係なく議論が進んだのかもしれない。

  取り敢えず inconsistency は昔からあったので昔の状態に戻すという方針は使えない。

  どう修正されるべきか。

  * これは確実に \C-\\ に変更されるべきである。
    それは今まで動いていた物が動かなくなったから。
    さらに bind -sSX の出力をそのまま使えないから。
    逆に bind -pP の出力が使えなくなるかもだけれども、
    それに関しては同時に対応すればよい。
    他の version の bash の出力を使用する事は考えにくいのだから。

  Note: _rl_convert_meta_chars_to_ascii の時
    \M-\C-x は必ず <\e><\><C><-><x> と解釈されてしまう。
    実際に再現する事ができる。
    	 $ bind 'set convert-meta on'
    	 $ bind '"\M-\C-t":"hello"'
    	 $ bind -s
    	 "\e\\C-t": "hello"
    然し　!_rl_convert_meta_chars_to_ascii の時には
    \M-\C-x は <\M-\C-x> にちゃんと解釈される。
  Note: 従来の実装では _rl_convert_meta_chars_to_ascii の設定に関わらず
    \C-\M-x は必ず <ESC><\C-x> と解釈されてしまう。これは変だ。
    \M の時と同様に振る舞うべきなのである。
  Note: "\C-" や "\M-\C-" の従来の振る舞いについて確認しておく。
  Note: "\" の振る舞いに関しても確認。
  Note: This doesn't yet handle things like \M-\a と書かれていたが、
    この修正によって取り扱う様になった。

2019-12-18

* report11: 何と test case 2 が直っていないではないか [#D0012]
  何が問題かというと→これについては緊急で直した。
  後で追加パッチとして送る必要がある。

  * ok: うーん。要するに ANYOTHERKEY に移動した時にちゃんと -x も移動するのかという問題?
    以下も後でチェックする必要がある。

    $ bind -x '"\C-t": echo world'
    $ bind '"\C-t\C-t":"hello"'
    →これはちゃんと動いていた。

    $ bind -x '"\C-t": echo world'
    $ bind -x '"\C-t\C-t": echo hello'
    →これは動かないが上の項目と同じ問題であろう。
    →これは上を直したらちゃんと動く様になった事を確認した。OK

  パッチは用意した。メールの準備をする。mail2.txt に書いた。
  後は送信するだけである。
  Done: 送信

* report13: shadow `bind -X' が削除されない [#D0011]

  $ bind '"\C-t\C-t\C-t\C-t":"hello"'
  $ bind -x '"\C-t":echo world'
  $ bind -r '\C-t'
  $ bind -X
  "\C-t": "echo world"

  cmd_xmap から削除されていない。
  実際には動かないので bash_execute_unix_command は削除されている。

  % obinding と nbinding の列挙に問題が在るのかと思ったがそうではなかった。
  % そもそも bind -r で削除する時には obinding と nbinding のチェックは行われていない。

  うーん。観察してみても原因は分からない。観察した限りではちゃんと
  map[ANYOTHERKEY] から削除される様になっている気がする。

  調べてみるとどうやら通過していない。
  どうやらそもそも unbind_unix_command というのが呼び出されていない様だ。

  →これは何が悪いか分かった。修正した。

  Done: 送信

* report12: 以前に作った patch を送るにあたって再現する方法はないか考える [#D0010]

  | rl_bind_key
  |   rl_add_defun
  |   rl_bind_key_in_map
  |   rl_unbind_key
  |   rl_parse_and_bind
  |     これは実際に呼び出す事ができそうである。
  |     実際に動かしてみるとちゃんと動く!
  |
  |     と思ったがこれは今時分が修正済みの branch にいるからだ。
  |     →devel に戻って実行してみたがちゃんと動いている様だ。
  |
  |     % 何で動いているのか理解できない。rl_bind_key が確かに
  |     % key == 0 で呼び出されてそうすると rl_generic_bind に
  |     % 空文字列が渡される。更に rl_translate_keyseq で
  |     % 空文字列は空の keyseq に翻訳される様に見える。
  |     % →確認してみた所そもそも rl_generic_bind は呼び出されていない気がする。
  |
  |     分かった。rl_bind_key で問題の場所に入るのは
  |     ANYOTHERKEY として登録する時のみである。
  |     改めて実行してみる事にする。
  |   prepare_terminal_settings (readline/rltty)

  再現できた。以下で行ける。

  $ bind '"\C-@\C-@":"hello"'
  $ bind 'C-SPC:backward-char'

  結果を作文した。
  Done: 送信

* 2019-02-19 OK: rl_generic_bind に "" を渡した時の振る舞いが気になる [#D0009]
  変な事にはならないのだろうか…。printf して見る事にする。

  | うーん。そもそも bind -r '' だと一番下まで制御が行かない。
  | 更に bind -r '\C-@' としても一番下まで制御が行かない。
  | 少なくとも bind -r '\C-@' はバグである…。bind -r '\0' としても駄目である。
  | うーん。やっぱりそもそも rl_generic_bind まで到達していない気がしてきた。
  |
  | と思ったら rl_generic_bind の冒頭にチェックがある。空文字列の場合には直ちに戻る様子である。
  | しかし、それだと \0 に対する処理が説明できない。
  | 呼び出し元に問題があるという事だろうか。
  |
  | 実際に調べてみた所、空文字列の場合でも rl_generic_bind まで到達しない。
  | うーん。どうなっているのだろうか。一回 bind.def から辿ってみる事にしようか。
  | % unbind_command という関数を呼び出している。
  | % unbind_command は同じファイル bind.def 内で定義されていて、
  | % まず初めに rl_named_function を呼び出して関数を特定し、
  | % それから rl_unbind_function_in_map を呼び出している。
  | % あれ、これは変だ。多分、別の関数である。bind -u function-name である。
  | bind -r に対応するのは unbind_keyseq であった。
  | この関数を覗くと怪しい処理がある。rl_function_of_keyseq を空 keymap に対して呼び出している。
  | これは一体何が目的なのだろうか…→空keymapは現在のkeymap _rl_keymap を使うという指示だった。
  | うーん。ここでは rl_function_of_keyseq_len を使うべきではなかろうか。直してみる事にする。
  | →これは直った。\0 とすれば到達する。
  |
  | '' の時にはそもそも bind されていないので到達しない。
  | もし到達したとしても keyseq = "" の時には一番上のチェックで弾かれるのでOK
  | keyseq != "" であれば必ず 1 文字以上の keys が生成される筈である。

  結論。"" を渡した時には先頭ではねられるので問題にはならない。
  一方で、調べている最中に bind -r '\C-@' が効かないというバグが見つかったので修正する。
  これらはいつ報告する事にしようか。Chet の手を煩わせるのもあれなので、
  "bind -x different keymaps" に対する処置が終わってからという事にしたい。
  丁度そのタイミングで、既存のスレッドに対する追加パッチという形でお願いすれば良い。

* report11: また新しいバグを見つけてしまった [#D0008]

  $ LANG=C ./bash-3a7c642e --norc
  $ bind -s '"\C-t\C-t":"hello"'
  $ bind -x '"\C-t":echo world'
  $ <-- <C-t>
  bash-3a7c642e: bash_execute_unix_command: cannot find keymap for command

  bash-4.0 -- 4.2 は segfault
  bash-4.3 は動く
  bash-4.4 から上記の振る舞い

  これは何による物だろうか。
  削除されてしまっている?

  調べてみると timeout したとしても実際に受信している入力が受け取られる?
  否、何だか変だ。C-t しか入力していないのに C-t C-t が受信された事になっている。
  少なくとも rl_executing_keyseq の中身はそういう事になっている。

  そして以下の様にしてみると C-t しか入力していなくても
  C-t C-t を入力したかの様に振る舞っている。

  $ LANG=C ./bash --norc
  $ bind -x '"\C-t\C-t":echo hello'
  $ bind -x '"\C-t":echo world'
  $ <-- <C-t>
  hello

  何かが変である。どうも調べてみると timeout の時には、
  これまでに入力された内容をそのままにして
  改めて dispatch を呼び出している?
  その事によって同じ文字が二重に書き込まれている?
  試してみる事にする。

  $ bind -s '"\C-t\C-u":"hello"'
  $ bind -x '"\C-t":echo world'
  $ <-- <C-t>
  <C-t> <C-t> に対して一致が試みられている。

  うーん。具体的にどの様な構造になっているのか
  ちゃんと確認してからでないと書き換えられない。
  然し、chatoyancy は遅いのでなかなか確認するのが難しい。
  結局どの様な処理の流れになっているのだろうか。
  ユーザが入力をすると一番最初に呼び出されるのはどの関数か。

  うーん。readline -> readline_internal -> readline_internal_charloop
  -> readline_internal_char になっている?
  更に _rl_dispatch(c, _rl_keymap) を呼び出している。
  其処から _rl_dispatch_subseq を呼び出している。
  其処で色々 dispatch していて、通常であれば末尾まで来て、
  其処で _rl_subseq_getchar で新しいキーを読み取って、
  それに基づいて再帰的に _rl_dispatch_subseq を呼び出している?

  _rl_subseq_result は何れにしても呼び出される様だ?
  _rl_subseq_result に -2 を渡した時が何も対応する物に一致しなかった時。
  そしてその時は一旦短くして再一致を確かめるという事の様だ。

  ? _rl_subseq_result に -2 が渡されるのは何処だろうか。

    | rl_executing_keyseq に文字を追加した直後に二箇所明示的に渡している箇所がある。
    | それ以外の場合は dispatch_subseq の戻り値をそのまま渡している。
    |
    | _rl_dispatch_subseq の戻り値は別の _rl_dispatch 呼び出しの戻り値か、
    | - 成功した時は 0 で
    | - ANYOTHERKEY が見つかった時に -2 を返している。
    | - got_subseq がある時には -1 を返す事になっている。
    | - 或いはそうでなくても何も見つからなかった時に
    |   状態をクリア (_rl_abort_internal) して -1 を返している。
    |   _rl_abort_internal の中を確認してみるとこれは緊急用だろうか?
    |   何れにしても -1 は何らかのエラーがあった時用に見える。
    | - 或いは _rl_subseq_result の戻り値をそのまま返している箇所もある。
    | - r = RL_ISSTATE (RL_STATE_MULTIKEY) ? -3 : 0; で決めた物を
    |   返している箇所もある。-3 は今回関係なさそうなので無視する。
    |
    | _rl_subseq_result に関しては、
    | _rl_dispatch, _rl_dispatch_subseq の戻り値を返しているか、
    | 或いは ANYOTHERKEY なら -2 で失敗なら -1 を返している。
    |
    | 取り敢えず ANYOTHERKEY または timeout の時に -2 になる。
    | うーん。何故 ANYOTHERKEY を要求しているのだろうか。
    | というか ANYOTHERKEY が設定されるのはどういう時だろうか。
    |
    | うーん。調べてみると確かに ANYOTHERKEY が設定されている。
    | ANYOTHERKEY が設定されている理由は何だろうか。
    | もし常に設定されている物だとすれば
    | それをチェックする理由は何だろうか。
    |
    | 或いは ANYOTHERKEY の場所に
    | subseq 一致の時の binding を格納している?
    | 調べてみるとそれっぽい。ANYOTHERKEY の場所に入っているのは
    | bash_execute_unix_command だった。bind -s にしてみると、
    | また別の値が入っていた。
    |
    | OK。つまり ANYOTHERKEY を実行するというので良い。

    -2 が渡されるのは対応する binding が見つからなかった時で、
    然し ANYOTHERKEY に対応する binding が設定されている時である。
    ANYOTHERKEY には timeout の時の設定が格納されている。
    そして timeout の時には見つからなかったとして処理される。
    結果として部分一致の結果を実行するという動作になっている。

  * ここでどの様に修正したら良いだろうか。
    timeout の時には rl_executing_keyseq を短くする必要がある気がする。
    然し、そうでない場合には短くするのは変な気がする。
    例えば本当に対応するキーがなかったとしたら
    その時はそのキーを保持するべきなのでは。

    うーん。呼び出し元の ungetc と一緒に短くするべき?
    試してみたが何だか動作が分からない。

    | そもそも 3 文字の時に timeout にならない…。
    | 実装を見ると ANYOTHERKEY をチェックしているので
    | n-1 文字の設定がない限りは n 文字は timeout しないのだ。
    | これは元々特殊キーと ESC を区別する為の timeout と思えば、
    | 確かに中途半端なキー状態で timeout するのは変である。
    | これに関しては備考として残しておくことにする。

  ここで問題は timeout の時ばかりではない事が判明した。
  上に追記した。新しく来た文字に対応する binding がない時に。
  どの様に処理が進むのかという事を確認する必要がある。

    うーん。新しく来た文字に対応する binding がない時に
    どういう分岐をするのか。どうも ISFUNC が設定されている様だ。
    その上で func が 0 になっている。調べると #define ISFUNC 0 である。
    やはり初期状態は全て {ISFUNC, 0} が設定されているのだろう。

  ? cmd_xmap から bind を削除する時にカウントをチェックしている。
    ANYOTHERKEY はちゃんとカウントされているのだろうか。

    例えば tt と t に bind して t を unbind したらちゃんと削除される?
    更に tt と t に bind して tt を unbind したら t に対して
    ちゃんと timeout なしで反応するか?

2019-02-11

* report10: 取り敢えず mail を作成する事にする [#D0007]

  | 2016-11-09
  |
  | * そもそも keymap に登録されたコマンドを実行しているのはどこだろう。
  |
  |   色々探しまわってみると ISFUNC で関数を登録し、ISMACR でマクロ文字列を登録している様だ。
  |   lib/readline/bind.c の中を探しても呼び出している様な場所は見つからない。
  |   よく考えてみたらファイル名が bind である。つまり、ここには登録関係の関数しかない。
  |   検索で ISFUNC をしてみると readline に case ISFUNC: というものがある。
  |   其処に行ってみると取得した関数を実行している。_rl_dispatch_subseq という関数の中だ。
  |
  |   cmd_xmap を廃止してデータを同じキーマップにまとめて登録するのだとしたら、
  |   この辺りの呼び出し方を調べる必要がある。
  |   先ず、現在の設計だと登録されているエントリへのポインタを
  |   呼びだされた関数が直接取得するのは難しそうだ。
  |
  |   a readline 側のサポートが必要になる。しかし、cmd_xmap が readline 側ではなく
  |     bash 側で用意されていることなどから考えるに自由に関数を登録できるような仕組みはそもそも readline にはない。
  |     readline を拡張して cmd_xmap 埋め込みに対応できる様にするというのは readline の機能を大幅に拡張する事になり大げさである。
  |
  |   b 従ってやはり bash 側で何とかいい感じに誤魔化して実装する必要がある。
  |     例えば現在の kmap と key 等を取得することができれば bash 側で同様に map[key].function から同一の情報を得られる。
  |
  |     % しかし readline を見る限り _rl_dispatch_subseq で使われる map, key は動的に指定され外部から取得するのは難しいのではないかという気がする。
  |     % ちょっと調べてみた。大体の場合は map は _rl_dispatching_keymap に一致している様だ。
  |     % しかし _rl_dispatch_callback 経由で _rl_dispatch_subseq が呼び出される場合には予想できない。
  |     % やはり bash で独立に同じ kmap を取得するというのには難がある気がする。
  |     % それが理由で cmd_xmap という内部用の keymap を管理するという事になっているのであろう。
  |     %
  |     % また改めて bash の cmd_xmap の参照の部分を確認してみる。
  |     % rl_executing_keyseq というのを参照している。これは何処で公開される物だろうか。
  |     % こでは readline.c で定義され readline.c で管理されている。readline.h で公開されている。
  |     % この rl_executing_keyseq と一緒に現在の keymap も公開すれば良いのではないだろうか。
  |     % うーん。と思って改めて readline.c を見てみると rl_executing_keymap という物がある。
  |     % 何だこれはと思って調べてみると丁度正に rl_dispatch_subseq で map を外に公開する為に
  |     % rl_executing_keymap = map となっていた。つまり、_rl_dispatch_subseq で使われる
  |     % map および key は普通に外部に公開されていたという事である。
  |
  |     という訳で _rl_dispatch_subseq で使用された map 及び key は、
  |     rl_executing_keymap および rl_executing_key で取得することが可能である。
  |     つまり rl_executing_keymap[rl_executing_key].function とやれば良い。
  |
  |   しかし此処でやはり問題が…。ISMACR の場合には登録されている内容は free の対象であったが、
  |   ISFUNC の場合には登録されている内容は関数へのポインタであって free の対象ではない。
  |   (というか初め ISMACR で関数が登録されているのかと考えて、関数へのポインタへのポインタだと勘違いしていた。)
  |   という事は勝手に新しい情報を ISFUNC に紐付けて登録する事はできないという事になる。
  |
  |   或いは、keymap の entry に新しい項目を追加してしまうというのも手なのかもしれない。
  |   keymap は Keymap 型であり、Keymap 型は以下のように定義されている。
  |     typedef KEYMAP_ENTRY *Keymap;
  |   KEYMAP_ENTRY は struct _keymap_entry の typedef で、_keymap_entry は単純に
  |   char type と rl_command_func_t* function の二つのメンバを持つ。
  |
  |   うーん。この _keymap_entry を改造する位ならば ISMACR, ISFUNC に代わる
  |   type を作成する方が見通しが良い気がする。うーん。
  |   或いは、cmd_xmap に登録する時に keymap も鍵として使用して登録してしまう?
  |   しかし問題が二点ある。
  |
  |   1 keymap の同一性をどの様に判定するのか。
  |     単純にポインタで良いのか。
  |     もし realloc されるとポインタの値が変わってしまう事には注意しなければならない。
  |     keymap に対応する id 番号の様な物が存在すればそれが良いのであるが…。
  |
  |     readline の中を grep する限りは keymap は realloc していない様な気がする。
  |     もっとちゃんと調べる必要がある。cmd_xmap は rl_make_bare_keymap で生成している。
  |     rl_make_bare_keymap は readline/keymaps.c に定義が存在して、
  |     rl_make_keymap 及び rl_copy_keymap から使用されている。
  |     rl_make_bare_keymap の実装を見る限り keymap の長さは固定であるので realloc はない。
  |     また rl_make_keymap 及び rl_copy_keymap は現状では誰も使っていない様だ。
  |
  |     rl_make_bare_keymap を使っている箇所も特に見当たらない。cmd_xmap と、
  |     vi_mode.c の vi_replace_map だけだ。ではその他の keymap はどの様に確保されるのだろうか。
  |     様々の名前がついている keymap は何処なのかと思って探してみると、
  |     readline/bind.c の中に名前が定義されている。実体は各専用のファイルに定義されている様だ。
  |     例えば、"emacs", "emacs-standard" は emacs_standard_keymap という変数に紐付けられ、
  |     これは emacs_keymap.c で定義されている。そしてこれは何と静的な配列である。
  |     特にこれらの基本的な keymap に関して言うならばアドレスが変化するという事はなさそうだ。
  |
  |     では複数のキーに紐付いて設定される keymap に関してはどうだろうか。
  |     一旦削除されてから再度確保し直されるとしても、
  |     前の keymap から新しい keymap への引き継ぎが為されていないのであればそれを追跡する必要はない。
  |     偶たま同じアドレスになるとしてもその場合には
  |     本体の keymap の方に改めて登録するときに一緒に cmd_xmap の方にも登録するので、
  |     その時に上書きされるので変な衝突が起こるという事もないだろう。
  |
  |   2 keymap が消滅する時や unbind する時にどうやってエントリを削除するのか。
  |     しかし、よく考えて見ればこれは現在の実装でも問題になっている筈である。
  |     実装を見た感じ登録するコードは存在しても削除するコードが存在していない気がする。
  |
  |     試してみたところ一度登録した bind -X は二度と解除されない様だ。。
  |
  |     うーん。やはりこれに対応する為には bind/unbind の時に一緒に開放もしなければならず、
  |     その為には readline/bind.c を修正しなければならない。つまり、readline 側での特別な対応が必要である。
  |     もし ISFUNC において関数ポインタを格納する場所が動的に確保される領域であったならば、
  |     その動的確保される領域を勝手に拡張して後半に引数のデータを保持すれば良かった。
  |     しかし実際にはその様な実装にはなっていない様だ。
  |     代わりに ISMACR で格納する様にすれば追加のデータと関数ポインタを一緒に記録できるが、
  |     ISMACR は単にキーボードマクロとして処理されてしまうのでそのままでは使えない。
  |
  |   結局 readline を弄らないとまともな対応は不可能に思われる。
  |   readline を拡張するとすれば param 付きの関数を登録できる様にするという手がある。
  |   param は一個で良い。関数ポインタ単体の時に何が問題かというと動的な機能を登録できないという事である。
  |   つまり、関数ポインタは通常は静的な関数からしか取得できないので静的な機能にならざるを得ない。
  |
  |   要旨: bash_execute_unix_command の内部で元のエントリを取得する事は可能である。
  |   グローバル変数 rl_executing_keymap rl_executing_key を使えば良い。
  |   しかし一番問題になるのは登録されたデータの解放である。
  |   本体 keymap に対する unbind と共に行うのだとすればやはり readline を書き換えるのが易い。
  |   「readline 関数の呼び出し全てに介入して readline の処理を模倣して事前に cmd_xmap の更新を行う」
  |   という方法もできなくはないが結局 readline/bind.c を再実装しているだけに過ぎない気がする。
  |
  |   もう readline を拡張する方向で行くしかない気がする。
  |   しかしその前に C-@ の原因について調べて置かなければならない。
  |
  | ------------------------------------------------------------------------------
  |
  | * [bug] bind -x で登録された項目が内部的に残っている。
  |   更に bind -X で内部的に残っている項目まで全て出力される。
  |
  |   $ LANG=C ./bash --norc
  |   $ bind -X
  |   $ bind -x '"A": echo hello'
  |   $ bind -X
  |   "A": "echo hello"
  |   $ bind '"A": self-insert'
  |   $ bind -X
  |   "A": "echo hello"  # <-- overwritten keyseq is still remained
  |   $ exit
  |
  |   マクロの場合にはちゃんと消える。
  |
  |   $ LANG=C ./bash --norc
  |   $ bind -s
  |   $ bind '"A":"hello"'
  |   $ bind -s
  |   "A": "hello"
  |   $ bind '"A": self-insert'
  |   $ bind -s # <-- nothing output, the entry was successfully removed
  |   $ exit
  |
  | * [bug] cmd_xmap が keymap 間で共有されている。
  |   複数の異なる keymap に登録すると一方が他方を上書きする。
  |
  |   $ LANG=C bash-4.4 --norc
  |   $ bind -m emacs -x '"A":echo emacs'
  |   # ----- type A -----
  |   emacs
  |   $ bind -m vi -x '"A":echo vi'
  |   # ----- type A -----
  |   vi
  |   $ exit
  |
  |   $ LANG=C bash-4.4 --norc
  |   $ bind -m emacs '"A":"echo emacs"'
  |   # ----- type A -----
  |   $ echo emacs
  |   emacs
  |   $ bind -m vi '"A":"echo vi"'
  |   # ----- type A -----
  |   $ echo emacs
  |   emacs
  |   $ set -o vi
  |   # ----- type ESC A -----
  |   $ echo vi
  |   vi
  |   $ exit
  |
  |   $ LANG=C bash-4.4 --norc
  |   $ bind -m emacs -x '"A":echo emacs'
  |   # ----- type A -----
  |   emacs
  |   $ bind -m vi -x '"A":echo vi'
  |   # ----- type A -----
  |   vi
  |   $ set -o vi
  |   # ----- type A -----
  |   vi
  |   $ set -o emacs
  |   $ exit
  |
  | * [bug] cmd_xmap には bind 時の文字列が全体の keyseq として登録される。
  |   例えば emacs-ctlx には C-x に続いて何かを入力した時の動作を指定する事ができるが、
  |   これに対して bind -x しようとしても正しく登録する事ができない。
  |   (とはいいつつこれは単に bind -m emacs -x '"\C-x?": ...' とすれば期待通りにできるので回避可能である。)
  |
  |   $ LANG=C bash-4.4 --norc
  |   $ bind -m emacs -x '"A":echo hello'
  |   # ----- type A -----
  |   hello
  |   $ bind -m emacs-ctlx -x '"A":echo world'
  |   # ----- type C-x A -----
  |   bash-4.4: bash_execute_unix_command: cannot find keymap for command
  |   # ----- type A -----
  |   world
  |   $
  |   $ exit
  |
  |   マクロの場合にはちゃんとできる。
  |
  |   $ LANG=C ./bash --norc
  |   $ bind -m emacs-ctlx '"A":"hello world"'
  |   $ exit

* report9: convert-meta と unmeta について [#D0006]

  まとめ始めたが何だか分からなくなった。
  というか unmeta を if の中に入れるだけでは治らない。
  cmd_xmap と現在の kmap で map[ESC].type == ISKMAP の
  状態が異なる為に不一致が起こっている。

  _rl_convert_meta_chars_to_ascii を参照している箇所を確認して、
  全体としての一貫性がどうなっているのかを改めて確認する必要がある。

  bind.c:144: rl_bind_key に関しては、そもそも meta char を受け取って、
  現在の kmap[ESC] が存在していない場合には "out of range" の扱いだそうだ。

  bind.c:400: rl_generic_bind については、
  そもそも keys, keys_len を翻訳する時に工夫すれば良いのでは?

    →rl_translate_keyseq を修正したので変更不要の気がするが、
    使わないコードを残しておく理由もないので削除する。

  bind.c:523: rl_translate_keyseq は \M- の形式だけ \e に変換している。
  他の場所で meta chars を分解するぐらいであればそもそもこの場所で
  \e に分けて置いた方が良いのではないだろうか。

    →強制的に ESC と UNMETA (c) に分ける様に書き換えた。
    実装を見てみても最大バッファ長さは strlen(str)*2 + 1 で変わらないと思う。

  bind.c:799: _rl_function_of_keyseq_internal は書き換えかけたが…
  よく考えたらこれは読み取りのコードなのでこのままで良い気がする。
  書きかけて削除したコードは以下に残しておく。

    | char* keys;
    | int keys_len;
    |
    | keys = keyseq;
    | keys_len = len;
    |
    | if (_rl_convert_meta_chars_to_ascii)
    |   {
    |     keys = (char *)xmalloc(len * 2 + 1);
    |     keys_len = 0;
    |     for (i = 0; keyseq && i < len; i++)
    |       {
    |         unsigned char ic = keyseq[i];
    |         if (META_CHAR (ic))
    |           {
    |             keys[keys_len++] = ESC;
    |             keys[keys_len++] = UNMETA (ic);
    |           }
    |         else
    |           keys[keys_len++] = ic;
    |       }
    |     keys[keys_len] = '\0';
    |   }

  bind.c:2588: rl_invoking_keyseqs_in_map
  これは正直 \M-? と出力しようが \e? と出力しようがどちらでも良い。
  \e が kmap に存在するかどうかで動作を分けるのも妙な気がするが。
  と思ったが、この構造を追うと map[ESC].type == ISKMAP は恒真ではないか。なので気にしない。

    | for (key = 0; key < KEYMAP_SIZE; key++)
    |   {
    |     switch (map[key].type)
    |       case ISKMAP:
    |         {
    |           for (i = 0; seqs[i]; i++)
    |             {
    |               if (key == ESC)
    |                   if (_rl_convert_meta_chars_to_ascii && map[ESC].type == ISKMAP)
    |                     sprintf (keyname, "\\M-");
    |                   else
    |                     sprintf (keyname, "\\e");

  readline.c:817: _rl_dispatch_subseq
  うーん。これは一体何をやっているか分からない。meta char が指定された時は、
  map に ESC がなければ rl_ding というのを実行している。
  これは実装を確認すると単にベルを鳴らすだけの話である。
  これは受け取った文字を使って kmap を辿る操作である。
  meta char は ESC と UNMETA (c) に分解して辿る。
  これはこのままで問題ない。

  取り敢えず patch を作った。

* report7: 序でなのでこれも報告する事にする [#D0005]
  ref ble.sh/memo.txt#D0920

* report8: 改めてバグ報告をする事にする [#D0004]
  ref ble.sh/memo.txt#D0918
  簡単なバグなのですぐ送ってしまう事にする。

2018-05-03

* report6: 月を跨いだので現在分かっている最後のバグについて patch を送る事にする [#D0003]
  このバグについてのメモは何処かにあるはずだと思ったが、
  確認してみると何処にも見つからない。
  仕方がないので改めて際限コードを作成する事にする。

  $ bash-4.4 --norc
  $ f1() { bind -x '"\C-t": f1'; }; f1
  bash-4.4: $'\317\003': command not found

2018-03-23

* READLINE_POINT が bytes 単位である事について [#D0002]

  これは ble.sh の方にメモがあるかと思ったら何もなかった。そういう仕様だという前提で書かれたのであろう。
  READLINE_POINT が bytes 単位である事を認識して書いているコードはどれぐらいあるだろうか。

  | 正しく実装する一つの方法は LC_CTYPE を設定してから文字列の長さを測るという物である。
  | [Search](https://github.com/search?utf8=%E2%9C%93&amp;q=LC_CTYPE+READLINE_POINT+NOT+LC_MESSAGES+NOT+rl_line_buffer&amp;type=Code)
  | →[dot/kingbash.script](https://github.com/billinux/dot/blob/986cc0b8df950687ff0b50aced6df5a755a9b9d3/bin/kingbash.script)
  |
  | もう一つの方法は LC_ALL を設定するという物。
  | [Search](https://github.com/search?q=LC_ALL+READLINE_POINT+NOT+LC_MESSAGES+NOT+rl_line_buffer+NOT+READLINE_LINE_BUFFER&amp;type=Code&amp;utf8=%E2%9C%93)
  |
  | 或いは wc -c でも数えられるかもしれない。
  | [Search](https://github.com/search?utf8=%E2%9C%93&amp;q=wc+%22READLINE_POINT%3D%22+NOT+LC_MESSAGES+NOT+rl_line_buffer+NOT+READLINE_LINE_BUFFER&amp;type=Code)

  他の検索

  | [Stack Overflow](https://stackoverflow.com/search?q=%22READLINE_POINT%22)

  結局、どうやら kingbash.script で対策されているだけで他には使われていない様である。
  [Bash/関数 - ArchWiki](https://wiki.archlinux.jp/index.php/Bash/%E9%96%A2%E6%95%B0)
  によると KingBash はメニュー補間を実現するスクリプト (2008) の様である。

  kingbash.script の場合には単に文字列末端にカーソルを移動するだけである (要確認)。
  LC_ALL=C LC_CTYPE=C で過大評価になるだけなので結局文字列末端に移動することは変わらない。

  とにかく初めに READLINE_POINT の修正案を提示する事が先である。
  先ず文字列の長さを数える方法について確認する。
  或いはパラメータ展開の offset, length をどの様に処理しているか。

  subst.c:4411: mb_getcharlens (string, len)
  subst.c:7639: mb_substring (string, s, e)
  lib/readline/mbutil.c:363: _rl_find_next_mbchar (char *string, int seed, int count, int flags)

  文字数からバイト位置に変換するのは _rl_find_next_mbchar で良さそうだ。flags = 0
  mb_getcharlens は調べてみると何処からも使われない。
  というか ifdef INCLUDE_UNUSED の中にあるというのはそういう事の様だ。
  他に類似の機能はないだろうか。というか ${#var} の場合に何れにしても数える必要があるので、
  何処かでその機能は存在しているはずである。

  subst.c:6967: parameter_brace_expand_length (name) の中の
	subst.c:7021:           number = MB_STRLEN (t); である。

  MB_STRLEN は incloude/shmbutil.h で定義されている。

  $ rl-insert () { READLINE_LINE=${READLINE_LINE::READLINE_POINT}$1${READLINE_LINE:READLINE_POINT}; ((READLINE_POINT+=${#1})); }
  $ bind -x '"\C-t": rl-insert AA'
  $ echo あ|いうえお

  ここで C-t を押してみるとあらぬ所に挿入される。更に続けて文字を入力すると文字が壊れる。

2018-03-21

* 改めて C-@ の問題について patch を送る事にした [#D0001]

  関連して他の問題もある。`rl_bind_keyseq_if_unbound_in_map' 287 lib/readline/bind.c で、
  引数 keyseq を rl_function_of_keyseq と rl_bind_keyseq_in_map に渡している。
  rl_function_of_keyseq は translated sequences を受け取る関数である。
  rl_bind_keyseq_in_map は untranslated sequences を受け取る関数である。

  rl_function_of_keyseq が translated sequences を受け取る関数であることの根拠

    o 実装がその様になっている (長さを受け取らないので欠陥であるが)。
    o bash_execute_unix_command で translated sequences を渡している。
    - initialize_readline (bashline.c) で null-terminated sequences を渡している…が、
      これは何とも言えない。

  rl_bind_keyseq_in_map が untranslated sequences を受け取る関数であることの根拠

    o 中で rl_translate_keyseq を呼び出している。
    o bind_keyseq_to_unix_command で bind -x '"...": ...' の最初の ... の部分を
      rl_bind_keyseq_in_map に渡している。

  rl_bind_keyseq_if_unbound_in_map が untranslated sequences であるべき理由

    o 長さを受け取っていないので、translated だと問題が起こる。
    - rl_bind_key_if_unbound_in_map から null-terminated で呼び出している。
    - rl_bind_key_if_unbound から null-terminated で呼び出している。
    - rl_bind_keyseq_if_unbound は等価な関数
    x bind_termcap_arrow_keys で使われている rl_bind_keyseq_if_unbound は
      translated sequences でなければならない。
      →これは keys, key_len 引数を受け取る様にしなければならない。
      もしこれに対応するとすると、
      - rl_bind_keyseq_if_unbound_in_map
      - rl_bind_keyseq_in_map
      - rl_generic_bind
      それぞれに対して keys, key_len を受け取る版を作成しなければならない。x

  ToDo:
    rl_bind_key_if_unbound_in_map: untranslate
    rl_bind_key_if_unbound       : untranslate

  以下は昔書きかけた bug report

  | From: murase
  | To: bug-bash@gnu.org
  | Subject: [50 character or so descriptive subject here (for reference)]
  |
  | Configuration Information [Automatically generated, do not change]:
  | Machine: i686
  | OS: linux-gnu
  | Compiler: gcc
  | Compilation CFLAGS:  -DPROGRAM='bash' -DCONF_HOSTTYPE='i686' -DCONF_OSTYPE='linux-gnu' -DCONF_MACHTYPE='i686-pc-linux-gnu' -DCONF_VENDOR='pc' -DLOCALEDIR='/home/murase/opt/bash-4.4/share/l\
  | ocale' -DPACKAGE='bash' -DSHELL -DHAVE_CONFIG_H   -I.  -I. -I./include -I./lib   -O2 -march=native -Wno-parentheses -Wno-format-security
  | uname output: Linux padparadscha 4.7.2-101.fc23.i686 #1 SMP Fri Aug 26 16:39:46 UTC 2016 i686 i686 i386 GNU/Linux
  | Machine Type: i686-pc-linux-gnu
  |
  | Bash Version: 4.4
  | Patch Level: 0
  | Release Status: release
  |
  | Description:
  |   [Detailed description of the problem, suggestion, or complaint.]
  |
  | Repeat-By:
  |
  |   $ LANG=C bash-4.4 --norc
  |   $ bind -x '"\C-@":echo hello'
  |   $
  |   # ----- type C-@ or C-space -----
  |   bash-4.4: bash_execute_unix_command: cannot find keymap for command
  |   $ bind -x '"\C-A":echo hello'
  |   # ----- type C-a -----
  |   hello # expected result for C-a
  |   $ exit
  |   $ LANG=C bash-4.3 --norc
  |   $ bind -x '"\C-@":echo hello'
  |   $
  |   # ----- type C-@ or C-space in the terminal -----
  |   bash-4.3: bash_execute_unix_command: cannot find keymap for command
  |   $ exit
  |   $ LANG=C bash-4.2 --norc
  |   $ bind -x '"\C-@":echo hello'
  |   # ----- type C-@ or C-space -----
  |   hello
  |   $ exit
  |
  | Fix:
  |   [Description of how to fix the problem.  If you don't know a
  |   fix for the problem, don't include this section.]

  以下はこれについての古い項目

  | 2016-11-09 C-@ に bind -x すると実行に失敗する原因は分かった。
  |
  | | 先ず bind -X するとちゃんと登録されている。
  | | よく分からないので登録時・読み取り時の kseq 変数の中身を printf で見てみる。
  | | どうやら登録時は bind に指定した引数 (の部分文字列) をそのまま渡している様だ。
  | | そして読み取り時は入力したキーの列がそのまま渡されている。
  | | これだと登録時と読み取り時で異なるシーケンスになるのが普通だがこれで良いのか?
  | | 試しに C-a で試してみると両者が異なっていてもちゃんと機能する様だ。
  | | というか、登録時の kseq と読み取り時の kseq は意味合いが異なるのだろう。
  | |
  | | と、ここで読み取り時に実際に入力したキーの列が格納されているのはヌル終端文字列である。
  | | ヌル終端文字列に C-@ を含ませる事は不可能である。
  | | これだと長さ 0 になってしまうのではないだろうか。
  | | そしてこの推測が正しければ、そもそも C-@ を一文字でも含む様なキーシーケンスは全然登録できない。
  | | 試してみることにする。
  | |
  | | C-@A で試してみた所やはり同様に
  | |   bash: bash_execute_unix_command: cannot find keymap for command
  | | のエラーが発生する様だ。(C-@ set-mark が残っているので、
  | | 素早く入力しないと set-mark の方が呼び出されてしまう事に注意する。
  | | # というか C-@ を解除する方法はないのだろうか…と思ったら普通に bind -r で良かった。
  |
  | [まとめ]
  |
  | cmd_xmap から読み出す時に rl_executing_keyseq (ヌル終端文字列) を使っているが、
  | そこに C-@ が含まれていると其処で文字列が終端していると見なされて読み出せない。
  |
  | さてではどの様に修正したら良いであろうか。
  | ヌル終端文字列を受け取る関数 rl_function_of_keyseq を見るといろいろな箇所で用いられている。
  | 何故これが問題にならないのであろう。。というかこの関数は本当にヌル終端文字列を受け取る関数なのか?
  | → bind -x '"\\\\": echo double bslash' として \ \ と入力したら rl_function_of_keyseq に "\\" が渡され、
  | 結果として正しく echo double bslash が実行された。つまり rl_function_of_keyseq は "\\" をちゃんと二文字の \ と認識している。
  | 勝手にエスケープされた一文字の \ という様に誤解釈したりはしない様だ。つまり、
  | rl_function_of_keyseq は本当にヌル終端文字列を受け取るという事である。
  |
  | ここで、その他の rl_function_of_keyseq で問題が生じないのかどうかを調べる必要がある。
  | 先ず rl_function_of_keyseq の実装を念のため確認する。やはり常に生のヌル終端文字列として取り扱っている。
  | 今度は呼び出し元について調べる。
  | - called by rl_bind_keyseq_if_unbound_in_map:
  |   % readline 内部での呼び出しは rl_bind_keyseq_if_unbound_in_map (bind.c) の引数をそのまま渡すもののみである。
  |   % rl_bind_keyseq_if_unbound_in_map は readline 内部 (bind.c) のみで使用されている。
  |   % - called by rl_bind_key_if_unbound_in_map:
  |   %   key から keyseq を作って渡している。
  |   %   rl_bind_key_if_unbound_in_map は initialize_readline (bashline.c) 内部でハードコートされた引数について呼び出されている。
  |   %   たまたまハードコートされたキーについては C-@ が含まれていないので問題が起こっていないという事だ。
  |   %   他の箇所では使われていない。従ってこれについては問題は生じない。
  |   % - called by rl_bind_key_if_unbound:
  |   %   この関数は誰も使っていない。
  |   %   また、中身は単に rl_bind_key_if_unbound_in_map(key, default_func, _rl_keymap) に置き換えられる。
  |   % - called by rl_bind_keyseq_if_unbound:
  |   %   rl_bind_keyseq_if_unbound_in_map(keyseq, default_func, _rl_keymap) であり、
  |   %   実際に使われている箇所はハードコートされた物と terminfo から読み取った制御シーケンスである。
  |   %   制御シーケンスには NUL は含まれない (ANSI規格に従えば)。従ってこれも問題は起こらない。
  |   これはよく見てみれば別のバグで rl_function_of_keyseq に keys を渡す時に翻訳を忘れているだけだった。
  |   その修正さえすれば何の問題もない。
  | - called by bashline.c (initialize_readline):
  |   四ヶ所から呼び出されているが全部ハードコードされた物であり NUL は含まれていない。
  | - called by bashline.c (bash_execute_unix_command):
  |   これは今問題になっている関数である。
  |
  | 結局今回問題になっている物以外は全てハードコードされた物であって (たまたま) 何も問題が生じていないという事の様だ。
  | さて rl_function_of_keyseq を拡張して長さを指定できる様にするとしたらどの様にするか。
  | 長さを取得する方法が必要である。
  | 調べると rl_key_sequence_length という変数に長さが入っている様だ。
  | 似た変数名として rl_executing_keyseq_size という物があるが、
  | これは buffer のサイズを保持しているのであって長さを保持している訳ではない事に注意する。
  | extern int rl_key_sequence_length は readline.h で公開されている。
  | という訳で
  |
  | さて似たような事が他で問題にならないのかというのは不思議である。
  | - rl_untranslate_keyseq この関数名は怪しいと思って確認した見たが、
  |   keyseq といいつつこれは1文字を文字列に変換するだけの関数である。
  | - というかそもそも keymap は終端をどの様に検知しているのだろう?
  |   うーん。というかそもそも kseq を保持する様な実装にはなっていなくて、
  |   keymap の chain を辿っていく仕組みになっていて、唯一長さを意識するのは bind 時であったが、
  |   これは ASCII rep で渡しているから問題ないということなのか。しかしそれでも rl_translate_keyseq に渡すから、
  |   問題になるのじゃないかと思ったが…rl_translate_keyseq はちゃんと int* len という引数に結果を格納する。
  | ★rl_bind_keyseq_if_unbound_in_map この関数は引数 keyseq の使い方が怪しい。
  |   keyseq を rl_function_of_keyseq と rl_bind_keyseq_in_map にそのまま渡している。
  |   rl_function_of_keyseq は keyseq を直接表現として取り扱う。
  |   rl_bind_keyseq_in_map は keyseq をASCII表現として取り扱う。
  |   ドキュメントによると keyseq は ASCII 表現でなければならない気がする。
  |   つまり変換が必要である。
