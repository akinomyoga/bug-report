
------------------------------------------------------------------------------
  Memo
------------------------------------------------------------------------------

2019-12-18

* Bash 仕様: n key目の timeout は n-1 key目がある時にのみ起こる。

  これは元々 keymap-timeout の機能自体が vi モードで ESC と
  矢印キーを区別するための物だからであろう。
  ESC [ まで受信してその次が暫く来なかった時に、
  CSI シーケンスが終了するのを待つ方が自然である。
  従って timeout して "ESC" + "[" に分解される事はない。

  然し、ユーザが abc と a に対して束縛している時に
  ab まで入力して止まった時に幾ら待っても動かないという事になる。
  この状況でどう振る舞うのが良いのかというのについては非自明である。

2019-02-11

* バグ報告の仕方

  git format-patch devel 等とする。


------------------------------------------------------------------------------
  Bugs
------------------------------------------------------------------------------

2019-12-17

* shadow がそのままになってしまう。
  というかこれについては既にコメントが書かれている。

  $ bind '"\C-t\C-t\C-t\C-t":"hello"'
  $ bind -x '"\C-t":echo world'
  $ bind -r '\C-t\C-t\C-t\C-t'
  $ #<-- <C-t> 500ms 後に world が表示される

  ■これは保留

* report14: ble.sh #D1078 についても。

  | 症状は何だったか。
  |
  | $ bash-5.0 --norc
  | $ bind -p | grep '"\\C-\\'
  | $ bind '"\C-\\": self-insert'
  | $ bind -p | grep '"\\C-\\'
  | "\C-\\\": self-insert
  |
  | $ bash-5.0 --norc
  | $ set -o vi
  | $ bind -p | grep '"\\C-\\'
  | "\C-\\": self-insert
  | $ bind '"\C-\\": self-insert'
  | $ bind -p | grep '"\\C-\\'
  | "\C-\\\": self-insert
  | "\C-\": self-insert
  |
  | これである。中々謎である。ちゃんと \C-\\ と出力される事もあるから、
  | これは何か記録のされ方が変な事になっているのだろうという気がする。
  | 取り敢えず bind -p の処理を何処でやっているかを特定する。
  |
  | rl_function_dumper から rl_invoking_keyseqs_in_map を呼び出している。
  | その中で文字列を構築している。中を確認してみると何だか怪しい。
  | \C-\ が出力されてしまう気がする。しかし blame するとここ8年間ここは動いていない。
  | うーん。ここも怪しいかもしれないが今回の事はここが原因ではない。
  |
  | うーん。実際に出力してみると何故かちゃんと \C-\\ になっている。
  | 一方で bind '"\C-\\a"' が <C-\><C-g> と解釈されていると分かった。
  | 更に bind "\C-\a" は <C-\><a> と解釈されている。
  | この振る舞いは bash 4.3 でも同様であった。つまり自分の所為ではない。
  |
  | 一方で Bash 4.3 では bind "\C-\" の " はエスケープされた物として取り扱われる。
  |
  | うーん。どうやら bind -s や bind -X は大丈夫の様だ。
  |
  | まとめ。
  |
  | bind '"\C-\":"..."' の解釈について、
  | 最初の ".." の切り出しの時には \C-\ を認識せずに単に \ だけを見て ".." を切り出す。
  | 次の解釈の時に \C-\ の単位で解釈を行う。したがって "\C-\\" は \C-\ + \ と解釈される。
  | また出力に関しては bind -sX は \C-\\ を出力するが bind -pP は \C-\ を出力する。

  状況を整理すると Bash では \C-\ と \C-\\ が混ざっている。
  単一文字の束縛に対しては bind -spPX は全て \C-\\ を出力する。

    $ ./bash-3a7c642e --norc
    $ bind '"\x1c":"hello"'
    $ bind -s
    "\C-\\": "hello"
    $ bind '"\x1c":self-insert'
    $ bind -p | grep '\\C-\\'
    "\C-\\": self-insert
    $ bind -P | grep '\\C-\\'
    self-insert can be found on "\C-\\", " ", "!", "\"", "#", ...
    $ bind -x '"\x1c":"echo hello"'
    $ bind -X
    "\C-\\": "echo hello"

  複数文字の束縛に対しては bind -pP は最後の文字以外について \C-\ を出力する。
  また shadow binding の場合は最後の文字以外の場合でも \C-\ になる。

    $ ./bash-3a7c642e --norc
    $ bind '"\x1c\x1c":"hello"'
    $ bind -s
    "\C-\\\C-\\": "hello"
    $ bind '"\x1c\x1c":self-insert'
    $ bind -p | grep '\\C-\\'
    "\C-\\C-\\": self-insert
    $ bind -P | grep '\\C-\\'
    self-insert can be found on "\C-\\C-\\", " ", "!", "\"", "#", ...
    $ bind -x '"\x1c\x1c":echo hello'
    $ bind -X
    "\C-\\\C-\\": "echo hello"

  束縛の解釈については "..." を切り出す時には \C-\" は " をエスケープする。
  然し中身を解釈する時には \C-\ が一つのまとまりと解釈される。

  % どちらが採用されるべきだろうか。
  % 
  % a \C-\\ に統一する案。既存のコードに対する影響はどれほどだろうか。
  %   つまり \C-\ 前提で扱っているコードはあるだろうか。
  %   "\C-\" は使えない。何故なら \" をエスケープする為。
  %   "\C-\a" 等はどうだろうか。これは従来通りの解釈になる様にすればOK
  %   "\C-\\" はどうだろうか。従来は C-\ + \ だったのが今後は C-\ という意味に変わる。
  %   "\C-\\C-a" は C-\ C-a から "C-\ C - a" に意味が変わる。
  % 
  % b 逆に \C-\ に統一する案。"\C-\" を accept する様に書き換えが必要である。
  %   また出力の際に \\ ではなく \ を出力する様に変更する必要がある。

  古い Bash での振る舞いはどうだったか。
  調べてみると出力の inconsistency は Bash 3.0 の時から変わっていない。

  | 解釈の inconsistency についてはどうだろうか。
  | というか何故古い Bash で問題が発生していなかったのか。
  | 
  | どうも解釈に関しては \C-\\ から \C-\ になったのは Bash 5 からの様だ。
  | どの瞬間から変化したのだろうか。もしかして自分が噛んでいたりする?
  | 動作を確認すると rl_parse_and_bind が呼び出されてその中で
  | "..." の中身が抽出されて、それから rl_bind_seq 及び rl_macro_bind に渡される。
  | これらの関数は rl_translate_keyseq を使っている。
  | 
  | うーん。不思議だ rl_translate_keyseq の中は確かに最近変更されているが、
  | 該当部分は変更されていない様に見える。だとすれば渡す側に何か変更がある?
  | 切り出し部分を確認したが全く変更はない。という事はやはり rl_translate_keyseq である。
  | うーん。昔の状態を checkout して何時からこれになったのか調べる。
  | 20190207 の時点でもう変化していた。20180309 の時点でもう変化していた。
  |   20170804 の時点では変化していた。20170601 では変化。
  |     20170505 変化。これが犯人である。
  |   20170407 の時点では未だ。20170421 未変化。20170428 未変化。
  | 20170106 の時点ででは未だ変化していない。
  | 
  | commit af2a77f
  | | diff --git a/CWRU/CWRU.chlog b/CWRU/CWRU.chlog
  | | index 51e95ae3..7892ce94 100644
  | | --- a/CWRU/CWRU.chlog
  | | +++ b/CWRU/CWRU.chlog
  | | @@ -13767,3 +13767,76 @@ lib/glob/sm_loop.c
  | |            matches beyond it.  Look at https://research.swtch.com/glob for a
  | |            longer explanation. This results in a significant speedup for globs
  | |            with multiple instances of `*', especially with more than 4.
  | | +
  | | +                                    5/2
  | | +                                    ---
  | | +lib/readline/bind.c
  | | +        - rl_translate_keyseq: make sure a trailing backslash in the key
  | | +          sequence is preserved. Report from Eduardo Bustamante
  | | +          <dualbus@gmail.com>
  | | +
  | | diff --git a/lib/readline/bind.c b/lib/readline/bind.c
  | | index 117f3427..fef538b1 100644
  | | --- a/lib/readline/bind.c
  | | +++ b/lib/readline/bind.c
  | | @@ -441,7 +441,10 @@ rl_translate_keyseq (const char *seq, char *array, int *len)
  | |            c = seq[++i];
  | | 
  | |            if (c == 0)
  | | +            {
  | | +              array[l++] = '\\';        /* preserve trailing backslash */
  | |                break;
  | | +            }
  | | 
  | |            /* Handle \C- and \M- prefixes. */
  | |            if ((c == 'C' || c == 'M') && seq[i + 1] == '-')
  | 
  | 不思議だこれで振る舞いが変わるのは不思議だ。
  | あ。分かった。テストケースが悪いんだ。
  | 前から \C-\ だったのが、中途半端な \ を無視する事によって
  | \C-\\ がたまたま \C-\ になっていただけなのだ。

  →結局、Bash 3.0 からずっとこの様な取扱いになっていたのだった。
  偶々 \C-\\ が \C-\ + \ になって \ が消滅していたから動いている様に見えたのが、
  commit af2a77f によって顕在化したという事なのである。
  この修正の元になった議論を確認したが恐らく以下のものである。
  https://lists.gnu.org/archive/html/bug-bash/2017-04/msg00139.html
  振る舞い自体については議論に上っていない。何だかよく分からない。
  或いはこの後で ML に関係なく議論が進んだのかもしれない。

  取り敢えず inconsistency は昔からあったので昔の状態に戻すという方針は使えない。

  どう修正されるべきか。

  * これは確実に \C-\\ に変更されるべきである。
    それは今まで動いていた物が動かなくなったから。
    さらに bind -sSX の出力をそのまま使えないから。
    逆に bind -pP の出力が使えなくなるかもだけれども、
    それに関しては同時に対応すればよい。
    他の version の bash の出力を使用する事は考えにくいのだから。

2016-11-09

* sv_isrchterm

  - さて rl_translate_keyseq を使っている箇所を見てみたが、折角 len で長さを受け取っても
    結局それを null-terminated string に変換している。これだと意味ないのではないか。
    例えば sv_isrchterm という関数で _rl_isearch_terminators の更新を行っている。

  ★isearch-terminator に C-@ を指定しても使えない気がする。
  ★emacs-mode-string, vi-cmd-mode-string, vi-ins-mode-string にも似たような問題がある気がするが、
    これは単に出力するだけなので NUL がある場合に其処で途切れていても問題は生じない。


-------------------------------------------------------------------------------
  Done
-------------------------------------------------------------------------------

2019-12-18

* report11: 何と test case 2 が直っていないではないか。
  何が問題かというと→これについては緊急で直した。
  後で追加パッチとして送る必要がある。

  * ok: うーん。要するに ANYOTHERKEY に移動した時にちゃんと -x も移動するのかという問題?
    以下も後でチェックする必要がある。

    $ bind -x '"\C-t": echo world'
    $ bind '"\C-t\C-t":"hello"'
    →これはちゃんと動いていた。

    $ bind -x '"\C-t": echo world'
    $ bind -x '"\C-t\C-t": echo hello'
    →これは動かないが上の項目と同じ問題であろう。
    →これは上を直したらちゃんと動く様になった事を確認した。OK

  パッチは用意した。メールの準備をする。mail2.txt に書いた。
  後は送信するだけである。
  Done: 送信

* report13: shadow `bind -X' が削除されない

  $ bind '"\C-t\C-t\C-t\C-t":"hello"'
  $ bind -x '"\C-t":echo world'
  $ bind -r '\C-t'
  $ bind -X
  "\C-t": "echo world"

  cmd_xmap から削除されていない。
  実際には動かないので bash_execute_unix_command は削除されている。

  % obinding と nbinding の列挙に問題が在るのかと思ったがそうではなかった。
  % そもそも bind -r で削除する時には obinding と nbinding のチェックは行われていない。

  うーん。観察してみても原因は分からない。観察した限りではちゃんと
  map[ANYOTHERKEY] から削除される様になっている気がする。

  調べてみるとどうやら通過していない。
  どうやらそもそも unbind_unix_command というのが呼び出されていない様だ。

  →これは何が悪いか分かった。修正した。

  Done: 送信

* report12: 以前に作った patch を送るにあたって再現する方法はないか考える。

  | rl_bind_key
  |   rl_add_defun
  |   rl_bind_key_in_map
  |   rl_unbind_key
  |   rl_parse_and_bind
  |     これは実際に呼び出す事ができそうである。
  |     実際に動かしてみるとちゃんと動く!
  |
  |     と思ったがこれは今時分が修正済みの branch にいるからだ。
  |     →devel に戻って実行してみたがちゃんと動いている様だ。
  |
  |     % 何で動いているのか理解できない。rl_bind_key が確かに
  |     % key == 0 で呼び出されてそうすると rl_generic_bind に
  |     % 空文字列が渡される。更に rl_translate_keyseq で
  |     % 空文字列は空の keyseq に翻訳される様に見える。
  |     % →確認してみた所そもそも rl_generic_bind は呼び出されていない気がする。
  |
  |     分かった。rl_bind_key で問題の場所に入るのは
  |     ANYOTHERKEY として登録する時のみである。
  |     改めて実行してみる事にする。
  |   prepare_terminal_settings (readline/rltty)

  再現できた。以下で行ける。

  $ bind '"\C-@\C-@":"hello"'
  $ bind 'C-SPC:backward-char'

  結果を作文した。
  Done: 送信

* 2019-02-19 OK: rl_generic_bind に "" を渡した時の振る舞いが気になる。
  変な事にはならないのだろうか…。printf して見る事にする。

  | うーん。そもそも bind -r '' だと一番下まで制御が行かない。
  | 更に bind -r '\C-@' としても一番下まで制御が行かない。
  | 少なくとも bind -r '\C-@' はバグである…。bind -r '\0' としても駄目である。
  | うーん。やっぱりそもそも rl_generic_bind まで到達していない気がしてきた。
  |
  | と思ったら rl_generic_bind の冒頭にチェックがある。空文字列の場合には直ちに戻る様子である。
  | しかし、それだと \0 に対する処理が説明できない。
  | 呼び出し元に問題があるという事だろうか。
  |
  | 実際に調べてみた所、空文字列の場合でも rl_generic_bind まで到達しない。
  | うーん。どうなっているのだろうか。一回 bind.def から辿ってみる事にしようか。
  | % unbind_command という関数を呼び出している。
  | % unbind_command は同じファイル bind.def 内で定義されていて、
  | % まず初めに rl_named_function を呼び出して関数を特定し、
  | % それから rl_unbind_function_in_map を呼び出している。
  | % あれ、これは変だ。多分、別の関数である。bind -u function-name である。
  | bind -r に対応するのは unbind_keyseq であった。
  | この関数を覗くと怪しい処理がある。rl_function_of_keyseq を空 keymap に対して呼び出している。
  | これは一体何が目的なのだろうか…→空keymapは現在のkeymap _rl_keymap を使うという指示だった。
  | うーん。ここでは rl_function_of_keyseq_len を使うべきではなかろうか。直してみる事にする。
  | →これは直った。\0 とすれば到達する。
  |
  | '' の時にはそもそも bind されていないので到達しない。
  | もし到達したとしても keyseq = "" の時には一番上のチェックで弾かれるのでOK
  | keyseq != "" であれば必ず 1 文字以上の keys が生成される筈である。

  結論。"" を渡した時には先頭ではねられるので問題にはならない。
  一方で、調べている最中に bind -r '\C-@' が効かないというバグが見つかったので修正する。
  これらはいつ報告する事にしようか。Chet の手を煩わせるのもあれなので、
  "bind -x different keymaps" に対する処置が終わってからという事にしたい。
  丁度そのタイミングで、既存のスレッドに対する追加パッチという形でお願いすれば良い。

* report11: また新しいバグを見つけてしまった。

  $ LANG=C ./bash-3a7c642e --norc
  $ bind -s '"\C-t\C-t":"hello"'
  $ bind -x '"\C-t":echo world'
  $ <-- <C-t>
  bash-3a7c642e: bash_execute_unix_command: cannot find keymap for command

  bash-4.0 -- 4.2 は segfault
  bash-4.3 は動く
  bash-4.4 から上記の振る舞い

  これは何による物だろうか。
  削除されてしまっている?

  調べてみると timeout したとしても実際に受信している入力が受け取られる?
  否、何だか変だ。C-t しか入力していないのに C-t C-t が受信された事になっている。
  少なくとも rl_executing_keyseq の中身はそういう事になっている。

  そして以下の様にしてみると C-t しか入力していなくても
  C-t C-t を入力したかの様に振る舞っている。

  $ LANG=C ./bash --norc
  $ bind -x '"\C-t\C-t":echo hello'
  $ bind -x '"\C-t":echo world'
  $ <-- <C-t>
  hello

  何かが変である。どうも調べてみると timeout の時には、
  これまでに入力された内容をそのままにして
  改めて dispatch を呼び出している?
  その事によって同じ文字が二重に書き込まれている?
  試してみる事にする。

  $ bind -s '"\C-t\C-u":"hello"'
  $ bind -x '"\C-t":echo world'
  $ <-- <C-t>
  <C-t> <C-t> に対して一致が試みられている。

  うーん。具体的にどの様な構造になっているのか
  ちゃんと確認してからでないと書き換えられない。
  然し、chatoyancy は遅いのでなかなか確認するのが難しい。
  結局どの様な処理の流れになっているのだろうか。
  ユーザが入力をすると一番最初に呼び出されるのはどの関数か。

  うーん。readline -> readline_internal -> readline_internal_charloop
  -> readline_internal_char になっている?
  更に _rl_dispatch(c, _rl_keymap) を呼び出している。
  其処から _rl_dispatch_subseq を呼び出している。
  其処で色々 dispatch していて、通常であれば末尾まで来て、
  其処で _rl_subseq_getchar で新しいキーを読み取って、
  それに基づいて再帰的に _rl_dispatch_subseq を呼び出している?

  _rl_subseq_result は何れにしても呼び出される様だ?
  _rl_subseq_result に -2 を渡した時が何も対応する物に一致しなかった時。
  そしてその時は一旦短くして再一致を確かめるという事の様だ。

  ? _rl_subseq_result に -2 が渡されるのは何処だろうか。

    | rl_executing_keyseq に文字を追加した直後に二箇所明示的に渡している箇所がある。
    | それ以外の場合は dispatch_subseq の戻り値をそのまま渡している。
    |
    | _rl_dispatch_subseq の戻り値は別の _rl_dispatch 呼び出しの戻り値か、
    | - 成功した時は 0 で
    | - ANYOTHERKEY が見つかった時に -2 を返している。
    | - got_subseq がある時には -1 を返す事になっている。
    | - 或いはそうでなくても何も見つからなかった時に
    |   状態をクリア (_rl_abort_internal) して -1 を返している。
    |   _rl_abort_internal の中を確認してみるとこれは緊急用だろうか?
    |   何れにしても -1 は何らかのエラーがあった時用に見える。
    | - 或いは _rl_subseq_result の戻り値をそのまま返している箇所もある。
    | - r = RL_ISSTATE (RL_STATE_MULTIKEY) ? -3 : 0; で決めた物を
    |   返している箇所もある。-3 は今回関係なさそうなので無視する。
    |
    | _rl_subseq_result に関しては、
    | _rl_dispatch, _rl_dispatch_subseq の戻り値を返しているか、
    | 或いは ANYOTHERKEY なら -2 で失敗なら -1 を返している。
    |
    | 取り敢えず ANYOTHERKEY または timeout の時に -2 になる。
    | うーん。何故 ANYOTHERKEY を要求しているのだろうか。
    | というか ANYOTHERKEY が設定されるのはどういう時だろうか。
    |
    | うーん。調べてみると確かに ANYOTHERKEY が設定されている。
    | ANYOTHERKEY が設定されている理由は何だろうか。
    | もし常に設定されている物だとすれば
    | それをチェックする理由は何だろうか。
    |
    | 或いは ANYOTHERKEY の場所に
    | subseq 一致の時の binding を格納している?
    | 調べてみるとそれっぽい。ANYOTHERKEY の場所に入っているのは
    | bash_execute_unix_command だった。bind -s にしてみると、
    | また別の値が入っていた。
    |
    | OK。つまり ANYOTHERKEY を実行するというので良い。

    -2 が渡されるのは対応する binding が見つからなかった時で、
    然し ANYOTHERKEY に対応する binding が設定されている時である。
    ANYOTHERKEY には timeout の時の設定が格納されている。
    そして timeout の時には見つからなかったとして処理される。
    結果として部分一致の結果を実行するという動作になっている。

  * ここでどの様に修正したら良いだろうか。
    timeout の時には rl_executing_keyseq を短くする必要がある気がする。
    然し、そうでない場合には短くするのは変な気がする。
    例えば本当に対応するキーがなかったとしたら
    その時はそのキーを保持するべきなのでは。

    うーん。呼び出し元の ungetc と一緒に短くするべき?
    試してみたが何だか動作が分からない。

    | そもそも 3 文字の時に timeout にならない…。
    | 実装を見ると ANYOTHERKEY をチェックしているので
    | n-1 文字の設定がない限りは n 文字は timeout しないのだ。
    | これは元々特殊キーと ESC を区別する為の timeout と思えば、
    | 確かに中途半端なキー状態で timeout するのは変である。
    | これに関しては備考として残しておくことにする。

  ここで問題は timeout の時ばかりではない事が判明した。
  上に追記した。新しく来た文字に対応する binding がない時に。
  どの様に処理が進むのかという事を確認する必要がある。

    うーん。新しく来た文字に対応する binding がない時に
    どういう分岐をするのか。どうも ISFUNC が設定されている様だ。
    その上で func が 0 になっている。調べると #define ISFUNC 0 である。
    やはり初期状態は全て {ISFUNC, 0} が設定されているのだろう。

  ? cmd_xmap から bind を削除する時にカウントをチェックしている。
    ANYOTHERKEY はちゃんとカウントされているのだろうか。

    例えば tt と t に bind して t を unbind したらちゃんと削除される?
    更に tt と t に bind して tt を unbind したら t に対して
    ちゃんと timeout なしで反応するか?

2019-02-11

* report10: 取り敢えず mail を作成する事にする

  | 2016-11-09
  |
  | * そもそも keymap に登録されたコマンドを実行しているのはどこだろう。
  |
  |   色々探しまわってみると ISFUNC で関数を登録し、ISMACR でマクロ文字列を登録している様だ。
  |   lib/readline/bind.c の中を探しても呼び出している様な場所は見つからない。
  |   よく考えてみたらファイル名が bind である。つまり、ここには登録関係の関数しかない。
  |   検索で ISFUNC をしてみると readline に case ISFUNC: というものがある。
  |   其処に行ってみると取得した関数を実行している。_rl_dispatch_subseq という関数の中だ。
  |
  |   cmd_xmap を廃止してデータを同じキーマップにまとめて登録するのだとしたら、
  |   この辺りの呼び出し方を調べる必要がある。
  |   先ず、現在の設計だと登録されているエントリへのポインタを
  |   呼びだされた関数が直接取得するのは難しそうだ。
  |
  |   a readline 側のサポートが必要になる。しかし、cmd_xmap が readline 側ではなく
  |     bash 側で用意されていることなどから考えるに自由に関数を登録できるような仕組みはそもそも readline にはない。
  |     readline を拡張して cmd_xmap 埋め込みに対応できる様にするというのは readline の機能を大幅に拡張する事になり大げさである。
  |
  |   b 従ってやはり bash 側で何とかいい感じに誤魔化して実装する必要がある。
  |     例えば現在の kmap と key 等を取得することができれば bash 側で同様に map[key].function から同一の情報を得られる。
  |
  |     % しかし readline を見る限り _rl_dispatch_subseq で使われる map, key は動的に指定され外部から取得するのは難しいのではないかという気がする。
  |     % ちょっと調べてみた。大体の場合は map は _rl_dispatching_keymap に一致している様だ。
  |     % しかし _rl_dispatch_callback 経由で _rl_dispatch_subseq が呼び出される場合には予想できない。
  |     % やはり bash で独立に同じ kmap を取得するというのには難がある気がする。
  |     % それが理由で cmd_xmap という内部用の keymap を管理するという事になっているのであろう。
  |     %
  |     % また改めて bash の cmd_xmap の参照の部分を確認してみる。
  |     % rl_executing_keyseq というのを参照している。これは何処で公開される物だろうか。
  |     % こでは readline.c で定義され readline.c で管理されている。readline.h で公開されている。
  |     % この rl_executing_keyseq と一緒に現在の keymap も公開すれば良いのではないだろうか。
  |     % うーん。と思って改めて readline.c を見てみると rl_executing_keymap という物がある。
  |     % 何だこれはと思って調べてみると丁度正に rl_dispatch_subseq で map を外に公開する為に
  |     % rl_executing_keymap = map となっていた。つまり、_rl_dispatch_subseq で使われる
  |     % map および key は普通に外部に公開されていたという事である。
  |
  |     という訳で _rl_dispatch_subseq で使用された map 及び key は、
  |     rl_executing_keymap および rl_executing_key で取得することが可能である。
  |     つまり rl_executing_keymap[rl_executing_key].function とやれば良い。
  |
  |   しかし此処でやはり問題が…。ISMACR の場合には登録されている内容は free の対象であったが、
  |   ISFUNC の場合には登録されている内容は関数へのポインタであって free の対象ではない。
  |   (というか初め ISMACR で関数が登録されているのかと考えて、関数へのポインタへのポインタだと勘違いしていた。)
  |   という事は勝手に新しい情報を ISFUNC に紐付けて登録する事はできないという事になる。
  |
  |   或いは、keymap の entry に新しい項目を追加してしまうというのも手なのかもしれない。
  |   keymap は Keymap 型であり、Keymap 型は以下のように定義されている。
  |     typedef KEYMAP_ENTRY *Keymap;
  |   KEYMAP_ENTRY は struct _keymap_entry の typedef で、_keymap_entry は単純に
  |   char type と rl_command_func_t* function の二つのメンバを持つ。
  |
  |   うーん。この _keymap_entry を改造する位ならば ISMACR, ISFUNC に代わる
  |   type を作成する方が見通しが良い気がする。うーん。
  |   或いは、cmd_xmap に登録する時に keymap も鍵として使用して登録してしまう?
  |   しかし問題が二点ある。
  |
  |   1 keymap の同一性をどの様に判定するのか。
  |     単純にポインタで良いのか。
  |     もし realloc されるとポインタの値が変わってしまう事には注意しなければならない。
  |     keymap に対応する id 番号の様な物が存在すればそれが良いのであるが…。
  |
  |     readline の中を grep する限りは keymap は realloc していない様な気がする。
  |     もっとちゃんと調べる必要がある。cmd_xmap は rl_make_bare_keymap で生成している。
  |     rl_make_bare_keymap は readline/keymaps.c に定義が存在して、
  |     rl_make_keymap 及び rl_copy_keymap から使用されている。
  |     rl_make_bare_keymap の実装を見る限り keymap の長さは固定であるので realloc はない。
  |     また rl_make_keymap 及び rl_copy_keymap は現状では誰も使っていない様だ。
  |
  |     rl_make_bare_keymap を使っている箇所も特に見当たらない。cmd_xmap と、
  |     vi_mode.c の vi_replace_map だけだ。ではその他の keymap はどの様に確保されるのだろうか。
  |     様々の名前がついている keymap は何処なのかと思って探してみると、
  |     readline/bind.c の中に名前が定義されている。実体は各専用のファイルに定義されている様だ。
  |     例えば、"emacs", "emacs-standard" は emacs_standard_keymap という変数に紐付けられ、
  |     これは emacs_keymap.c で定義されている。そしてこれは何と静的な配列である。
  |     特にこれらの基本的な keymap に関して言うならばアドレスが変化するという事はなさそうだ。
  |
  |     では複数のキーに紐付いて設定される keymap に関してはどうだろうか。
  |     一旦削除されてから再度確保し直されるとしても、
  |     前の keymap から新しい keymap への引き継ぎが為されていないのであればそれを追跡する必要はない。
  |     偶たま同じアドレスになるとしてもその場合には
  |     本体の keymap の方に改めて登録するときに一緒に cmd_xmap の方にも登録するので、
  |     その時に上書きされるので変な衝突が起こるという事もないだろう。
  |
  |   2 keymap が消滅する時や unbind する時にどうやってエントリを削除するのか。
  |     しかし、よく考えて見ればこれは現在の実装でも問題になっている筈である。
  |     実装を見た感じ登録するコードは存在しても削除するコードが存在していない気がする。
  |
  |     試してみたところ一度登録した bind -X は二度と解除されない様だ。。
  |
  |     うーん。やはりこれに対応する為には bind/unbind の時に一緒に開放もしなければならず、
  |     その為には readline/bind.c を修正しなければならない。つまり、readline 側での特別な対応が必要である。
  |     もし ISFUNC において関数ポインタを格納する場所が動的に確保される領域であったならば、
  |     その動的確保される領域を勝手に拡張して後半に引数のデータを保持すれば良かった。
  |     しかし実際にはその様な実装にはなっていない様だ。
  |     代わりに ISMACR で格納する様にすれば追加のデータと関数ポインタを一緒に記録できるが、
  |     ISMACR は単にキーボードマクロとして処理されてしまうのでそのままでは使えない。
  |
  |   結局 readline を弄らないとまともな対応は不可能に思われる。
  |   readline を拡張するとすれば param 付きの関数を登録できる様にするという手がある。
  |   param は一個で良い。関数ポインタ単体の時に何が問題かというと動的な機能を登録できないという事である。
  |   つまり、関数ポインタは通常は静的な関数からしか取得できないので静的な機能にならざるを得ない。
  |
  |   要旨: bash_execute_unix_command の内部で元のエントリを取得する事は可能である。
  |   グローバル変数 rl_executing_keymap rl_executing_key を使えば良い。
  |   しかし一番問題になるのは登録されたデータの解放である。
  |   本体 keymap に対する unbind と共に行うのだとすればやはり readline を書き換えるのが易い。
  |   「readline 関数の呼び出し全てに介入して readline の処理を模倣して事前に cmd_xmap の更新を行う」
  |   という方法もできなくはないが結局 readline/bind.c を再実装しているだけに過ぎない気がする。
  |
  |   もう readline を拡張する方向で行くしかない気がする。
  |   しかしその前に C-@ の原因について調べて置かなければならない。
  |
  | ------------------------------------------------------------------------------
  |
  | * [bug] bind -x で登録された項目が内部的に残っている。
  |   更に bind -X で内部的に残っている項目まで全て出力される。
  |
  |   $ LANG=C ./bash --norc
  |   $ bind -X
  |   $ bind -x '"A": echo hello'
  |   $ bind -X
  |   "A": "echo hello"
  |   $ bind '"A": self-insert'
  |   $ bind -X
  |   "A": "echo hello"  # <-- overwritten keyseq is still remained
  |   $ exit
  |
  |   マクロの場合にはちゃんと消える。
  |
  |   $ LANG=C ./bash --norc
  |   $ bind -s
  |   $ bind '"A":"hello"'
  |   $ bind -s
  |   "A": "hello"
  |   $ bind '"A": self-insert'
  |   $ bind -s # <-- nothing output, the entry was successfully removed
  |   $ exit
  |
  | * [bug] cmd_xmap が keymap 間で共有されている。
  |   複数の異なる keymap に登録すると一方が他方を上書きする。
  |
  |   $ LANG=C bash-4.4 --norc
  |   $ bind -m emacs -x '"A":echo emacs'
  |   # ----- type A -----
  |   emacs
  |   $ bind -m vi -x '"A":echo vi'
  |   # ----- type A -----
  |   vi
  |   $ exit
  |
  |   $ LANG=C bash-4.4 --norc
  |   $ bind -m emacs '"A":"echo emacs"'
  |   # ----- type A -----
  |   $ echo emacs
  |   emacs
  |   $ bind -m vi '"A":"echo vi"'
  |   # ----- type A -----
  |   $ echo emacs
  |   emacs
  |   $ set -o vi
  |   # ----- type ESC A -----
  |   $ echo vi
  |   vi
  |   $ exit
  |
  |   $ LANG=C bash-4.4 --norc
  |   $ bind -m emacs -x '"A":echo emacs'
  |   # ----- type A -----
  |   emacs
  |   $ bind -m vi -x '"A":echo vi'
  |   # ----- type A -----
  |   vi
  |   $ set -o vi
  |   # ----- type A -----
  |   vi
  |   $ set -o emacs
  |   $ exit
  |
  | * [bug] cmd_xmap には bind 時の文字列が全体の keyseq として登録される。
  |   例えば emacs-ctlx には C-x に続いて何かを入力した時の動作を指定する事ができるが、
  |   これに対して bind -x しようとしても正しく登録する事ができない。
  |   (とはいいつつこれは単に bind -m emacs -x '"\C-x?": ...' とすれば期待通りにできるので回避可能である。)
  |
  |   $ LANG=C bash-4.4 --norc
  |   $ bind -m emacs -x '"A":echo hello'
  |   # ----- type A -----
  |   hello
  |   $ bind -m emacs-ctlx -x '"A":echo world'
  |   # ----- type C-x A -----
  |   bash-4.4: bash_execute_unix_command: cannot find keymap for command
  |   # ----- type A -----
  |   world
  |   $
  |   $ exit
  |
  |   マクロの場合にはちゃんとできる。
  |
  |   $ LANG=C ./bash --norc
  |   $ bind -m emacs-ctlx '"A":"hello world"'
  |   $ exit

* report9: convert-meta と unmeta について

  まとめ始めたが何だか分からなくなった。
  というか unmeta を if の中に入れるだけでは治らない。
  cmd_xmap と現在の kmap で map[ESC].type == ISKMAP の
  状態が異なる為に不一致が起こっている。

  _rl_convert_meta_chars_to_ascii を参照している箇所を確認して、
  全体としての一貫性がどうなっているのかを改めて確認する必要がある。

  bind.c:144: rl_bind_key に関しては、そもそも meta char を受け取って、
  現在の kmap[ESC] が存在していない場合には "out of range" の扱いだそうだ。

  bind.c:400: rl_generic_bind については、
  そもそも keys, keys_len を翻訳する時に工夫すれば良いのでは?

    →rl_translate_keyseq を修正したので変更不要の気がするが、
    使わないコードを残しておく理由もないので削除する。

  bind.c:523: rl_translate_keyseq は \M- の形式だけ \e に変換している。
  他の場所で meta chars を分解するぐらいであればそもそもこの場所で
  \e に分けて置いた方が良いのではないだろうか。

    →強制的に ESC と UNMETA (c) に分ける様に書き換えた。
    実装を見てみても最大バッファ長さは strlen(str)*2 + 1 で変わらないと思う。

  bind.c:799: _rl_function_of_keyseq_internal は書き換えかけたが…
  よく考えたらこれは読み取りのコードなのでこのままで良い気がする。
  書きかけて削除したコードは以下に残しておく。

    | char* keys;
    | int keys_len;
    |
    | keys = keyseq;
    | keys_len = len;
    |
    | if (_rl_convert_meta_chars_to_ascii)
    |   {
    |     keys = (char *)xmalloc(len * 2 + 1);
    |     keys_len = 0;
    |     for (i = 0; keyseq && i < len; i++)
    |       {
    |         unsigned char ic = keyseq[i];
    |         if (META_CHAR (ic))
    |           {
    |             keys[keys_len++] = ESC;
    |             keys[keys_len++] = UNMETA (ic);
    |           }
    |         else
    |           keys[keys_len++] = ic;
    |       }
    |     keys[keys_len] = '\0';
    |   }

  bind.c:2588: rl_invoking_keyseqs_in_map
  これは正直 \M-? と出力しようが \e? と出力しようがどちらでも良い。
  \e が kmap に存在するかどうかで動作を分けるのも妙な気がするが。
  と思ったが、この構造を追うと map[ESC].type == ISKMAP は恒真ではないか。なので気にしない。

    | for (key = 0; key < KEYMAP_SIZE; key++)
    |   {
    |     switch (map[key].type)
    |       case ISKMAP:
    |         {
    |           for (i = 0; seqs[i]; i++)
    |             {
    |               if (key == ESC)
    |                   if (_rl_convert_meta_chars_to_ascii && map[ESC].type == ISKMAP)
    |                     sprintf (keyname, "\\M-");
    |                   else
    |                     sprintf (keyname, "\\e");

  readline.c:817: _rl_dispatch_subseq
  うーん。これは一体何をやっているか分からない。meta char が指定された時は、
  map に ESC がなければ rl_ding というのを実行している。
  これは実装を確認すると単にベルを鳴らすだけの話である。
  これは受け取った文字を使って kmap を辿る操作である。
  meta char は ESC と UNMETA (c) に分解して辿る。
  これはこのままで問題ない。

  取り敢えず patch を作った。

* report7: 序でなのでこれも報告する事にする。
  ref ble.sh/memo.txt#D0920

* report8: 改めてバグ報告をする事にする。
  ref ble.sh/memo.txt#D0918
  簡単なバグなのですぐ送ってしまう事にする。

2018-05-03

* report6: 月を跨いだので現在分かっている最後のバグについて patch を送る事にする。
  このバグについてのメモは何処かにあるはずだと思ったが、
  確認してみると何処にも見つからない。
  仕方がないので改めて際限コードを作成する事にする。

  $ bash-4.4 --norc
  $ f1() { bind -x '"\C-t": f1'; }; f1
  bash-4.4: $'\317\003': command not found

2018-03-23

* READLINE_POINT が bytes 単位である事について。

  これは ble.sh の方にメモがあるかと思ったら何もなかった。そういう仕様だという前提で書かれたのであろう。
  READLINE_POINT が bytes 単位である事を認識して書いているコードはどれぐらいあるだろうか。

  | 正しく実装する一つの方法は LC_CTYPE を設定してから文字列の長さを測るという物である。
  | [Search](https://github.com/search?utf8=%E2%9C%93&amp;q=LC_CTYPE+READLINE_POINT+NOT+LC_MESSAGES+NOT+rl_line_buffer&amp;type=Code)
  | →[dot/kingbash.script](https://github.com/billinux/dot/blob/986cc0b8df950687ff0b50aced6df5a755a9b9d3/bin/kingbash.script)
  |
  | もう一つの方法は LC_ALL を設定するという物。
  | [Search](https://github.com/search?q=LC_ALL+READLINE_POINT+NOT+LC_MESSAGES+NOT+rl_line_buffer+NOT+READLINE_LINE_BUFFER&amp;type=Code&amp;utf8=%E2%9C%93)
  |
  | 或いは wc -c でも数えられるかもしれない。
  | [Search](https://github.com/search?utf8=%E2%9C%93&amp;q=wc+%22READLINE_POINT%3D%22+NOT+LC_MESSAGES+NOT+rl_line_buffer+NOT+READLINE_LINE_BUFFER&amp;type=Code)

  他の検索

  | [Stack Overflow](https://stackoverflow.com/search?q=%22READLINE_POINT%22)

  結局、どうやら kingbash.script で対策されているだけで他には使われていない様である。
  [Bash/関数 - ArchWiki](https://wiki.archlinux.jp/index.php/Bash/%E9%96%A2%E6%95%B0)
  によると KingBash はメニュー補間を実現するスクリプト (2008) の様である。

  kingbash.script の場合には単に文字列末端にカーソルを移動するだけである (要確認)。
  LC_ALL=C LC_CTYPE=C で過大評価になるだけなので結局文字列末端に移動することは変わらない。

  とにかく初めに READLINE_POINT の修正案を提示する事が先である。
  先ず文字列の長さを数える方法について確認する。
  或いはパラメータ展開の offset, length をどの様に処理しているか。

  subst.c:4411: mb_getcharlens (string, len)
  subst.c:7639: mb_substring (string, s, e)
  lib/readline/mbutil.c:363: _rl_find_next_mbchar (char *string, int seed, int count, int flags)

  文字数からバイト位置に変換するのは _rl_find_next_mbchar で良さそうだ。flags = 0
  mb_getcharlens は調べてみると何処からも使われない。
  というか ifdef INCLUDE_UNUSED の中にあるというのはそういう事の様だ。
  他に類似の機能はないだろうか。というか ${#var} の場合に何れにしても数える必要があるので、
  何処かでその機能は存在しているはずである。

  subst.c:6967: parameter_brace_expand_length (name) の中の
	subst.c:7021:           number = MB_STRLEN (t); である。

  MB_STRLEN は incloude/shmbutil.h で定義されている。

  $ rl-insert () { READLINE_LINE=${READLINE_LINE::READLINE_POINT}$1${READLINE_LINE:READLINE_POINT}; ((READLINE_POINT+=${#1})); }
  $ bind -x '"\C-t": rl-insert AA'
  $ echo あ|いうえお

  ここで C-t を押してみるとあらぬ所に挿入される。更に続けて文字を入力すると文字が壊れる。

2018-03-21

* 改めて C-@ の問題について patch を送る事にした。

  関連して他の問題もある。`rl_bind_keyseq_if_unbound_in_map' 287 lib/readline/bind.c で、
  引数 keyseq を rl_function_of_keyseq と rl_bind_keyseq_in_map に渡している。
  rl_function_of_keyseq は translated sequences を受け取る関数である。
  rl_bind_keyseq_in_map は untranslated sequences を受け取る関数である。

  rl_function_of_keyseq が translated sequences を受け取る関数であることの根拠

    o 実装がその様になっている (長さを受け取らないので欠陥であるが)。
    o bash_execute_unix_command で translated sequences を渡している。
    - initialize_readline (bashline.c) で null-terminated sequences を渡している…が、
      これは何とも言えない。

  rl_bind_keyseq_in_map が untranslated sequences を受け取る関数であることの根拠

    o 中で rl_translate_keyseq を呼び出している。
    o bind_keyseq_to_unix_command で bind -x '"...": ...' の最初の ... の部分を
      rl_bind_keyseq_in_map に渡している。

  rl_bind_keyseq_if_unbound_in_map が untranslated sequences であるべき理由

    o 長さを受け取っていないので、translated だと問題が起こる。
    - rl_bind_key_if_unbound_in_map から null-terminated で呼び出している。
    - rl_bind_key_if_unbound から null-terminated で呼び出している。
    - rl_bind_keyseq_if_unbound は等価な関数
    x bind_termcap_arrow_keys で使われている rl_bind_keyseq_if_unbound は
      translated sequences でなければならない。
      →これは keys, key_len 引数を受け取る様にしなければならない。
      もしこれに対応するとすると、
      - rl_bind_keyseq_if_unbound_in_map
      - rl_bind_keyseq_in_map
      - rl_generic_bind
      それぞれに対して keys, key_len を受け取る版を作成しなければならない。x

  ToDo:
    rl_bind_key_if_unbound_in_map: untranslate
    rl_bind_key_if_unbound       : untranslate

  以下は昔書きかけた bug report

  | From: murase
  | To: bug-bash@gnu.org
  | Subject: [50 character or so descriptive subject here (for reference)]
  |
  | Configuration Information [Automatically generated, do not change]:
  | Machine: i686
  | OS: linux-gnu
  | Compiler: gcc
  | Compilation CFLAGS:  -DPROGRAM='bash' -DCONF_HOSTTYPE='i686' -DCONF_OSTYPE='linux-gnu' -DCONF_MACHTYPE='i686-pc-linux-gnu' -DCONF_VENDOR='pc' -DLOCALEDIR='/home/murase/opt/bash-4.4/share/l\
  | ocale' -DPACKAGE='bash' -DSHELL -DHAVE_CONFIG_H   -I.  -I. -I./include -I./lib   -O2 -march=native -Wno-parentheses -Wno-format-security
  | uname output: Linux padparadscha 4.7.2-101.fc23.i686 #1 SMP Fri Aug 26 16:39:46 UTC 2016 i686 i686 i386 GNU/Linux
  | Machine Type: i686-pc-linux-gnu
  |
  | Bash Version: 4.4
  | Patch Level: 0
  | Release Status: release
  |
  | Description:
  |   [Detailed description of the problem, suggestion, or complaint.]
  |
  | Repeat-By:
  |
  |   $ LANG=C bash-4.4 --norc
  |   $ bind -x '"\C-@":echo hello'
  |   $
  |   # ----- type C-@ or C-space -----
  |   bash-4.4: bash_execute_unix_command: cannot find keymap for command
  |   $ bind -x '"\C-A":echo hello'
  |   # ----- type C-a -----
  |   hello # expected result for C-a
  |   $ exit
  |   $ LANG=C bash-4.3 --norc
  |   $ bind -x '"\C-@":echo hello'
  |   $
  |   # ----- type C-@ or C-space in the terminal -----
  |   bash-4.3: bash_execute_unix_command: cannot find keymap for command
  |   $ exit
  |   $ LANG=C bash-4.2 --norc
  |   $ bind -x '"\C-@":echo hello'
  |   # ----- type C-@ or C-space -----
  |   hello
  |   $ exit
  |
  | Fix:
  |   [Description of how to fix the problem.  If you don't know a
  |   fix for the problem, don't include this section.]

  以下はこれについての古い項目

  | 2016-11-09 C-@ に bind -x すると実行に失敗する原因は分かった。
  |
  | | 先ず bind -X するとちゃんと登録されている。
  | | よく分からないので登録時・読み取り時の kseq 変数の中身を printf で見てみる。
  | | どうやら登録時は bind に指定した引数 (の部分文字列) をそのまま渡している様だ。
  | | そして読み取り時は入力したキーの列がそのまま渡されている。
  | | これだと登録時と読み取り時で異なるシーケンスになるのが普通だがこれで良いのか?
  | | 試しに C-a で試してみると両者が異なっていてもちゃんと機能する様だ。
  | | というか、登録時の kseq と読み取り時の kseq は意味合いが異なるのだろう。
  | |
  | | と、ここで読み取り時に実際に入力したキーの列が格納されているのはヌル終端文字列である。
  | | ヌル終端文字列に C-@ を含ませる事は不可能である。
  | | これだと長さ 0 になってしまうのではないだろうか。
  | | そしてこの推測が正しければ、そもそも C-@ を一文字でも含む様なキーシーケンスは全然登録できない。
  | | 試してみることにする。
  | |
  | | C-@A で試してみた所やはり同様に
  | |   bash: bash_execute_unix_command: cannot find keymap for command
  | | のエラーが発生する様だ。(C-@ set-mark が残っているので、
  | | 素早く入力しないと set-mark の方が呼び出されてしまう事に注意する。
  | | # というか C-@ を解除する方法はないのだろうか…と思ったら普通に bind -r で良かった。
  |
  | [まとめ]
  |
  | cmd_xmap から読み出す時に rl_executing_keyseq (ヌル終端文字列) を使っているが、
  | そこに C-@ が含まれていると其処で文字列が終端していると見なされて読み出せない。
  |
  | さてではどの様に修正したら良いであろうか。
  | ヌル終端文字列を受け取る関数 rl_function_of_keyseq を見るといろいろな箇所で用いられている。
  | 何故これが問題にならないのであろう。。というかこの関数は本当にヌル終端文字列を受け取る関数なのか?
  | → bind -x '"\\\\": echo double bslash' として \ \ と入力したら rl_function_of_keyseq に "\\" が渡され、
  | 結果として正しく echo double bslash が実行された。つまり rl_function_of_keyseq は "\\" をちゃんと二文字の \ と認識している。
  | 勝手にエスケープされた一文字の \ という様に誤解釈したりはしない様だ。つまり、
  | rl_function_of_keyseq は本当にヌル終端文字列を受け取るという事である。
  |
  | ここで、その他の rl_function_of_keyseq で問題が生じないのかどうかを調べる必要がある。
  | 先ず rl_function_of_keyseq の実装を念のため確認する。やはり常に生のヌル終端文字列として取り扱っている。
  | 今度は呼び出し元について調べる。
  | - called by rl_bind_keyseq_if_unbound_in_map:
  |   % readline 内部での呼び出しは rl_bind_keyseq_if_unbound_in_map (bind.c) の引数をそのまま渡すもののみである。
  |   % rl_bind_keyseq_if_unbound_in_map は readline 内部 (bind.c) のみで使用されている。
  |   % - called by rl_bind_key_if_unbound_in_map:
  |   %   key から keyseq を作って渡している。
  |   %   rl_bind_key_if_unbound_in_map は initialize_readline (bashline.c) 内部でハードコートされた引数について呼び出されている。
  |   %   たまたまハードコートされたキーについては C-@ が含まれていないので問題が起こっていないという事だ。
  |   %   他の箇所では使われていない。従ってこれについては問題は生じない。
  |   % - called by rl_bind_key_if_unbound:
  |   %   この関数は誰も使っていない。
  |   %   また、中身は単に rl_bind_key_if_unbound_in_map(key, default_func, _rl_keymap) に置き換えられる。
  |   % - called by rl_bind_keyseq_if_unbound:
  |   %   rl_bind_keyseq_if_unbound_in_map(keyseq, default_func, _rl_keymap) であり、
  |   %   実際に使われている箇所はハードコートされた物と terminfo から読み取った制御シーケンスである。
  |   %   制御シーケンスには NUL は含まれない (ANSI規格に従えば)。従ってこれも問題は起こらない。
  |   これはよく見てみれば別のバグで rl_function_of_keyseq に keys を渡す時に翻訳を忘れているだけだった。
  |   その修正さえすれば何の問題もない。
  | - called by bashline.c (initialize_readline):
  |   四ヶ所から呼び出されているが全部ハードコードされた物であり NUL は含まれていない。
  | - called by bashline.c (bash_execute_unix_command):
  |   これは今問題になっている関数である。
  |
  | 結局今回問題になっている物以外は全てハードコードされた物であって (たまたま) 何も問題が生じていないという事の様だ。
  | さて rl_function_of_keyseq を拡張して長さを指定できる様にするとしたらどの様にするか。
  | 長さを取得する方法が必要である。
  | 調べると rl_key_sequence_length という変数に長さが入っている様だ。
  | 似た変数名として rl_executing_keyseq_size という物があるが、
  | これは buffer のサイズを保持しているのであって長さを保持している訳ではない事に注意する。
  | extern int rl_key_sequence_length は readline.h で公開されている。
  | という訳で
  |
  | さて似たような事が他で問題にならないのかというのは不思議である。
  | - rl_untranslate_keyseq この関数名は怪しいと思って確認した見たが、
  |   keyseq といいつつこれは1文字を文字列に変換するだけの関数である。
  | - というかそもそも keymap は終端をどの様に検知しているのだろう?
  |   うーん。というかそもそも kseq を保持する様な実装にはなっていなくて、
  |   keymap の chain を辿っていく仕組みになっていて、唯一長さを意識するのは bind 時であったが、
  |   これは ASCII rep で渡しているから問題ないということなのか。しかしそれでも rl_translate_keyseq に渡すから、
  |   問題になるのじゃないかと思ったが…rl_translate_keyseq はちゃんと int* len という引数に結果を格納する。
  | ★rl_bind_keyseq_if_unbound_in_map この関数は引数 keyseq の使い方が怪しい。
  |   keyseq を rl_function_of_keyseq と rl_bind_keyseq_in_map にそのまま渡している。
  |   rl_function_of_keyseq は keyseq を直接表現として取り扱う。
  |   rl_bind_keyseq_in_map は keyseq をASCII表現として取り扱う。
  |   ドキュメントによると keyseq は ASCII 表現でなければならない気がする。
  |   つまり変換が必要である。
