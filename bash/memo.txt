

------------------------------------------------------------------------------
  Memo
------------------------------------------------------------------------------

2020-05-15

* ${ list; } に対応するには何処をどうすれば良いのか。
  Chet が patch があれば受け入れると言っている。
  気になる。然しすでに何日か経ってしまったし、mmap を使った実装などを要求されると大変である。
  というより一時ファイルを作成して其処に出力させるなど面倒が多い気がする。

  最初は文法を見ていたがどうも ${...} の中は括弧の対応だけとってその場では解釈しない様子だ。
  実際に ${} を処理しているのは subst.c:8743 parameter_brace_expand である。
  その場で中の構造を決定して実行している様に見える。この関数を弄れば良いという事だろうか。

  * ${ の直後にどの文字が来たら ${ list;} と解釈するか。

    空白の場合にだけ特別な処理をするのか、
    或いは { ...; } と同様に単語の区切りとなる文字
    ($IFS, <>, |&;, ()) を要求するか。

    - ${} の中身を独立した行にしたい場合や ${< file} という記述をした
      いという事を考えると、単語区切りの文字を要求したい気がする。

    - "(" に関しては zsh の parameter expansion の flags と被る。これ
      に対応してしまうと将来的に zsh と同様の展開をサポートしたい時に
      困る。既に Bash には ${var@ops} もあるがこれは他の ${a##pat} 等
      と組み合わせる事ができない。また、zsh ユーザに対して混乱をきたす
      可能性がある。

    - "|&;)" に関しては明らかに文法の誤りである。因みに ksh の場合には
      & で始まる文法が存在する。

    - ksh の振る舞いを確認すると 空白以外にも <> や () を特別扱いして
      いる様に見える。|;& も同様の気がするが実際には良くわからない。

    選択肢は三種類ある。(1) $IFS のみ (2) $IFS 及び <> のみ (3) 全ての
    単語区切り空白のみというのはやはり変なので $IFS は対応するべきであ
    る。(2) 位なら未だOK。(3) は文法的に明らかに許容できない物も含むが
    言語の設計としては自然。ksh は (3) の様な気がする。取り敢えず
    " \t\n<>" もしくは " \t\n<>|&;()" だろう。

  コマンド置換は subst.c:9716 において extract_command_subst を呼び出して範囲を切り出し、
  subst.c:9778 において command_substitute を呼び出して実行している。中では色々関数を呼び出している。
  これらは ${ ... } の切り出しには使えないだろう。それよりは寧ろ、${ ... } の関数を使う方が自然。
  然し、${ ... } は SX_POSIXEXP | SX_WORD なのか SX_WORD なのか。というより、SX_POSIXEXP は何だろう。

  * parse.y はやはり修正する必要がある。${} の解析は {} の入れ子を数えずに、
    単に } が現れた所で終了する様になっている。つまり、
    echo ${a##{} }xxx は echo "${a##{}" "}xxx" と解釈されるし、
    echo ${ echo {} } は echo "${ echo {}" "}" と解釈される。

  * 更に単に {} の入れ子だけ数えれば良いという訳ではない。
    } が単独文字の単語を為しているかどうかを判定する必要がある。
    その様に色々と考えて行くと {} による切り出しというのは新しい関数を書く必要が出てくる。
    一方で ksh の実装を見ると結構いい加減の気もする。} の前に
    くっついて来る単語があるかないかだけ判定すれば良い?

    其処まで行くのであれば実は ;()&| の直後の } という様にしてしまっても良い?
    然し、$()} というパターンを考えると ) の直後というのは駄目。
    ${ echo hello; } ${ type cmd; } vs ${ type cmd } うーん。
    やはり、[;&|\n][ \t]+\} が現れる迄を読み取る?
    time } だとか a=1 } だとかはどう取り扱うべきか。

    a=1 } に関しては } は通常のコマンド名として解釈される様だ。
    time } に関しては構文エラーになる。time 改行 } に関しては大丈夫。
    他に 行頭以外に } が来る状況は在るだろうか。例えば < file } は試したらエラーだった。
    | } とした場合でもエラーになる。その他 case 関連の ;; ;;& ;& や
    && や || もその次に } が来ることはない。
    色々考え合わせるにやはり /[;&\n][ \t]+\}/ 的な判定で良い気がする。
    然し、実際のところそんな実装で良いのかという問題も在る。

    {} の入れ子を実装する為には実は { も数える必要がある。
    色々考えるとやはり parse.y のレベルで { ... } を解析する仕組みがある筈。
    そうでないと関数定義の切り出しも難しくなってしまう。
    実際に調べてみると function_body : shell_command,
    shell_command: group_command, group_command: '{' compond_list '}' となっている。
    更によく見てみると $() も ${} も parse.y では解析していない。

* man ksh を見ると ksh には未だ未だ色々な機能がある事が分かる。
  色々便利そうな拡張があるが現実にこれらを利用するスクリプトは存在するのだろうか。

  * namespace varname { list ;} ... 変数の名前空間
  * & name args...; list &      ... ジョブプール名を指定してコマンドを実行
  * ${ ... }                    ... 同じプロセス内のコマンド置換。
  * $(1<#)                      ... ftell(fd) の結果に置換される。
  * ${arr[1][2]} 配列の配列 etc.
  * ${$param} ... 間接参照 (Bash ${!param} に同じ) (Zsh とは意味が異なる)
  * ${@vname} ... 属性 (Bash ${vname@a} に同じだろうか)
  * ${!vname} ... nameref の参照先変数名 (Bash と意味が異なる)

  extglob
  * {n}(...), {n,m}() ... 繰り返し。
  * %({}Q"E\)         ... 入れ子括弧の読み取り。
  * ~(options:...)    ... オプション。

  算術式
  * 浮動小数点が使える。数学関数も使える。数学定数が用意されている。
    ユーザ定義の関数も指定できる。ユーザ定義関数では配列参照も引数に指定できる。

  リダイレクション
  * >; word <>; word ... 一時ファイルに出力してコマンドが成功してから word に改名
  * <#((expr)) >#((expr)) ... fseek
  * <#pattern <##pattern  ... 行検索 (## の時はスキップした行は標準出力へ)

  * 関数: func() 形式の場合はスコープを作らない。function func 形式の場合は作る。
  * 変数: get/set/append/unset 等の操作を定義できる。

  * set -sK COLS arr             ... 配列のソート
  * test -R                      ... nameref かどうかのテスト
  * . funcname                   ... 同じスコープで関数を実行
  * enum name=(value1 value2...) ... 新しい列挙型を作成する。

2020-04-15

* tempenv が絡んだ時の unset の振る舞いが変だ。
  以下は unset の状態になると期待するが実際には global が見えてしまう。
  Bash-4.2 までは期待通りの動作だが、Bash-4.3 以降でこうなってしまっている。

  f1() {
    local v=local
    unset -v v
    echo "v=${v- (unset)}"
  }
  v=global
  v=tempenv f1

  そもそも何処でこの処理をしているのかについて確認する。
  先ず初めに builtins/set.def (builtin_unset) が呼び出される。
  そして variables.c (unbind_variable(name)) が呼び出される。
  其処から variables.c (makunbound(name, variable_context)) が呼び出される。
  この関数の中で localvar_unset 等の判定が行われている。
  variable_context と比較して一致するかどうかを判定している。

  うーん。ここで別の文脈という事になってしまっているという事だろうか。
  然し、不思議なのは local builtin で variable_context に値が設定される訳ではないという事。

  * 取り敢えず本当にここで違う物が得られているのかという事を確認するのが最初。
    と思って実際に試してみた所、ちゃんと両者は一致していて 1 になっている。
    此処で確認しておいてよかった。もうすぐで variable_context が何処で設定されているか
    調べ始めてしまうところであった。だとするともっと別の場所で判定が行われている。
  * 別の条件 local_p によってスキップしているのだろうかと思ったがそうでもなかった。
  * 更に nofree_p が設定されていない事によって勝手に削除されてしまうのだろうか、
    と思ったが確認してみた所、普通のローカル変数でも tmpenv でも nofree_p は 0 だった。
  * 駄目だ FREE する所まで振る舞いが一致している。という事はまた別の場所で何か処理が行われている?
    試しに dynamic unset の時の path で出力する様にして見たが、
    其処は通過していない様だ。という事は何か別の経路で変数が削除されてしまっている。
  * 因みに tempvar_p についてはちゃんと有効になっている。
    或いは export 属性がついていると変数が即座に削除されてしまう等の事があるのだろうか。
    もしくは tempvar が export 属性を持っていない場合には無視されてしまうというバグがあるのか。

  とここで気づいてしまったのだが bash-dev では直っている。
  突き止めた。f65f3d54 で修正されている。以下の ChangeLog がこれに対応する物だ。

  |             2/6
  |             ---
  | variables.c
  |   - make_local_variable: make sure local variables that have the same
  |     names as variables found in the temporary environment are marked as
  |     local. From Grisha Levit <grishalevit@gmail.com> back in 12/2018


2020-03-21

* "local -p" で flags が出力されない。
  local の man を見ると declare のオプションは全て使えると書いてある。
  (使えるとは書いてあるが振る舞いが同じとは書かれていないが…。
  然し、何も書いていないという事であれば同様に振る舞うと期待するのが自然である。)

* "local -p var" / "readonly -p var" で何も出力されない。
  manual を見ても何とも言えない。自然に考えたら対応していても良さそうなのに。
  "export -p var" に関しては manual にも書いていない。
  というより "export var" と同じ効果になっているが、これはおかしいのでは。

* "declare -p dict" で余分な空白が出力される
  declare -A dict=([1]=2 )

* "declare -p a=b" では "a=b" という名前の変数を探索するが、
  "declare -p a=(1 2 3)" では a=(1 2 3) を実行した上で
  更に declare -p a を実行するという振る舞いになる。

* "echo 6>&5-" とすると、閉じたままになっている。

2019-12-18

* Bash 仕様: n key目の timeout は n-1 key目がある時にのみ起こる。

  これは元々 keymap-timeout の機能自体が vi モードで ESC と
  矢印キーを区別するための物だからであろう。
  ESC [ まで受信してその次が暫く来なかった時に、
  CSI シーケンスが終了するのを待つ方が自然である。
  従って timeout して "ESC" + "[" に分解される事はない。

  然し、ユーザが abc と a に対して束縛している時に
  ab まで入力して止まった時に幾ら待っても動かないという事になる。
  この状況でどう振る舞うのが良いのかというのについては非自明である。

2019-02-11

* バグ報告の仕方

  git format-patch devel 等とする。


------------------------------------------------------------------------------
  Bugs
------------------------------------------------------------------------------

2019-12-17

* shadow がそのままになってしまう。
  というかこれについては既にコメントが書かれている。

  $ bind '"\C-t\C-t\C-t\C-t":"hello"'
  $ bind -x '"\C-t":echo world'
  $ bind -r '\C-t\C-t\C-t\C-t'
  $ #<-- <C-t> 500ms 後に world が表示される

  ■これは保留

2016-11-09

* sv_isrchterm

  - さて rl_translate_keyseq を使っている箇所を見てみたが、折角 len で長さを受け取っても
    結局それを null-terminated string に変換している。これだと意味ないのではないか。
    例えば sv_isrchterm という関数で _rl_isearch_terminators の更新を行っている。

  ★isearch-terminator に C-@ を指定しても使えない気がする。
  ★emacs-mode-string, vi-cmd-mode-string, vi-ins-mode-string にも似たような問題がある気がするが、
    これは単に出力するだけなので NUL がある場合に其処で途切れていても問題は生じない。


-------------------------------------------------------------------------------
  Done
-------------------------------------------------------------------------------

* 2021-02-06 report21: read -t がブロックしてしまう [#D0021]

  取り敢えず以下の構成で高確率で timeout に失敗するのが見られる。

  | #!/bin/bash
  |
  | rm -f a.pipe
  | mkfifo a.pipe
  | exec 9<> a.pipe
  | rm -f a.pipe
  | for c in {0..2000}; do
  |   (eval "echo {0..$c}" & read -u 9 -t 0.001) >/dev/null
  |   printf $'\r\e[Kok %d' "$c"
  | done
  | echo


  色々なシステムで計測してみたが少なくとも Linux, FreeBSD, Cygwin で確率的に再
  現している。Minix では再現しなかったがこれは偶々だろう。起こる頻度はシステム
  にも依存するし、bash version にも依存するし、コンパイル時の relstatus にも依
  存する。timeout の時間の長さにも依存するし、直前のプロセスが吐く標準出力の量
  にも依存する。状況に応じて特定の標準出力の量の時に起こりやすいなどの事がある
  様だ。

  | chatoyancy
  |   MACHTYPE: x86_64-unknown-linux-gnu (Fedora release 30 (Thirty))
  |   CPU: Intel(R) Core(TM) i7-7700 CPU @ 3.60GHz
  |
  |   * OK - GNU bash, 4.0.44(2)-release (x86_64-unknown-linux-gnu)
  |   * OK - GNU bash, 4.1.17(2)-release (x86_64-unknown-linux-gnu)
  |   * OK - GNU bash, 4.2.53(2)-release (x86_64-unknown-linux-gnu)
  |   * Fail - GNU bash, 4.3.48(1)-release (x86_64-unknown-linux-gnu)
  |   * Fail - GNU bash, 4.4.23(1)-release (x86_64-unknown-linux-gnu)
  |   * Fail - GNU bash, 5.0.18(1)-release (x86_64-pc-linux-gnu)
  |   * Fail - GNU bash, 5.0.7(1)-release (x86_64-pc-linux-gnu)
  |   * Fail - GNU bash, 5.0.16(1)-release (x86_64-pc-linux-gnu)
  |   * Fail - GNU bash, 5.0.18(1)-release (x86_64-pc-linux-gnu)
  |   * Fail - GNU bash, 5.1.0(1)-alpha (x86_64-pc-linux-gnu)
  |   * Fail - GNU bash, 5.1.0(1)-release (x86_64-pc-linux-gnu)
  |   * Fail - GNU bash, 5.1.4(2)-maint (x86_64-pc-linux-gnu) (Current devel fcad1d1)
  |
  | hp2019
  |   CPU: Intel(R) Core(TM) i5-8500 CPU @ 3.00GHz
  |   MACHTYPE: x86_64-unknown-linux-gnu (Fedora release 30 (Thirty))
  |
  |   * OK - GNU bash, 4.0.44(2)-release (x86_64-unknown-linux-gnu)
  |   * OK - GNU bash, 4.1.17(2)-release (x86_64-unknown-linux-gnu)
  |   * OK - GNU bash, 4.2.53(2)-release (x86_64-unknown-linux-gnu)
  |   * Fail - GNU bash, 4.3.48(1)-release (x86_64-unknown-linux-gnu)
  |   * Fail - GNU bash, 4.4.23(1)-release (x86_64-unknown-linux-gnu)
  |   * Fail - GNU bash, 5.0.7(1)-release (x86_64-redhat-linux-gnu)
  |   * Fail - GNU bash, 5.0.18(1)-release (x86_64-pc-linux-gnu)
  |   * Fail - GNU bash, 5.1.0(1)-release (x86_64-pc-linux-gnu)
  |
  | letsnote2019
  |   CPU: Intel(R) Core(TM) i5-7200U CPU @ 2.50GHz
  |   MACHTYPE: x86_64-unknown-cygwin (Cygwin)
  |
  |   * Fail - GNU bash, 4.4.12(3)-release (x86_64-unknown-cygwin)
  |
  |   MACHTYPE: x86_64-pc-linux-gnu (Arch Linux on VirtualBox)
  |
  |   * Fail - GNU bash, 5.1.4(1)-release (x86_64-pc-linux-gnu)
  |
  |   MACHTYPE: i386-portbld-freebsd12.0 (FreeBSD 12.0)
  |
  |   * Fail - GNU bash, 5.0.11(0)-release (i386-portbld-freebsd12.0)
  |
  |   MACHTYPE: i386-elf32-minix (Minix)
  |   Note: exec 9< <(sleep 60)
  |
  |   * OK - GNU bash, 4.3.0(1)-release (i386-elf32-minix)
  |
  |   MACHTYPE: i386-pc-solaris2.11 (Solaris)
  |
  |   * OK - GNU bash, 4.1.17(1)-release (i386-pc-solaris2.11)
  |
  | ln26
  |   MACHTYPE: x86_64-redhat-linux-gnu (CentOS Linux release 7.8.2003 (Core))
  |   CPU: Intel(R) Xeon(R) CPU E5-2678 v3 @ 2.50GHz
  |
  |   * OK - GNU bash, 4.2.46(2)-release (x86_64-redhat-linux-gnu)
  |   * Fail - GNU bash, 5.0.18(1)-release (x86_64-pc-linux-gnu)

  然し、再現条件がかなり特殊であることから単純にコードを見ても解決しないだろう
  という気がする。取り敢えず bisect をしかける事にしようか。bisect の使い方に浮
  いて先ずは調べる必要がある。

  | 10e784337238e6081ca5f9bdc8c21492f7b89388 is the first bad commit
  | commit 10e784337238e6081ca5f9bdc8c21492f7b89388
  | Author: Chet Ramey <chet@caleb.ins.cwru.edu>
  | Date:   Mon Mar 4 08:10:00 2013 -0500
  |
  |     commit bash-20130208 snapshot
  |
  | :100644 100644 8b579a4a679d56ebc1d7883764712356a4783295 33f721be4ad8a667c9c61114997ee5c8814380de M      CHANGES-4.3
  | :040000 040000 7835bcfa78a2e08722ed510cac2a5c21821808a8 96f9df818407352b01ed77f34139ef2d5af20f35 M      CWRU
  | :040000 040000 b9ba7671f57a49ffc7bca6820f7bd3af95fd3ed0 63edacf96a6b00e7af7de94cfecae953621f3cc3 M      autom4te.cache
  | :040000 040000 3ad1df80fbada3bf4f5ca1cd22b407fb22b4c4ab c2cc5e9932a325c450fa6c199daa324f43b29d10 M      builtins
  | :100755 100755 91c869da60ea7719d9f8b221ff39fd7d2261e34d a3ef6123574d724a9d084e50caa9fa720d729301 M      configure
  | :100644 100644 563ba2916172b09adde4f78265492104bfd08685 27aa19733651c0a05d9ef70e528a7bab0fa1247c M      configure.ac
  | :100644 100644 9227638c3c3eb56f1e1fe0394ab7db2a35911a4b 472f585fe1dd82292e6fa9ff1dad55048c4a24fa M      jobs.c
  | :100644 100644 98f62645939a72218dea89cb921a48394a64fe8d 61f0f7c5a8eeb1d0b848662bf7cc4d3961795e21 M      parse.y
  | :100644 100644 8df01e1fe9bcf3aafa0918cc54980e88a6002d72 7d447ab2b9b38cd05623a058c9e6527e22f47e61 M      quit.h
  | :000000 100644 0000000000000000000000000000000000000000 2f127da9927a053b69dde2f9bfef9a5b769eb862 A      quit.h~
  | :100644 100644 786d7f07a9f6304776eea0a01d9293fd6fab5084 016763a077d9cf8c33f3efb9b5ad0a5bf40f38a6 M      test.c
  | :100644 100644 d60a7fb45e71f484cbe105d6c14f02f4932695fd b030747ba37156b90edb4b4fc94974cf2f89efb2 M      trap.c
  | :000000 100644 0000000000000000000000000000000000000000 dcc3851d9b7dbad06e12e7e287f0d3c8c2df45b4 A      trap.c~
  | bisect run success

  でも余り信用していない。何度か試してみる事にする。

  | # bad: [df8375c37c241d6bad23d5c3af5c4233e363b7d5] commit bash-20140221 snapshot
  | # good: [987daba4c451dc7e467c26bb953a308289a6f8b6] bash-4.2 20110622 more stray file cleanup
  | git bisect start 'df8375c' '987daba'
  | # good: [f37a40a43235e39f3f24bb556293b530c106de2f] commit bash-20121102 snapshot
  | git bisect good f37a40a43235e39f3f24bb556293b530c106de2f
  | # bad: [ef5b315f179ae98665c621879ef8c43c08db2ee7] commit bash-20130705 snapshot
  | git bisect bad ef5b315f179ae98665c621879ef8c43c08db2ee7
  | # bad: [bd0a00589fe830b605aa3adca6266f1f95743a73] bash-20130222 remove leftover and stray files
  | git bisect bad bd0a00589fe830b605aa3adca6266f1f95743a73
  | # good: [279b7ea101f99f7ba052fd6f7f04f0ea388f3e55] bash-20121228 additional cleanup
  | git bisect good 279b7ea101f99f7ba052fd6f7f04f0ea388f3e55
  | # good: [4d68afdae9947822df503a6d25a82b2d6b94ca39] bash-20130125 remove leftover and stray files
  | git bisect good 4d68afdae9947822df503a6d25a82b2d6b94ca39
  | # bad: [10e784337238e6081ca5f9bdc8c21492f7b89388] commit bash-20130208 snapshot
  | git bisect bad 10e784337238e6081ca5f9bdc8c21492f7b89388
  | # good: [208fdb509e072977ae7a621e916dfcd32c76047d] commit bash-20130201 snapshot
  | git bisect good 208fdb509e072977ae7a621e916dfcd32c76047d
  | # first bad commit: [10e784337238e6081ca5f9bdc8c21492f7b89388] commit bash-20130208 snapshot

  うーん。どうもちゃんと動くようだ。取り敢えず 208fdb5 は問題ない。そして
  10e7843 はちゃんとコンパイルできて、その上で途中で止まってしまう。取り敢えず
  特に問題を引き起こしている変更まで抽出できた。

  * 元の bug-bash の議論

    そもそもこの変更が行われたのは problem reported by Mike Frysinger
    <vapier@gentoo.org> によると書かれている。以下の報告の様だ。

    https://lists.gnu.org/archive/html/bug-bash/2013-02/msg00016.html

    紹介されているスクリプトで再現しない。bash-4.1 では再現する。と思ったら、こ
    の時点の devel では再現していなかったが、代わりに timeout しないという問題
    があった様である。しかし、こちらの方が寧ろ再現しない。修正によってより
    timeout が効かなくなる様になったという形である。

    この感じだと元のテストケースは使えない。真面目にどういう事になっているのか
    調べて修正する必要があるのではないか。或いはここまで報告したら後は適当にやっ
    てくれるだろうか。

  問題が起こった時の振る舞いを見てみると、sigalrm は呼び出されるがその後の
  check_signals は呼び出されないというのが問題の様である。

  * 止まっている時のスタックの状態はどうなっているのか。
    以下の様に zread.c 51 で止まっている。

    #0  0x00007f71518f4145 in read () from /lib64/libc.so.6
    #1  0x000000000048f665 in zread (fd=9, buf=0x7fff0fd32c3a "", len=1) at zread.c:51
    #2  0x000000000047f995 in read_builtin (list=0x0) at ./read.def:513
    #3  0x00000000004328df in execute_builtin (builtin=builtin@entry=0x47ecb0 <read_builtin>,
    #4  0x00000000004363f9 in execute_builtin_or_function (flags=<optimized out>, fds_to_close
    #5  execute_simple_command (fds_to_close=<optimized out>, async=<optimized out>, pipe_out=
    #6  execute_command_internal (command=<optimized out>, asynchronous=<optimized out>, pipe_
    #7  0x0000000000434498 in execute_command_internal (command=0x2529208, asynchronous=0, pip
    #8  0x00000000004379d5 in execute_in_subshell (command=command@entry=0x25280c8, asynchrono
    #9  0x000000000043401e in execute_command_internal (command=0x25280c8, asynchronous=0, pip
    #10 0x0000000000436ba2 in execute_command (command=0x25280c8) at execute_cmd.c:390
    #11 0x0000000000438b90 in execute_connection (command=0x252b748, asynchronous=0, pipe_in=-
    #12 0x0000000000434498 in execute_command_internal (command=0x252b748, asynchronous=0, pip
    #13 0x0000000000436ba2 in execute_command (command=0x252b748) at execute_cmd.c:390
    #14 0x0000000000435420 in execute_for_command (for_command=<optimized out>) at execute_cmd
    #15 execute_command_internal (command=0x252b588, asynchronous=<optimized out>, pipe_in=<op
    #16 0x0000000000436ba2 in execute_command (command=0x252b588) at execute_cmd.c:390
    #17 0x00000000004212c9 in reader_loop () at eval.c:160
    #18 0x000000000041f927 in main (argc=2, argv=0x7fff0fd336d8, env=0x7fff0fd336f0) at shell.

    ssize_t
    zread (fd, buf, len)
         int fd;
         char *buf;
         size_t len;
    {
      ssize_t r;

      while ((r = read (fd, buf, len)) < 0 && errno == EINTR) ★
        check_signals_and_traps (); /* XXX - should it be check_signals()? */
      return r;
    }

    これを見ると check_signals が呼び出されるのはここ経由なのであろう。

  * check_signals が呼び出される時にはどのように呼び出されるのか

    $ gdb ./bash
    > set style enabled off
    > b r21bp_check_signals
    > set follow-fork-mode child
    > set detach-on-fork off
    > r bisect_read_timeout1.sh
    > inferior 1
    > c
    > inferior 1
    > c
    > inferior 1
    > c
    > inferior 5
    > c
    ここで gdb がクラッシュする→これは style enabled off にしたら動いた。
    > bt

    #0  r21bp_check_signals () at trap.c:475
    #1  check_signals () at trap.c:475
    #2  0x000000000045b9ab in check_signals_and_traps () at trap.c:465
    #3  0x000000000048f667 in zread (fd=9, buf=0x7fffffffcdfa "", len=1) at zread.c:52
    #4  0x000000000047f9a5 in read_builtin (list=0x0) at ./read.def:516
    #5  0x00000000004328df in execute_builtin (builtin=builtin@entry=0x47ecc0 <read_builtin>, flags=flags@entry
    #6  0x00000000004363f9 in execute_builtin_or_function (flags=<optimized out>, fds_to_close=0x5df1c8, redire
        words=<optimized out>) at execute_cmd.c:4717
    #7  execute_simple_command (fds_to_close=<optimized out>, async=<optimized out>, pipe_out=<optimized out>,
    #8  execute_command_internal (command=<optimized out>, asynchronous=<optimized out>, pipe_in=<optimized out
    #9  0x0000000000434498 in execute_command_internal (command=0x595508, asynchronous=0, pipe_in=-1, pipe_out=
    #10 0x00000000004379d5 in execute_in_subshell (command=command@entry=0x595708, asynchronous=asynchronous@en
        fds_to_close=fds_to_close@entry=0x5df1c8) at execute_cmd.c:1567
    #11 0x000000000043401e in execute_command_internal (command=0x595708, asynchronous=0, pipe_in=-1, pipe_out=
    #12 0x0000000000436ba2 in execute_command (command=0x595708) at execute_cmd.c:390
    #13 0x0000000000438b90 in execute_connection (command=0x596508, asynchronous=0, pipe_in=-1, pipe_out=-1, fd
    #14 0x0000000000434498 in execute_command_internal (command=0x596508, asynchronous=0, pipe_in=-1, pipe_out=
    #15 0x0000000000436ba2 in execute_command (command=0x596508) at execute_cmd.c:390
    #16 0x0000000000435420 in execute_for_command (for_command=<optimized out>) at execute_cmd.c:2668
    #17 execute_command_internal (command=0x596808, asynchronous=<optimized out>, pipe_in=<optimized out>, pipe
    #18 0x0000000000436ba2 in execute_command (command=0x596808) at execute_cmd.c:390
    #19 0x00000000004212c9 in reader_loop () at eval.c:160
    #20 0x000000000041f927 in main (argc=2, argv=0x7fffffffd898, env=0x7fffffffd8b0) at shell.c:755

    結局予想は正しかった。

  * 関係ない: sigalrm の戻り値は何も返さなくても良いのか。

    signal handler の戻り値の sighandler は何だろうか。
    set_signal_handler を調べてみると sigaction という関数でシグナルを登録している。
    うーん。sigaction の man を見る限りは void(int) の筈。
    然し sigalrm は sighandler(int) である何でエラーにならないのだろうか。

    ./sig.h:32:#define sighandler RETSIGTYPE
    ./sig.h:33:typedef RETSIGTYPE SigHandler __P((int));

    うーん。試しに SIG_DFL を返してみたがやはり問題は生じる。
    return 0 をしても問題は生じる。なので戻り値の問題ではない様に思われる。

  これはどういう事なのだろうか。多くのシステムで再現する事から何らかの理由があ
  ると期待できる? そもそも SIGALRM で read が失敗するという事が保証されていない
  可能性?

  或いは select を用いて実装し直すのがここは正しいのではないだろうか。
  https://stackoverflow.com/questions/2917881/how-to-implement-a-timeout-in-read-function-call

  色々試した。何が起こっているのかというと (1) read の外で SIGALRM を受信すると
  SIGALRM を逃して無限に待つ事になる(2) read の中であっても pipe を開いて読み取
  り始めるまでは恐らくシグナルを逃す。という事なのだろう。これの対策として read
  の直前に check_signals() の呼び出しが追加されている。然し、それでも
  check_signals と read の呼び出しの間に SIGALRM が現れる可能性もあるし、上記の
  様に read の中で pipe を用意している間に SIGALRM が現れた場合にも対応できない。

  * check_signals が read の直前に追加された経緯を調べる。

    ------------------------------------------------------------------------------

    bb70624e9 (Jari Aalto 2000-03-17 21:46:59 +0000  59)
    0275a139a (Chet Ramey 2018-02-05 10:34:47 -0500  60)   check_signals ();        /* check for signals before a blocking read */
    bb70624e9 (Jari Aalto 2000-03-17 21:46:59 +0000  61)   while ((r = read (fd, buf, len)) < 0 && errno == EINTR)
    e34adc2c3 (Chet Ramey 2020-04-06 09:52:11 -0400  62)     {
    e34adc2c3 (Chet Ramey 2020-04-06 09:52:11 -0400  63)       int t;
    e34adc2c3 (Chet Ramey 2020-04-06 09:52:11 -0400  64)       t = errno;
    e34adc2c3 (Chet Ramey 2020-04-06 09:52:11 -0400  65)       /* XXX - bash-5.0 */
    e34adc2c3 (Chet Ramey 2020-04-06 09:52:11 -0400  66)       /* We check executing_builtin and run traps here for backwards compatibility */
    e34adc2c3 (Chet Ramey 2020-04-06 09:52:11 -0400  67)       if (executing_builtin)
    e34adc2c3 (Chet Ramey 2020-04-06 09:52:11 -0400  68)         check_signals_and_traps ();     /* XXX - should it be check_signals()? */
    e34adc2c3 (Chet Ramey 2020-04-06 09:52:11 -0400  69)       else
    e34adc2c3 (Chet Ramey 2020-04-06 09:52:11 -0400  70)         check_signals ();
    e34adc2c3 (Chet Ramey 2020-04-06 09:52:11 -0400  71)       errno = t;
    e34adc2c3 (Chet Ramey 2020-04-06 09:52:11 -0400  72)     }
    df8375c37 (Chet Ramey 2014-03-07 16:10:54 -0500  73)

    ------------------------------------------------------------------------------

    Commit 64a7a6249 2016-10-19 15:13:16

    >                    9/29
    >                    ----
    >
    > trap.h
    >     - check_signals: new extern declaration
    >     - trapped_signal_received: new extern declaration
    >
    > builtins/read.def
    >     - read_builtin: if one of the zread* functions returns < 0 (which
    >       usually only happens in Posix mode), make sure we call check_signals()
    >       before eventually calling run_pending_traps() because zread() isn't
    >       going to call it
    >     - include trap.h for correct extern functions and variable declarations
    >
    > lib/sh/zread.c
    >     - zread: if executing a builtin, call check_signals_and_traps() for
    >       backwards compatibility.  If not, call check_signals() only, because
    >       we don't want to run traps during, for instance, reading command
    >       substitution output.  Fixes race condition bug reported by Luiz Angelo
    >       Daros de Luca <luizluca@gmail.com>
    > diff --git a/lib/sh/zread.c b/lib/sh/zread.c
    > index 868f9705..496f20b8 100644
    > --- a/lib/sh/zread.c
    > +++ b/lib/sh/zread.c
    > @@ -37,7 +37,10 @@ extern int errno;
    >  #  define SEEK_CUR 1
    >  #endif
    >
    > +extern int executing_builtin;
    > +
    >  extern void check_signals_and_traps (void);
    > +extern void check_signals (void);
    >  extern int signal_is_trapped (int);
    >
    >  /* Read LEN bytes from FD into BUF.  Retry the read on EINTR.  Any other
    > @@ -50,8 +53,13 @@ zread (fd, buf, len)
    >  {
    >    ssize_t r;
    >
    >    while ((r = read (fd, buf, len)) < 0 && errno == EINTR)
    > +    /* XXX - bash-5.0 */
    > +    /* We check executing_builtin and run traps here for backwards compatibility */
    > +    if (executing_builtin)
    >        check_signals_and_traps ();^I/* XXX - should it be check_signals()? */
    > +    else
    > +      check_signals ();
    >
    >    return r;
    >  }

    https://lists.gnu.org/archive/html/bug-bash/2016-09/msg00092.html

    ------------------------------------------------------------------------------

    Commit 0275a139a 2018-02-05 10:34:47

    >                    1/31
    >                    ----
    > lib/sh/zread.c
    >     - zread,zreadintr: call check_signals() before calling read() to
    >       minimize the race window between signal delivery, signal handling,
    >       and a blocking read(2). Partial fix for FIFO read issue reported by
    >       Oyvind Hvidsten <oyvind.hvidsten@dhampir.no>
    >
    > diff --git a/lib/sh/zread.c b/lib/sh/zread.c
    > index 14b66381..8b7ecedf 100644
    > --- a/lib/sh/zread.c
    > +++ b/lib/sh/zread.c
    > @@ -53,6 +53,7 @@ zread (fd, buf, len)
    >  {
    >    ssize_t r;
    >
    > +  check_signals ();^I/* check for signals before a blocking read */
    >    while ((r = read (fd, buf, len)) < 0 && errno == EINTR)
    >      /* XXX - bash-5.0 */
    >      /* We check executing_builtin and run traps here for backwards compatibility */

    https://lists.gnu.org/archive/html/bug-bash/2018-01/msg00114.html
    https://lists.gnu.org/archive/html/bug-bash/2018-01/msg00128.html

    ------------------------------------------------------------------------------

    Commit e34adc2c3 2020-04-06 09:52:11

    >                     4/3
    >                     ---
    > builtins/read.def
    >     - read_builtin: if a read in posix mode is interrupted by a signal,
    >       make sure to preserve the value of errno around calls to
    >       check_signals and run_pending_traps so any error message isn't quite
    >       as confusing. Issue reported by Stan Marsh <gazelle@xmission.com>
    >
    > lib/sh/zread.c
    >     - zread: preserve value of errno (always EINTR) around calls to
    >       check_signals or check_signals_and_traps
    >
    > diff --git a/lib/sh/zread.c b/lib/sh/zread.c
    > index 8b7ecedf..8dd78102 100644
    > --- a/lib/sh/zread.c
    > +++ b/lib/sh/zread.c
    > @@ -55,12 +55,17 @@ zread (fd, buf, len)
    >
    >    check_signals ();^I/* check for signals before a blocking read */
    >    while ((r = read (fd, buf, len)) < 0 && errno == EINTR)
    > +    {
    > +      int t;
    > +      t = errno;
    >        /* XXX - bash-5.0 */
    >        /* We check executing_builtin and run traps here for backwards compatibility */
    >        if (executing_builtin)
    >          check_signals_and_traps ();^I/* XXX - should it be check_signals()? */
    >        else
    >          check_signals ();
    > +      errno = t;
    > +    }
    >
    >    return r;
    >  }

    ------------------------------------------------------------------------------

  これを解決する方法は果たして存在するのだろうか。

  a 一つの方法は以前の様に sigalrt の中で longjmp を実行する方向で、但し様々の
    問題を解決する方法である。というか結局何が問題だったのかよく分からない。

    もしその問題について解決したら patch を受け入れてくれるのだろうか。分からな
    い。そもそも signal handler の中から longjmp した時に何が起こるのかは微妙。
    signal handler の呼び出しはシステムからの特別な呼び出しによる物ではないのか。
    それを乗っ取ってその中で動作し続けて大丈夫なのだろうか。

    と思って検索してみたら正に signal handler の中から longjmp はしては行けない
    というページがあった。この点を指摘されるともう駄目である。
    https://www.jpcert.or.jp/sc-rules/c-sig32-c.html

  b もう一つの方法は何か上手な方法で read が絶対にブロックしないという事を保証
    するという事。select があれば事前に調べる事にすれば良い。但し、この時には
    non-blocking read が必要になる。fd に non-blocking を毎回設定して大丈夫なの
    か。うーん。ソースコードを調べたが O_NONBLOCK は大して使っていない。何か別の手法があるのだったか。

    https://www.geekpage.jp/programming/linux-network/select.php

    このページを見ると blocking のままで使えると書いている。
    うーん。この方法が良いのではないだろうか。

  c reject: SIGALRM を trap したらどうなるか? と思ったが run_pending_traps は
    signal handler の中で即座に呼び出される事はない。という事を考えると SIGALRM
    を trap したとしてもどうにもならない。

    念の為 SIGALRM が呼び出されるか確認する。

    →trap '...' ALRM としても中身が実行される事は決してない。考えてみれば当た
    り前である。というのも、read.def では一時的に signal handler を置き換えるの
    であるから。read が終了しない限りは singal handler は復元されない。なので、
    trap ALRM で設置した handler が read -t の最中に呼び出されるという事はあり
    えない。

  d read の中でシグナルを取り逃がすのだとしたら例えば、sigalrt の中でもうひとつ
    のシグナルを投げて、read が catch しない限り無限にシグナルを投げ続けるのは
    どうだろう。と思ったが、SIGALRT をもう一度投げるとすると、最初の SIGALRT を
    正しく read が捕まえて signal handler を復元した後で、再び SIGALRT が受信さ
    れて元々のハンドラが実行されてしまう。

    % これを防ぐ為には SIGALRT を投げた回数と受信した回数をちゃんと数えて処理しな
    % ければならない。
    %
    % 受信した回数は sigalrt の中で数えれば良い。然し、ちゃんと数えることにしたと
    % してどの様に処理するべきなのかは謎である。うーん。sigalrt は受信する度に新
    % しく SIGALRT を投げる事にする。つまり、常に SIGALRT が飛んでいる状態にする。
    % この様にしておけば read は必ずいつかの時点で中断するのでブロックする事はな
    % くなる。問題は read からタイムアウトした時にどう振る舞うべきかという事。何
    % も考えずにそのまま抜けてしまうと復元後に SIGALRT が来て変な事になる。なので、
    % 最初に SIGALRT ループを停止して、停止を確認した後で初めて処理を抜ける事がで
    % きる。
    %
    % a 例えば sigalrt は放置する事にして、何か処理が停止した事を表すフラグを立て
    %   て、そのフラグが経っていた時に sigalrt 自身にシグナルハンドラーを復元させ
    %   る。同時にシグナルハンドラーを呼ばせる。
    %
    %   この方法を取った時には、もし次の SIGALRT が来る前に再び read -t が呼び出
    %   されたらどうするのかというのが疑問である。一応、ちゃんと状態を管理すれば
    %   問題ない筈だが面倒そうである。

    と思ったが、どうやら単に falarm(0,0) を実行しておけばちゃんと SIGALRT をキャ
    ンセルする事ができる様である。

    改めて調べるとシグナルハンドラーの中で raise を投げるのは難しそう。一回だけ
    は投げても良いかもしれないが再帰的に投げるのは駄目という事になっている。

    https://www.jpcert.or.jp/sc-rules/c-sig33-c.html

    然しこれは廃止されて SIG30-C に統合されたそうだ。

    https://wiki.sei.cmu.edu/confluence/display/c/SIG30-C.+Call+only+asynchronous-safe+functions+within+signal+handlers

    言っている事をまとめると、raise() は C では未定義 (raise によって呼び出され
    た sighandler の中で raise は駄目) だが、POSIX では raise() は
    async-sig-safe 関数として sighandler の中で呼び出してもOKという事になってい
    る。POSIX を信じれば一応呼び出しても OK という事になっている。実際のシステ
    ムがどの様に振る舞うのかは微妙である。

    うーん。実際に動くとしてもかなり危ない感じの手法になるのは確かである。

2021-01-11

* bash-completion: 変なファイルが作られる [#D0020]

  echo '$1>xxx{xxx}' とすると変なファイルが作成される。
  これは ble.sh でやると auto-complete で沢山ファイルが作られるが、
  ble.sh なしでも TAB を推すとファイルが作られる。
  bash-completion の中で行われている展開が何か問題を起こしているのだろう。

  これは bash-completion に PR を出した。

2020-08-31

* report19b: bashline.c で savestring した後で自動で free する様にしていたと思ったが [#D0019]
  実際に確認してみると SEVAL_NOFREE が指定されている。
  r = parse_and_execute (savestring (cmd), "bash_execute_unix_command", SEVAL_NOHIST|SEVAL_NOFREE);
  自分の patch ではこれを削除する様にしたと思ったが残っている。何故?
  経緯について確認する必要がある。

  これについては先ず前に自分がした報告を探す。
  https://lists.gnu.org/archive/html/bug-bash/2018-05/msg00020.html である。
  確かにこの時点では　SEVAL_NOFREE を設定している。blame してみる。

  --- dfc21851b commit bash-20090723 snapshot
  +++ 96b7e2687 commit bash-20180504 snapshot
  -  r = parse_and_execute (cmd, "bash_execute_unix_command", SEVAL_NOHIST|SEVAL_NOFREE);
  +  r = parse_and_execute (savestring (cmd), "bash_execute_unix_command", SEVAL_NOHIST|SEVAL_NOFREE);

  どうもこちらの送った patch をちゃんと適用しなかった様だ。
  或いは、意図的に SEVAL_NOFREE を残した?
  然し、やはりそれは改めて考えてみても変である。
  やっぱりちゃんと patch を見ないで適用したのだとしか考えられない。

* report19: PROMPT_COMMAND を実行中に書き換えると変な事になるという問題 [#D0018]

  スカラーの時には execute_variable_command を呼び出していて、
  この関数の中では savestring を用いて実行コマンドを
  書き換えていたので問題は起こっていなかった。
  然し、配列になると配列自体がコマンド実行によって消滅してしまう可能性があるので、
  配列の値を保存しておくべきなのではないだろうか。

  segfault を起こすことができた。これは明らかに駄目。修正した。

2020-08-28

* report18: bash-5.0 以降で不完全なコマンドを実行するとシェルが終了する [#D0017]
  { a=1 } を無理やり実行するとシェルが終了する。
  というより "for i; do echo $i" を強制的に実行してもそうなる。
  これは防ぐ事はできるだろうか。

  普通の bash セッションで eval 'for i; do echo $i' としてもシェルが終了する。
  何故この様な振る舞いなのだろうか。どうも、bash-5.0 以降の振る舞いの様である。

  先ず eval { だけでも再現する。bash-4.4 以前は終了しない。
  試しに関数の中に入れて実行してみたがそれでも駄目。

  * 取り敢えず何故このような変更がなされたのか調べる事にする。
    先ず、どの commit でこれが発生したのかを調べる。

    8a10051 犯人はこれ。
    以下の変更が怪しい。実際に試したらそうだった。

    > From 8a100514480a55ad73966e516e38778509f6ace6 Mon Sep 17 00:00:00 2001
    > From: Chet Ramey <chet.ramey@case.edu>
    > Date: Thu, 11 May 2017 14:45:50 -0400
    > Subject: [PATCH] commit bash-20170511 snapshot
    >
    > diff --git a/CWRU/CWRU.chlog b/CWRU/CWRU.chlog
    > index 7892ce94..8ea60a39 100644
    > --- a/CWRU/CWRU.chlog
    > +++ b/CWRU/CWRU.chlog
    > @@ -13840,3 +13840,18 @@ builtins/read.def
    >  	  a CTLESC the last time through the loop (skip_ctlesc == 0),
    >  	  especially if i == 0. Another fuzzing bug from Eduardo Bustamante
    >  	  <dualbus@gmail.com>
    > +
    > +				    5/9
    > +				    ---
    > +parse.y
    > +	- token_is_assignment: use the allocated buffer approach in all cases,
    > +	  not just if we're not using bash malloc. This avoids the assignment
    > +	  to t[i+1] writing beyond the end of the allocated token if
    > +	  i == token_buffer_size - 1. Another fuzzing bug
    > +	- xparse_dolparen: if parse_string returns < 0, we clear out the
    > +	  current shell_input_line before performing a longjmp, since we're
    > +	  abandoning parsing of this command.  This is consistent with how
    > +	  the parser resynchronizes after other syntax errors
    > +	- GRAMMAR: add 'error yacc_EOF' production to handle a syntax error
    > +	  that's immediately followed by an EOF after resynchronization.
    > +	  Fixes another fuzzing bug
    > diff --git a/parse.y b/parse.y
    > index 7ca4a64e..dcc628e7 100644
    > --- a/parse.y
    > +++ b/parse.y
    > @@ -411,7 +411,14 @@ inputunit:	simple_list simple_list_terminator
    >  			      YYABORT;
    >  			    }
    >  			}
    > +	|	error yacc_EOF
    > +			{
    > +			  /* EOF after an error.  Do ignoreeof or not.  Really
    > +			     only interesting in non-interactive shells */
    > +			  global_command = (COMMAND *)NULL;
    > +			  handle_eof_input_unit ();
    > +			  YYACCEPT;
    > +			}
    >  	|	yacc_EOF
    >  			{
    >  			  /* Case of EOF seen by itself.  Do ignoreeof or
    > --
    > 2.21.3

    では何故この様に振る舞うのか。

    | ? というより、コメントには
    |   "really only interesting in non-interactive shells" と書いてあるので、
    |   interative shell で振る舞いが変わってしまっているのは意図していない気がする。
    |   →と思ったが handle_eof_input_unit の実装を見ると
    |   interactive shell だけで意味のある操作をしている気がする。
    |   このコメントの non-interactive は interactive の間違いだろうか。
    |
    | ? yacc の記法がよく分からないが、error yacc_EOF と yacc_EOF の両方があるのは何故。
    |   別に error yacc_EOF と yacc_EOF の順序はどちらでも関係ないようである。
    |   うーん。error yacc_EOF とは error が生じてから yacc_EOF が来た時の動作?
    |   →実際にコメントにはその様に書かれている。
    |
    | 調べてみると中で呼び出されている handle_eof_input_unit で終了している様だ。
    | 追加された部分がない時には代わりに yacc_EOF 節が呼び出される訳でもない様だ。
    | 完全なコマンド eval '{ echo; }' 等を実行しても yacc_EOF に入るわけではない。
    | どうも C-d で抜けたりすると yacc_EOF に入る様である。
    |
    | ? そもそもこの修正は何故行われたのか。fuzzing で見つかったという事になっている。
    |   関係ありそうなのは以下のスレッドである。然しどれかは分からない。
    |   https://lists.gnu.org/archive/html/bug-bash/2017-05/msg00076.html *
    |   https://lists.gnu.org/archive/html/bug-bash/2017-05/msg00075.html
    |   https://lists.gnu.org/archive/html/bug-bash/2017-05/msg00045.html
    |   https://lists.gnu.org/archive/html/bug-bash/2017-05/msg00036.html
    |
    |   修正するにしても元々の問題が再現する様になる修正方法では駄目である。
    |   例えば、error yacc_EOF で何も実行しない様にする事で例えば無限ループになるのだと駄目。
    |
    | ここでの正しい修正方法は何だろうか。
    | eval の中で EOF が来た場合には勝手に終了する訳には行かない。

  * 調べて分かった事。対話シェルのユーザコマンドでしか発生しない。
    これは明らかに振る舞いとして不自然である。

    * 普通のスクリプト実行では eval '{' しても其処で終了したりする事はない。
    * bash --rcfile <(echo eval {) -i としても終了したりはしない。

    ? 何故通常のコマンドの時にはこのエラーが発生しないのだろうか。
      eval の中だったら起こるという訳でもない。
      何が起こっているのだろうか。
      と思ったが、唯単に終了しないというだけで通過はしているのかもしれない。
      確認してみる事にする。

      →確かめてみた所、普通のスクリプト実行時にもちゃんと error yacc_EOF は発生しているが、
      対話シェルではないという事からその場で終了したりはしないという事らしい。

      また、eval で完全なコマンドを提供した時には特に error yacc_EOF も yacc_EOF も発生しない。
      評価している文字列の末端でエラーが起こった時に error yacc_EOF が発生し、
      また評価しているスクリプトの末端で yacc_EOF が発生する。
      それ以外の末端の場合には何も発生しない、という事のようである。不思議である。

    * source の場合にも同じ問題が生じる? と思ったら何故か問題は生じない。
      対話モードを一時的に抜けているという事なのだろうか。

      調べてみると evalstring に SEVAL_NONINT または SEVAL_INTERACT を渡した時には
      対応する対話モードに一時的に変更してコマンドを実行する様である。
      source の場合には非対話モードで処理をするという事なのだろう。
      なので急に終了したりはしない。

  * 元の fuzz で発見された問題は何だったのか

    | ? No: eval { で中途半端な状態にして解析中断するとスタックに何か残って問題が起こるという事?
    |   と思って以下のコードを実行してみたが特にメモリを食らう様になるなどの事は内容に見える。
    |
    |   $ time for ((i=0;i<10000000;i++)); do eval {; done 2>/dev/null
    |
    |   メモリ使用量も増えていない。以下の1行目は上のループの実行前で、2行目は実行後。
    |
    |   $ ps uaxf | grep $$
    |   murase    8850  0.0  0.0  16784  7196 pts/3    S    06:35   0:00  |   \_ bash-4.4 --norc
    |   murase    8833 29.2  0.0  16888  7264 pts/3    S    06:32   0:44  |   \_ bash-4.4 --norc
    |
    | ? 元のメールにある報告で確認できないか。よく分からないと思ったが、
    |   base64 で表示しているのが問題のある入力だったという事のようであ
    |   る。中を見ると通常の bash スクリプトの一部を部分的に破壊した様な
    |   内容になっている。成程、こういう物が fuzz の対象となるのである。
    |
    |   実際に bash-4.4 が segfault する事を確認する事ができた。
    |   これが件の変更と関連するかどうかを調べれば良いのである。
    |   →OK segfault にはならなかったが、無限ループになるという事を確認できた。
    |   報告では確かに無限ループと書かれている。

    問題は再現した。そして単にコメントアウトすれば問題は起こらない。

  * まとめ

    ? コメントの "really only interesting in non-interactive shells"
      の意味はよく分からない。実際の動作は逆に interactive shells で何
      か特別な操作をしている様に見える。

    * "error yacc_EOF" は構文エラーの直後に EOF が来る時に発生する?
      通常のスクリプトで発生する条件と
      interactive session に於いて発生する条件が同じか確認が必要。

      * 対話シェルではトップレベルで "error yacc_EOF" が実行される事はな
        い。
      * 関数内で実行されるということもないだろう。何故なら、そもそも
        構文エラーを含む様な関数を定義できないので。
      * source の末端では error yacc_EOF が発生する様だが、source は非
        対話モードでファイルを読み込むので即座に終了するという事はない。
      * eval の末端で起きているのが今回の問題。eval は対話モードで評価
        する為に問題が発生する。

      この現在の状況でそのまま報告すると Chet はおそらく、eval は対話
      モードで評価するのだから { が来た時に終了するのは自然である等と
      変な回答をして修正しないという事が予想される。ここはちゃんと調べ
      て何が問題点でどの様に修正するべきかを提示する必要がある。

    元々の問題は以下で報告されている物である。
    当該変更によって以下の振る舞いが修正される事を確認した。
     https://lists.gnu.org/archive/html/bug-bash/2017-05/msg00076.html

    * どのように修正するべきだろうか。
      単に global_command と handle_eof_input_unit() を
      コメントアウトしただけだと eval { の終了ステータスが 0 になっている。
      handle_eof_input_unit() だけをコメントアウトしてもだめ。
      handle_eof_input_unit() の代わりに EOF_Reached = 1 を設定しても駄目。
      YYACCEPT; の代わりに YYABORT; を実行すると問題ない。

    * そもそも何故この修正で無限ループが修正されるのだろうか。
      これは解析の無限ループではなくて実行の無限ループである。

  * 問題点2: どうも元の報告に対しても bash -n の終了ステータスが変である。
    構文エラーが報告されているのにも関わらず終了ステータス 0 になっている。
    これはやはり終了ステータス 1 になるべきなのではないだろうか。
    →と思ったらこれは bash-5.0 では既に修正されている。
    つまり個の部分に対して更なる修正が追加されたという事を意味する。
    確認する必要がある。

    d7d836dfc (Chet Ramey 2017-06-20 10:38:13 -0400  424) に条件分岐で
    YYABORT と YYACCEPT を切り替える様にしている。更に、
    ab8ded9c3 (Chet Ramey 2018-12-17 14:53:06 -0500  421) で追加の条件で
    何かの処理を追加している。うーん。

    どうも prase_and_execute_level を見て振る舞いを変えれば良いのではないか?
    実際に見てみた所、確かに prase_and_execute_level を見ればトップレベルで実行されているかどうか確認できる。
    なので修正するとすれば handle_eof_input_unit を
    if (interactive && parse_and_execute_level == 0) の条件下に移動するという事。

    然し、そもそも何故 ignoreeof のチェックが evalstring の中で有効に
    なっていたのだろうか。謎である。eval の中で何らかの理由で EOF が受
    け取られた時に ignoreeof が設定されていない時には勝手に終了してし
    まうという事なのだろうか。然し、実際には eval を実行している時には
    EOF は受信されない様である。うーん。不思議である。まあ気にしなくて
    良い気がする。

  Bug report を作成する事にする。必要な情報を集める事にする。

2020-08-23

* report17: PROMPT_COMMANDS と PROMPT_COMMAND を共存させるにはどうしたら良いのか [#D0016]
  ble.sh で --attach=prompt で PROMPT_COMMANDS に対応しようとして分からなくなった。
  取り敢えずメールで質問を書いた。

2020-04-20

* report16: hash_search が線形探索しているから遅いと主張する人が現れた [#D0015]
  然し言っている事が良くわからない。実測してみた所、
  確かに途中から自乗で計算時間が増えている。

  調べてみると rehash が実装されていない。実装してみた所、高速になった気がする。
  条件を等しくして計測しなければならないので計測し直す。

  テスト用コード
  | {
  |   FILE*f=fopen("/dev/tty","a");
  |   fprintf(f,"hash_insert\n");
  |   fclose(f);
  | }

  取り敢えずファイルを整理する。

  * test1.sh は移動して編集した。計測が終わり次第移動元は削除する。
  * 計測データも移動する。 test1.txt.a と test1.txt.b である。
  * gp を編集する。

  2020-08-28 メモが書きかけになって残っていたが、これは既に merge されている。

2020-04-17

* また別の議論で Bash の変な振る舞いを見つけた [#D0014]
  https://github.com/akinomyoga/ble.sh/issues/48

  | $ test_command='f1() { false; return; }; trap "f1 && echo unexpected" WINCH; kill -WINCH 0'
  | $ bash-2.05b -c "$test_command"
  | $ bash-3.1 -c "$test_command"
  | $ bash-3.2 -c "$test_command"
  | $ bash-4.0 -c "$test_command"
  | $ bash-4.1 -c "$test_command"
  | $ bash-4.2 -c "$test_command"
  | $ bash-4.3 -c "$test_command"
  | $ bash-4.4 -c "$test_command"
  | unexpected
  | $ bash-5.0 -c "$test_command"
  | unexpected
  | $ bash-dev -c "$test_command"
  | unexpected

  Bash のソースコードを確認すると buitins/common.c (get_exitstat) に説明が書かれている。

  | if (list == 0)
  |   {
  |     /* If we're not running the DEBUG trap, the return builtin, when not
  |        given any arguments, uses the value of $? before the trap ran.  If
  |        given an argument, return uses it.  This means that the trap can't
  |        change $?.  The DEBUG trap gets to change $?, though, since that is
  |        part of its reason for existing, and because the extended debug mode
  |        does things with the return value. */
  |     if (this_shell_builtin == return_builtin && running_trap > 0 && running_trap != DEBUG_TRAP+1)
  |       return (trap_saved_exit_value);
  |     return (last_command_exit_value);
  |   }

  理由は書かれていないが、bug-bash で検索した感じだと誰かが文句を言ったという事だろうか。
  git blame で確認してみる事にする。以下のような感じである。

  939d190e0 (Chet Ramey 2014-03-21 14:15:01 -0400  559
  e2f12fdf5 (Chet Ramey 2014-04-07 10:46:02 -0400  560

  7117c2d22 (Jari Aalto 2002-07-17 14:10:11 +0000 497)   if (list == 0)
  939d190e0 (Chet Ramey 2014-03-21 14:15:01 -0400 498)     {
  e2f12fdf5 (Chet Ramey 2014-04-07 10:46:02 -0400 499)       /* If we're not running the DEBUG trap, the return builtin, when not
  e2f12fdf5 (Chet Ramey 2014-04-07 10:46:02 -0400 500)           given any arguments, uses the value of $? before the trap ran.  If
  e2f12fdf5 (Chet Ramey 2014-04-07 10:46:02 -0400 501)           given an argument, return uses it.  This means that the trap can't
  e2f12fdf5 (Chet Ramey 2014-04-07 10:46:02 -0400 502)           change $?.  The DEBUG trap gets to change $?, though, since that is
  e2f12fdf5 (Chet Ramey 2014-04-07 10:46:02 -0400 503)           part of its reason for existing, and because the extended debug mode
  e2f12fdf5 (Chet Ramey 2014-04-07 10:46:02 -0400 504)           does things with the return value. */
  e2f12fdf5 (Chet Ramey 2014-04-07 10:46:02 -0400 505)       if (this_shell_builtin == return_builtin && running_trap > 0 && running_trap != DEBUG_TRAP+1)
  939d190e0 (Chet Ramey 2014-03-21 14:15:01 -0400 506)           return (trap_saved_exit_value);
  939d190e0 (Chet Ramey 2014-03-21 14:15:01 -0400 507)       return (last_command_exit_value);
  939d190e0 (Chet Ramey 2014-03-21 14:15:01 -0400 508)     }

  939d190e0 を確認してみる。

  7117c2d22 (Jari Aalto 2002-07-17 14:10:11 +0000 497)   if (list == 0)
  939d190e0 (Chet Ramey 2014-03-21 14:15:01 -0400 498)     {
  939d190e0 (Chet Ramey 2014-03-21 14:15:01 -0400 499)       if (this_shell_builtin == return_builtin && running_trap)
  939d190e0 (Chet Ramey 2014-03-21 14:15:01 -0400 500)          return (trap_saved_exit_value);
  939d190e0 (Chet Ramey 2014-03-21 14:15:01 -0400 501)       return (last_command_exit_value);
  939d190e0 (Chet Ramey 2014-03-21 14:15:01 -0400 502)     }

  939d190e0~ ではどうだろうか。

  7117c2d22 (Jari Aalto 2002-07-17 14:10:11 +0000 496)   if (list == 0)
  7117c2d22 (Jari Aalto 2002-07-17 14:10:11 +0000 497)     return (last_command_exit_value);


  1つ目の修正の説明は以下の様に書かれている。

  >            3/11
  >            ----
  >
  > builtins/common.c
  >   - get_exitstat: when running `return' in a trap action, and it is not
  >     supplied an argument, use the saved exit status in
  >     trap_saved_exit_value.  Fixes Posix problem reported by
  >     Eduardo A. Bustamante L坦pez <dualbus@gmail.com>

  2つ目の修正は以下の様になっている。

  >            3/18
  >            ----
  >
  > builtins/common.c
  >   - get_exitstat: update fix of 3/11 to allow the DEBUG trap to use the
  >     current value of $? instead of the value it had before the trap
  >     action was run.  This is one reason the DEBUG trap exists, and
  >     extended debug mode uses it.  Might want to do this only in Posix
  >     mode


  議論は以下にある。POSIX によると return が trap action の中で呼び出された時、
  必ず trap 直前の値になるという事らしい。うーん。
  https://lists.gnu.org/archive/html/bug-bash/2014-03/msg00053.html

  恐らく2つ目の修正は以下によってなされた。
  https://lists.gnu.org/archive/html/bug-bash/2018-04/msg00047.html

  うーん。と思って他のシェルを調べたら振る舞いがばらばらである。

  | $ mksh -c "$test_command"
  | unexpected
  | $ ksh -c "$test_command"
  | unexpected
  | $ yash -c "$test_command"
  | unexpected
  | $ ash -c "$test_command"
  | $ dash -c "$test_command"
  | $ zsh -c "$test_command"
  | $ busybox sh -c "$test_command"
  | $ posh -c "${test_command//WINCH/INT}"

  https://lists.gnu.org/archive/html/bug-bash/2014-03/msg00053.html
  の議論を改めて観察してみると Eduardo は
  元々 trap action (trap の引数に指定したもの) の中にある return を意図している気がする。
  然し Chet は trap handler が動いている時は無条件で return が
  trap handler 起動直前の $? を返す様に変更した。

  うーん。trap handler に指定した一番上の return だけが影響を受けるという実装はないのか。
  zsh は例えばどの様に実装しているだろうか。
  zsh は以下の設定でシグナルでループを終わらせる事を確認した。
  $ trap 'echo TRAPINT; return 123' USR1
  $ while (($?==0)); do :; done
  と思ったがこれだと終了して当たり前なので振る舞いを確認できない。
  というより、実際に $? がどうなったかを確かめる必要がある。

  % trap 'echo TRAPINT; (exit 123); return' USR1
  % f1() { while :; do for i in {1..100}; do (exit 111); done; done; }
  % f1
  TRAPINT
  % echo $?
  123

  どうも return は普通に trap action の中での直前のコマンドを参照している様だ。

  POSIX は一体どういう意図で書かれたのだろうか。
  * trap の action に関数呼び出しなどの複雑なコマンドは指定できないという事?
    然し、関数は一単語で呼び出せるし special utility を関数で実装する事も許している。
    関数呼び出しをしてはいけないという事を考える必要があるとは思えない。
    そう思うとやはり関数呼び出しの中でも return は同様に振る舞うべきなのか。
  * 或いは f1() { 何かの処理; return; }; trap '処理色々; f1' などの様にして使うのが目的なのか。
    然し、その様な使い方は考えにくいし、その様にするぐらいであれば、
    trap 'f1; return' 等の様に書く気がする。

  取り敢えず修正案を作ってそれから報告する事にする。
  然しどの様に修正するのが良いか。

  取り敢えず trap に入る瞬間の frame を覚えておいて、
  その frame にいる時に限り return の戻り値を直前のコマンドのそれに置き換える。
  その様に実装すれば良い筈である。

  では trap に入る瞬間の frame をどの様に記録するか。
  そもそも何処で trap に入るというのを検出する事は可能か。
  取り敢えず running_trap が設定される状況について確認する。

  * jobs.c で running_trap = SIG_CHLD + 1 が設定されている。
    その後で 0 にクリアされている。
  * trap.c (run_pending_traps) において running_trap = sig + 1 が実行されている。
    trap handler は主に此処で走るということの様である。

    * 此処で $? を global trap_saved_exit_value に保存している。
      但し、この保存が行われるのは複数の handler を処理する前である。
      つまり各 handler が実行される度に更新されるのではなくて、
      何れの handler が実行されるよりも前の値が記録されている。

    * もし return の位置を記録するのだとしたら $? とは違って、
      各 handler が実行される毎に毎回記録し直す必要がある。
      そういう意味で running_trap を設定する度に設定し直す。

      一方で old_running という変数がある。
      これが示唆する事は trap handler が入れ子になって呼び出される可能性があるという事。
      そして、そうだとすると return_frame に関しても old_return_frame 等に
      記録して入れ子に対応できる様にしなければならない。

      或いは return の文脈を直接記録しなくても関数の呼び出しの
      深さのような変数があればそれでも良い。そういう意味では
      BASH_SOURCE か FUNCNAME の様な変数がどの様に更新されるのかを見ても良い。

  | FUNCNAME について調べるとこれの実体は funcname_a という配列オブジェクトの様だ。
  | * そしてこれは execute_cmd.c 4767, 4901 において array_pop, array_push されている。
  |   前者は restore_funcarray_state であり、後者は execute_function である。
  | * 他に builtins/evalfile.c で array_push が実行されている。
  |   これは source, . であろう。
  | * それから shell.c で array_push が実行されている。
  |   これは見た所は最初の初期化としてグローバルに対応する要素を設定しているだけである。
  |
  | と思ったら丁度 funcnest という変数がいい感じに管理されている。
  | 実はこれを記録すれば良いのではないだろうか。
  | * execute_cmd.c の execute_function では funcnest++ されている。
  | * shell.c では funcnest は設定されていない。
  | * evalfile.c では funcnest ではなくて sourcelevel++ が実行されている。
  |
  | よく見ると return_catch_flag++ されている様だ。
  | * evalfile.c で return_catch_flag++ されている。
  | * 実は evalstring.c でも return_catch_flag++ されている。
  |   コメントの説明によると eval の中で return をした場合には、
  |   一旦捕まえて clean up をしてから更に外側に行くとの事。

  総合すると return_catch_flag が使えそうな気がするが、
  これは実は eval も数えてしまうので使えない。
  他に funcnest, sourcenest, evalnest, sourcelevel 等の変数がある。
  evalnest は eval の数を数えるのに使えるかと思いきや、
  何だか関係ない場所でも inc/dec されている (trap.c)。
  普通に考えたら return_catch_flag で evalstring の分を除いた物を記録したい。
  然し、evalstring は eval の他にも様々な場所で使われているから evalnest は使えない。
  色々考えると funcnest + sourcenest が使えるという事の気がする。

  取り敢えず修正した。そして修正した bash を使って幾つかテストしてみた。
  どうやら期待通りに動いている様に見える。
  次にするべき事は Bash に report を書く事である。提出した。

2019-01-22

* report14: ble.sh #D1078 についても [#D0013]

  | 症状は何だったか。
  |
  | $ bash-5.0 --norc
  | $ bind -p | grep '"\\C-\\'
  | $ bind '"\C-\\": self-insert'
  | $ bind -p | grep '"\\C-\\'
  | "\C-\\\": self-insert
  |
  | $ bash-5.0 --norc
  | $ set -o vi
  | $ bind -p | grep '"\\C-\\'
  | "\C-\\": self-insert
  | $ bind '"\C-\\": self-insert'
  | $ bind -p | grep '"\\C-\\'
  | "\C-\\\": self-insert
  | "\C-\": self-insert
  |
  | これである。中々謎である。ちゃんと \C-\\ と出力される事もあるから、
  | これは何か記録のされ方が変な事になっているのだろうという気がする。
  | 取り敢えず bind -p の処理を何処でやっているかを特定する。
  |
  | rl_function_dumper から rl_invoking_keyseqs_in_map を呼び出している。
  | その中で文字列を構築している。中を確認してみると何だか怪しい。
  | \C-\ が出力されてしまう気がする。しかし blame するとここ8年間ここは動いていない。
  | うーん。ここも怪しいかもしれないが今回の事はここが原因ではない。
  |
  | うーん。実際に出力してみると何故かちゃんと \C-\\ になっている。
  | 一方で bind '"\C-\\a"' が <C-\><C-g> と解釈されていると分かった。
  | 更に bind "\C-\a" は <C-\><a> と解釈されている。
  | この振る舞いは bash 4.3 でも同様であった。つまり自分の所為ではない。
  |
  | 一方で Bash 4.3 では bind "\C-\" の " はエスケープされた物として取り扱われる。
  |
  | うーん。どうやら bind -s や bind -X は大丈夫の様だ。
  |
  | まとめ。
  |
  | bind '"\C-\":"..."' の解釈について、
  | 最初の ".." の切り出しの時には \C-\ を認識せずに単に \ だけを見て ".." を切り出す。
  | 次の解釈の時に \C-\ の単位で解釈を行う。したがって "\C-\\" は \C-\ + \ と解釈される。
  | また出力に関しては bind -sX は \C-\\ を出力するが bind -pP は \C-\ を出力する。

  状況を整理すると Bash では \C-\ と \C-\\ が混ざっている。
  単一文字の束縛に対しては bind -spPX は全て \C-\\ を出力する。

    $ ./bash-3a7c642e --norc
    $ bind '"\x1c":"hello"'
    $ bind -s
    "\C-\\": "hello"
    $ bind '"\x1c":self-insert'
    $ bind -p | grep '\\C-\\'
    "\C-\\": self-insert
    $ bind -P | grep '\\C-\\'
    self-insert can be found on "\C-\\", " ", "!", "\"", "#", ...
    $ bind -x '"\x1c":"echo hello"'
    $ bind -X
    "\C-\\": "echo hello"

  複数文字の束縛に対しては bind -pP は最後の文字以外について \C-\ を出力する。
  また shadow binding の場合は最後の文字以外の場合でも \C-\ になる。

    $ ./bash-3a7c642e --norc
    $ bind '"\x1c\x1c":"hello"'
    $ bind -s
    "\C-\\\C-\\": "hello"
    $ bind '"\x1c\x1c":self-insert'
    $ bind -p | grep '\\C-\\'
    "\C-\\C-\\": self-insert
    $ bind -P | grep '\\C-\\'
    self-insert can be found on "\C-\\C-\\", " ", "!", "\"", "#", ...
    $ bind -x '"\x1c\x1c":echo hello'
    $ bind -X
    "\C-\\\C-\\": "echo hello"

  束縛の解釈については "..." を切り出す時には \C-\" は " をエスケープする。
  然し中身を解釈する時には \C-\ が一つのまとまりと解釈される。

  % どちらが採用されるべきだろうか。
  %
  % a \C-\\ に統一する案。既存のコードに対する影響はどれほどだろうか。
  %   つまり \C-\ 前提で扱っているコードはあるだろうか。
  %   "\C-\" は使えない。何故なら \" をエスケープする為。
  %   "\C-\a" 等はどうだろうか。これは従来通りの解釈になる様にすればOK
  %   "\C-\\" はどうだろうか。従来は C-\ + \ だったのが今後は C-\ という意味に変わる。
  %   "\C-\\C-a" は C-\ C-a から "C-\ C - a" に意味が変わる。
  %
  % b 逆に \C-\ に統一する案。"\C-\" を accept する様に書き換えが必要である。
  %   また出力の際に \\ ではなく \ を出力する様に変更する必要がある。

  古い Bash での振る舞いはどうだったか。
  調べてみると出力の inconsistency は Bash 3.0 の時から変わっていない。

  | 解釈の inconsistency についてはどうだろうか。
  | というか何故古い Bash で問題が発生していなかったのか。
  |
  | どうも解釈に関しては \C-\\ から \C-\ になったのは Bash 5 からの様だ。
  | どの瞬間から変化したのだろうか。もしかして自分が噛んでいたりする?
  | 動作を確認すると rl_parse_and_bind が呼び出されてその中で
  | "..." の中身が抽出されて、それから rl_bind_seq 及び rl_macro_bind に渡される。
  | これらの関数は rl_translate_keyseq を使っている。
  |
  | うーん。不思議だ rl_translate_keyseq の中は確かに最近変更されているが、
  | 該当部分は変更されていない様に見える。だとすれば渡す側に何か変更がある?
  | 切り出し部分を確認したが全く変更はない。という事はやはり rl_translate_keyseq である。
  | うーん。昔の状態を checkout して何時からこれになったのか調べる。
  | 20190207 の時点でもう変化していた。20180309 の時点でもう変化していた。
  |   20170804 の時点では変化していた。20170601 では変化。
  |     20170505 変化。これが犯人である。
  |   20170407 の時点では未だ。20170421 未変化。20170428 未変化。
  | 20170106 の時点ででは未だ変化していない。
  |
  | commit af2a77f
  | | diff --git a/CWRU/CWRU.chlog b/CWRU/CWRU.chlog
  | | index 51e95ae3..7892ce94 100644
  | | --- a/CWRU/CWRU.chlog
  | | +++ b/CWRU/CWRU.chlog
  | | @@ -13767,3 +13767,76 @@ lib/glob/sm_loop.c
  | |            matches beyond it.  Look at https://research.swtch.com/glob for a
  | |            longer explanation. This results in a significant speedup for globs
  | |            with multiple instances of `*', especially with more than 4.
  | | +
  | | +                                    5/2
  | | +                                    ---
  | | +lib/readline/bind.c
  | | +        - rl_translate_keyseq: make sure a trailing backslash in the key
  | | +          sequence is preserved. Report from Eduardo Bustamante
  | | +          <dualbus@gmail.com>
  | | +
  | | diff --git a/lib/readline/bind.c b/lib/readline/bind.c
  | | index 117f3427..fef538b1 100644
  | | --- a/lib/readline/bind.c
  | | +++ b/lib/readline/bind.c
  | | @@ -441,7 +441,10 @@ rl_translate_keyseq (const char *seq, char *array, int *len)
  | |            c = seq[++i];
  | |
  | |            if (c == 0)
  | | +            {
  | | +              array[l++] = '\\';        /* preserve trailing backslash */
  | |                break;
  | | +            }
  | |
  | |            /* Handle \C- and \M- prefixes. */
  | |            if ((c == 'C' || c == 'M') && seq[i + 1] == '-')
  |
  | 不思議だこれで振る舞いが変わるのは不思議だ。
  | あ。分かった。テストケースが悪いんだ。
  | 前から \C-\ だったのが、中途半端な \ を無視する事によって
  | \C-\\ がたまたま \C-\ になっていただけなのだ。

  →結局、Bash 3.0 からずっとこの様な取扱いになっていたのだった。
  偶々 \C-\\ が \C-\ + \ になって \ が消滅していたから動いている様に見えたのが、
  commit af2a77f によって顕在化したという事なのである。
  この修正の元になった議論を確認したが恐らく以下のものである。
  https://lists.gnu.org/archive/html/bug-bash/2017-04/msg00139.html
  振る舞い自体については議論に上っていない。何だかよく分からない。
  或いはこの後で ML に関係なく議論が進んだのかもしれない。

  取り敢えず inconsistency は昔からあったので昔の状態に戻すという方針は使えない。

  どう修正されるべきか。

  * これは確実に \C-\\ に変更されるべきである。
    それは今まで動いていた物が動かなくなったから。
    さらに bind -sSX の出力をそのまま使えないから。
    逆に bind -pP の出力が使えなくなるかもだけれども、
    それに関しては同時に対応すればよい。
    他の version の bash の出力を使用する事は考えにくいのだから。

  Note: _rl_convert_meta_chars_to_ascii の時
    \M-\C-x は必ず <\e><\><C><-><x> と解釈されてしまう。
    実際に再現する事ができる。
    	 $ bind 'set convert-meta on'
    	 $ bind '"\M-\C-t":"hello"'
    	 $ bind -s
    	 "\e\\C-t": "hello"
    然し　!_rl_convert_meta_chars_to_ascii の時には
    \M-\C-x は <\M-\C-x> にちゃんと解釈される。
  Note: 従来の実装では _rl_convert_meta_chars_to_ascii の設定に関わらず
    \C-\M-x は必ず <ESC><\C-x> と解釈されてしまう。これは変だ。
    \M の時と同様に振る舞うべきなのである。
  Note: "\C-" や "\M-\C-" の従来の振る舞いについて確認しておく。
  Note: "\" の振る舞いに関しても確認。
  Note: This doesn't yet handle things like \M-\a と書かれていたが、
    この修正によって取り扱う様になった。

2019-12-18

* report11: 何と test case 2 が直っていないではないか [#D0012]
  何が問題かというと→これについては緊急で直した。
  後で追加パッチとして送る必要がある。

  * ok: うーん。要するに ANYOTHERKEY に移動した時にちゃんと -x も移動するのかという問題?
    以下も後でチェックする必要がある。

    $ bind -x '"\C-t": echo world'
    $ bind '"\C-t\C-t":"hello"'
    →これはちゃんと動いていた。

    $ bind -x '"\C-t": echo world'
    $ bind -x '"\C-t\C-t": echo hello'
    →これは動かないが上の項目と同じ問題であろう。
    →これは上を直したらちゃんと動く様になった事を確認した。OK

  パッチは用意した。メールの準備をする。mail2.txt に書いた。
  後は送信するだけである。
  Done: 送信

* report13: shadow `bind -X' が削除されない [#D0011]

  $ bind '"\C-t\C-t\C-t\C-t":"hello"'
  $ bind -x '"\C-t":echo world'
  $ bind -r '\C-t'
  $ bind -X
  "\C-t": "echo world"

  cmd_xmap から削除されていない。
  実際には動かないので bash_execute_unix_command は削除されている。

  % obinding と nbinding の列挙に問題が在るのかと思ったがそうではなかった。
  % そもそも bind -r で削除する時には obinding と nbinding のチェックは行われていない。

  うーん。観察してみても原因は分からない。観察した限りではちゃんと
  map[ANYOTHERKEY] から削除される様になっている気がする。

  調べてみるとどうやら通過していない。
  どうやらそもそも unbind_unix_command というのが呼び出されていない様だ。

  →これは何が悪いか分かった。修正した。

  Done: 送信

* report12: 以前に作った patch を送るにあたって再現する方法はないか考える [#D0010]

  | rl_bind_key
  |   rl_add_defun
  |   rl_bind_key_in_map
  |   rl_unbind_key
  |   rl_parse_and_bind
  |     これは実際に呼び出す事ができそうである。
  |     実際に動かしてみるとちゃんと動く!
  |
  |     と思ったがこれは今時分が修正済みの branch にいるからだ。
  |     →devel に戻って実行してみたがちゃんと動いている様だ。
  |
  |     % 何で動いているのか理解できない。rl_bind_key が確かに
  |     % key == 0 で呼び出されてそうすると rl_generic_bind に
  |     % 空文字列が渡される。更に rl_translate_keyseq で
  |     % 空文字列は空の keyseq に翻訳される様に見える。
  |     % →確認してみた所そもそも rl_generic_bind は呼び出されていない気がする。
  |
  |     分かった。rl_bind_key で問題の場所に入るのは
  |     ANYOTHERKEY として登録する時のみである。
  |     改めて実行してみる事にする。
  |   prepare_terminal_settings (readline/rltty)

  再現できた。以下で行ける。

  $ bind '"\C-@\C-@":"hello"'
  $ bind 'C-SPC:backward-char'

  結果を作文した。
  Done: 送信

* 2019-02-19 OK: rl_generic_bind に "" を渡した時の振る舞いが気になる [#D0009]
  変な事にはならないのだろうか…。printf して見る事にする。

  | うーん。そもそも bind -r '' だと一番下まで制御が行かない。
  | 更に bind -r '\C-@' としても一番下まで制御が行かない。
  | 少なくとも bind -r '\C-@' はバグである…。bind -r '\0' としても駄目である。
  | うーん。やっぱりそもそも rl_generic_bind まで到達していない気がしてきた。
  |
  | と思ったら rl_generic_bind の冒頭にチェックがある。空文字列の場合には直ちに戻る様子である。
  | しかし、それだと \0 に対する処理が説明できない。
  | 呼び出し元に問題があるという事だろうか。
  |
  | 実際に調べてみた所、空文字列の場合でも rl_generic_bind まで到達しない。
  | うーん。どうなっているのだろうか。一回 bind.def から辿ってみる事にしようか。
  | % unbind_command という関数を呼び出している。
  | % unbind_command は同じファイル bind.def 内で定義されていて、
  | % まず初めに rl_named_function を呼び出して関数を特定し、
  | % それから rl_unbind_function_in_map を呼び出している。
  | % あれ、これは変だ。多分、別の関数である。bind -u function-name である。
  | bind -r に対応するのは unbind_keyseq であった。
  | この関数を覗くと怪しい処理がある。rl_function_of_keyseq を空 keymap に対して呼び出している。
  | これは一体何が目的なのだろうか…→空keymapは現在のkeymap _rl_keymap を使うという指示だった。
  | うーん。ここでは rl_function_of_keyseq_len を使うべきではなかろうか。直してみる事にする。
  | →これは直った。\0 とすれば到達する。
  |
  | '' の時にはそもそも bind されていないので到達しない。
  | もし到達したとしても keyseq = "" の時には一番上のチェックで弾かれるのでOK
  | keyseq != "" であれば必ず 1 文字以上の keys が生成される筈である。

  結論。"" を渡した時には先頭ではねられるので問題にはならない。
  一方で、調べている最中に bind -r '\C-@' が効かないというバグが見つかったので修正する。
  これらはいつ報告する事にしようか。Chet の手を煩わせるのもあれなので、
  "bind -x different keymaps" に対する処置が終わってからという事にしたい。
  丁度そのタイミングで、既存のスレッドに対する追加パッチという形でお願いすれば良い。

* report11: また新しいバグを見つけてしまった [#D0008]

  $ LANG=C ./bash-3a7c642e --norc
  $ bind -s '"\C-t\C-t":"hello"'
  $ bind -x '"\C-t":echo world'
  $ <-- <C-t>
  bash-3a7c642e: bash_execute_unix_command: cannot find keymap for command

  bash-4.0 -- 4.2 は segfault
  bash-4.3 は動く
  bash-4.4 から上記の振る舞い

  これは何による物だろうか。
  削除されてしまっている?

  調べてみると timeout したとしても実際に受信している入力が受け取られる?
  否、何だか変だ。C-t しか入力していないのに C-t C-t が受信された事になっている。
  少なくとも rl_executing_keyseq の中身はそういう事になっている。

  そして以下の様にしてみると C-t しか入力していなくても
  C-t C-t を入力したかの様に振る舞っている。

  $ LANG=C ./bash --norc
  $ bind -x '"\C-t\C-t":echo hello'
  $ bind -x '"\C-t":echo world'
  $ <-- <C-t>
  hello

  何かが変である。どうも調べてみると timeout の時には、
  これまでに入力された内容をそのままにして
  改めて dispatch を呼び出している?
  その事によって同じ文字が二重に書き込まれている?
  試してみる事にする。

  $ bind -s '"\C-t\C-u":"hello"'
  $ bind -x '"\C-t":echo world'
  $ <-- <C-t>
  <C-t> <C-t> に対して一致が試みられている。

  うーん。具体的にどの様な構造になっているのか
  ちゃんと確認してからでないと書き換えられない。
  然し、chatoyancy は遅いのでなかなか確認するのが難しい。
  結局どの様な処理の流れになっているのだろうか。
  ユーザが入力をすると一番最初に呼び出されるのはどの関数か。

  うーん。readline -> readline_internal -> readline_internal_charloop
  -> readline_internal_char になっている?
  更に _rl_dispatch(c, _rl_keymap) を呼び出している。
  其処から _rl_dispatch_subseq を呼び出している。
  其処で色々 dispatch していて、通常であれば末尾まで来て、
  其処で _rl_subseq_getchar で新しいキーを読み取って、
  それに基づいて再帰的に _rl_dispatch_subseq を呼び出している?

  _rl_subseq_result は何れにしても呼び出される様だ?
  _rl_subseq_result に -2 を渡した時が何も対応する物に一致しなかった時。
  そしてその時は一旦短くして再一致を確かめるという事の様だ。

  ? _rl_subseq_result に -2 が渡されるのは何処だろうか。

    | rl_executing_keyseq に文字を追加した直後に二箇所明示的に渡している箇所がある。
    | それ以外の場合は dispatch_subseq の戻り値をそのまま渡している。
    |
    | _rl_dispatch_subseq の戻り値は別の _rl_dispatch 呼び出しの戻り値か、
    | - 成功した時は 0 で
    | - ANYOTHERKEY が見つかった時に -2 を返している。
    | - got_subseq がある時には -1 を返す事になっている。
    | - 或いはそうでなくても何も見つからなかった時に
    |   状態をクリア (_rl_abort_internal) して -1 を返している。
    |   _rl_abort_internal の中を確認してみるとこれは緊急用だろうか?
    |   何れにしても -1 は何らかのエラーがあった時用に見える。
    | - 或いは _rl_subseq_result の戻り値をそのまま返している箇所もある。
    | - r = RL_ISSTATE (RL_STATE_MULTIKEY) ? -3 : 0; で決めた物を
    |   返している箇所もある。-3 は今回関係なさそうなので無視する。
    |
    | _rl_subseq_result に関しては、
    | _rl_dispatch, _rl_dispatch_subseq の戻り値を返しているか、
    | 或いは ANYOTHERKEY なら -2 で失敗なら -1 を返している。
    |
    | 取り敢えず ANYOTHERKEY または timeout の時に -2 になる。
    | うーん。何故 ANYOTHERKEY を要求しているのだろうか。
    | というか ANYOTHERKEY が設定されるのはどういう時だろうか。
    |
    | うーん。調べてみると確かに ANYOTHERKEY が設定されている。
    | ANYOTHERKEY が設定されている理由は何だろうか。
    | もし常に設定されている物だとすれば
    | それをチェックする理由は何だろうか。
    |
    | 或いは ANYOTHERKEY の場所に
    | subseq 一致の時の binding を格納している?
    | 調べてみるとそれっぽい。ANYOTHERKEY の場所に入っているのは
    | bash_execute_unix_command だった。bind -s にしてみると、
    | また別の値が入っていた。
    |
    | OK。つまり ANYOTHERKEY を実行するというので良い。

    -2 が渡されるのは対応する binding が見つからなかった時で、
    然し ANYOTHERKEY に対応する binding が設定されている時である。
    ANYOTHERKEY には timeout の時の設定が格納されている。
    そして timeout の時には見つからなかったとして処理される。
    結果として部分一致の結果を実行するという動作になっている。

  * ここでどの様に修正したら良いだろうか。
    timeout の時には rl_executing_keyseq を短くする必要がある気がする。
    然し、そうでない場合には短くするのは変な気がする。
    例えば本当に対応するキーがなかったとしたら
    その時はそのキーを保持するべきなのでは。

    うーん。呼び出し元の ungetc と一緒に短くするべき?
    試してみたが何だか動作が分からない。

    | そもそも 3 文字の時に timeout にならない…。
    | 実装を見ると ANYOTHERKEY をチェックしているので
    | n-1 文字の設定がない限りは n 文字は timeout しないのだ。
    | これは元々特殊キーと ESC を区別する為の timeout と思えば、
    | 確かに中途半端なキー状態で timeout するのは変である。
    | これに関しては備考として残しておくことにする。

  ここで問題は timeout の時ばかりではない事が判明した。
  上に追記した。新しく来た文字に対応する binding がない時に。
  どの様に処理が進むのかという事を確認する必要がある。

    うーん。新しく来た文字に対応する binding がない時に
    どういう分岐をするのか。どうも ISFUNC が設定されている様だ。
    その上で func が 0 になっている。調べると #define ISFUNC 0 である。
    やはり初期状態は全て {ISFUNC, 0} が設定されているのだろう。

  ? cmd_xmap から bind を削除する時にカウントをチェックしている。
    ANYOTHERKEY はちゃんとカウントされているのだろうか。

    例えば tt と t に bind して t を unbind したらちゃんと削除される?
    更に tt と t に bind して tt を unbind したら t に対して
    ちゃんと timeout なしで反応するか?

2019-02-11

* report10: 取り敢えず mail を作成する事にする [#D0007]

  | 2016-11-09
  |
  | * そもそも keymap に登録されたコマンドを実行しているのはどこだろう。
  |
  |   色々探しまわってみると ISFUNC で関数を登録し、ISMACR でマクロ文字列を登録している様だ。
  |   lib/readline/bind.c の中を探しても呼び出している様な場所は見つからない。
  |   よく考えてみたらファイル名が bind である。つまり、ここには登録関係の関数しかない。
  |   検索で ISFUNC をしてみると readline に case ISFUNC: というものがある。
  |   其処に行ってみると取得した関数を実行している。_rl_dispatch_subseq という関数の中だ。
  |
  |   cmd_xmap を廃止してデータを同じキーマップにまとめて登録するのだとしたら、
  |   この辺りの呼び出し方を調べる必要がある。
  |   先ず、現在の設計だと登録されているエントリへのポインタを
  |   呼びだされた関数が直接取得するのは難しそうだ。
  |
  |   a readline 側のサポートが必要になる。しかし、cmd_xmap が readline 側ではなく
  |     bash 側で用意されていることなどから考えるに自由に関数を登録できるような仕組みはそもそも readline にはない。
  |     readline を拡張して cmd_xmap 埋め込みに対応できる様にするというのは readline の機能を大幅に拡張する事になり大げさである。
  |
  |   b 従ってやはり bash 側で何とかいい感じに誤魔化して実装する必要がある。
  |     例えば現在の kmap と key 等を取得することができれば bash 側で同様に map[key].function から同一の情報を得られる。
  |
  |     % しかし readline を見る限り _rl_dispatch_subseq で使われる map, key は動的に指定され外部から取得するのは難しいのではないかという気がする。
  |     % ちょっと調べてみた。大体の場合は map は _rl_dispatching_keymap に一致している様だ。
  |     % しかし _rl_dispatch_callback 経由で _rl_dispatch_subseq が呼び出される場合には予想できない。
  |     % やはり bash で独立に同じ kmap を取得するというのには難がある気がする。
  |     % それが理由で cmd_xmap という内部用の keymap を管理するという事になっているのであろう。
  |     %
  |     % また改めて bash の cmd_xmap の参照の部分を確認してみる。
  |     % rl_executing_keyseq というのを参照している。これは何処で公開される物だろうか。
  |     % こでは readline.c で定義され readline.c で管理されている。readline.h で公開されている。
  |     % この rl_executing_keyseq と一緒に現在の keymap も公開すれば良いのではないだろうか。
  |     % うーん。と思って改めて readline.c を見てみると rl_executing_keymap という物がある。
  |     % 何だこれはと思って調べてみると丁度正に rl_dispatch_subseq で map を外に公開する為に
  |     % rl_executing_keymap = map となっていた。つまり、_rl_dispatch_subseq で使われる
  |     % map および key は普通に外部に公開されていたという事である。
  |
  |     という訳で _rl_dispatch_subseq で使用された map 及び key は、
  |     rl_executing_keymap および rl_executing_key で取得することが可能である。
  |     つまり rl_executing_keymap[rl_executing_key].function とやれば良い。
  |
  |   しかし此処でやはり問題が…。ISMACR の場合には登録されている内容は free の対象であったが、
  |   ISFUNC の場合には登録されている内容は関数へのポインタであって free の対象ではない。
  |   (というか初め ISMACR で関数が登録されているのかと考えて、関数へのポインタへのポインタだと勘違いしていた。)
  |   という事は勝手に新しい情報を ISFUNC に紐付けて登録する事はできないという事になる。
  |
  |   或いは、keymap の entry に新しい項目を追加してしまうというのも手なのかもしれない。
  |   keymap は Keymap 型であり、Keymap 型は以下のように定義されている。
  |     typedef KEYMAP_ENTRY *Keymap;
  |   KEYMAP_ENTRY は struct _keymap_entry の typedef で、_keymap_entry は単純に
  |   char type と rl_command_func_t* function の二つのメンバを持つ。
  |
  |   うーん。この _keymap_entry を改造する位ならば ISMACR, ISFUNC に代わる
  |   type を作成する方が見通しが良い気がする。うーん。
  |   或いは、cmd_xmap に登録する時に keymap も鍵として使用して登録してしまう?
  |   しかし問題が二点ある。
  |
  |   1 keymap の同一性をどの様に判定するのか。
  |     単純にポインタで良いのか。
  |     もし realloc されるとポインタの値が変わってしまう事には注意しなければならない。
  |     keymap に対応する id 番号の様な物が存在すればそれが良いのであるが…。
  |
  |     readline の中を grep する限りは keymap は realloc していない様な気がする。
  |     もっとちゃんと調べる必要がある。cmd_xmap は rl_make_bare_keymap で生成している。
  |     rl_make_bare_keymap は readline/keymaps.c に定義が存在して、
  |     rl_make_keymap 及び rl_copy_keymap から使用されている。
  |     rl_make_bare_keymap の実装を見る限り keymap の長さは固定であるので realloc はない。
  |     また rl_make_keymap 及び rl_copy_keymap は現状では誰も使っていない様だ。
  |
  |     rl_make_bare_keymap を使っている箇所も特に見当たらない。cmd_xmap と、
  |     vi_mode.c の vi_replace_map だけだ。ではその他の keymap はどの様に確保されるのだろうか。
  |     様々の名前がついている keymap は何処なのかと思って探してみると、
  |     readline/bind.c の中に名前が定義されている。実体は各専用のファイルに定義されている様だ。
  |     例えば、"emacs", "emacs-standard" は emacs_standard_keymap という変数に紐付けられ、
  |     これは emacs_keymap.c で定義されている。そしてこれは何と静的な配列である。
  |     特にこれらの基本的な keymap に関して言うならばアドレスが変化するという事はなさそうだ。
  |
  |     では複数のキーに紐付いて設定される keymap に関してはどうだろうか。
  |     一旦削除されてから再度確保し直されるとしても、
  |     前の keymap から新しい keymap への引き継ぎが為されていないのであればそれを追跡する必要はない。
  |     偶たま同じアドレスになるとしてもその場合には
  |     本体の keymap の方に改めて登録するときに一緒に cmd_xmap の方にも登録するので、
  |     その時に上書きされるので変な衝突が起こるという事もないだろう。
  |
  |   2 keymap が消滅する時や unbind する時にどうやってエントリを削除するのか。
  |     しかし、よく考えて見ればこれは現在の実装でも問題になっている筈である。
  |     実装を見た感じ登録するコードは存在しても削除するコードが存在していない気がする。
  |
  |     試してみたところ一度登録した bind -X は二度と解除されない様だ。。
  |
  |     うーん。やはりこれに対応する為には bind/unbind の時に一緒に開放もしなければならず、
  |     その為には readline/bind.c を修正しなければならない。つまり、readline 側での特別な対応が必要である。
  |     もし ISFUNC において関数ポインタを格納する場所が動的に確保される領域であったならば、
  |     その動的確保される領域を勝手に拡張して後半に引数のデータを保持すれば良かった。
  |     しかし実際にはその様な実装にはなっていない様だ。
  |     代わりに ISMACR で格納する様にすれば追加のデータと関数ポインタを一緒に記録できるが、
  |     ISMACR は単にキーボードマクロとして処理されてしまうのでそのままでは使えない。
  |
  |   結局 readline を弄らないとまともな対応は不可能に思われる。
  |   readline を拡張するとすれば param 付きの関数を登録できる様にするという手がある。
  |   param は一個で良い。関数ポインタ単体の時に何が問題かというと動的な機能を登録できないという事である。
  |   つまり、関数ポインタは通常は静的な関数からしか取得できないので静的な機能にならざるを得ない。
  |
  |   要旨: bash_execute_unix_command の内部で元のエントリを取得する事は可能である。
  |   グローバル変数 rl_executing_keymap rl_executing_key を使えば良い。
  |   しかし一番問題になるのは登録されたデータの解放である。
  |   本体 keymap に対する unbind と共に行うのだとすればやはり readline を書き換えるのが易い。
  |   「readline 関数の呼び出し全てに介入して readline の処理を模倣して事前に cmd_xmap の更新を行う」
  |   という方法もできなくはないが結局 readline/bind.c を再実装しているだけに過ぎない気がする。
  |
  |   もう readline を拡張する方向で行くしかない気がする。
  |   しかしその前に C-@ の原因について調べて置かなければならない。
  |
  | ------------------------------------------------------------------------------
  |
  | * [bug] bind -x で登録された項目が内部的に残っている。
  |   更に bind -X で内部的に残っている項目まで全て出力される。
  |
  |   $ LANG=C ./bash --norc
  |   $ bind -X
  |   $ bind -x '"A": echo hello'
  |   $ bind -X
  |   "A": "echo hello"
  |   $ bind '"A": self-insert'
  |   $ bind -X
  |   "A": "echo hello"  # <-- overwritten keyseq is still remained
  |   $ exit
  |
  |   マクロの場合にはちゃんと消える。
  |
  |   $ LANG=C ./bash --norc
  |   $ bind -s
  |   $ bind '"A":"hello"'
  |   $ bind -s
  |   "A": "hello"
  |   $ bind '"A": self-insert'
  |   $ bind -s # <-- nothing output, the entry was successfully removed
  |   $ exit
  |
  | * [bug] cmd_xmap が keymap 間で共有されている。
  |   複数の異なる keymap に登録すると一方が他方を上書きする。
  |
  |   $ LANG=C bash-4.4 --norc
  |   $ bind -m emacs -x '"A":echo emacs'
  |   # ----- type A -----
  |   emacs
  |   $ bind -m vi -x '"A":echo vi'
  |   # ----- type A -----
  |   vi
  |   $ exit
  |
  |   $ LANG=C bash-4.4 --norc
  |   $ bind -m emacs '"A":"echo emacs"'
  |   # ----- type A -----
  |   $ echo emacs
  |   emacs
  |   $ bind -m vi '"A":"echo vi"'
  |   # ----- type A -----
  |   $ echo emacs
  |   emacs
  |   $ set -o vi
  |   # ----- type ESC A -----
  |   $ echo vi
  |   vi
  |   $ exit
  |
  |   $ LANG=C bash-4.4 --norc
  |   $ bind -m emacs -x '"A":echo emacs'
  |   # ----- type A -----
  |   emacs
  |   $ bind -m vi -x '"A":echo vi'
  |   # ----- type A -----
  |   vi
  |   $ set -o vi
  |   # ----- type A -----
  |   vi
  |   $ set -o emacs
  |   $ exit
  |
  | * [bug] cmd_xmap には bind 時の文字列が全体の keyseq として登録される。
  |   例えば emacs-ctlx には C-x に続いて何かを入力した時の動作を指定する事ができるが、
  |   これに対して bind -x しようとしても正しく登録する事ができない。
  |   (とはいいつつこれは単に bind -m emacs -x '"\C-x?": ...' とすれば期待通りにできるので回避可能である。)
  |
  |   $ LANG=C bash-4.4 --norc
  |   $ bind -m emacs -x '"A":echo hello'
  |   # ----- type A -----
  |   hello
  |   $ bind -m emacs-ctlx -x '"A":echo world'
  |   # ----- type C-x A -----
  |   bash-4.4: bash_execute_unix_command: cannot find keymap for command
  |   # ----- type A -----
  |   world
  |   $
  |   $ exit
  |
  |   マクロの場合にはちゃんとできる。
  |
  |   $ LANG=C ./bash --norc
  |   $ bind -m emacs-ctlx '"A":"hello world"'
  |   $ exit

* report9: convert-meta と unmeta について [#D0006]

  まとめ始めたが何だか分からなくなった。
  というか unmeta を if の中に入れるだけでは治らない。
  cmd_xmap と現在の kmap で map[ESC].type == ISKMAP の
  状態が異なる為に不一致が起こっている。

  _rl_convert_meta_chars_to_ascii を参照している箇所を確認して、
  全体としての一貫性がどうなっているのかを改めて確認する必要がある。

  bind.c:144: rl_bind_key に関しては、そもそも meta char を受け取って、
  現在の kmap[ESC] が存在していない場合には "out of range" の扱いだそうだ。

  bind.c:400: rl_generic_bind については、
  そもそも keys, keys_len を翻訳する時に工夫すれば良いのでは?

    →rl_translate_keyseq を修正したので変更不要の気がするが、
    使わないコードを残しておく理由もないので削除する。

  bind.c:523: rl_translate_keyseq は \M- の形式だけ \e に変換している。
  他の場所で meta chars を分解するぐらいであればそもそもこの場所で
  \e に分けて置いた方が良いのではないだろうか。

    →強制的に ESC と UNMETA (c) に分ける様に書き換えた。
    実装を見てみても最大バッファ長さは strlen(str)*2 + 1 で変わらないと思う。

  bind.c:799: _rl_function_of_keyseq_internal は書き換えかけたが…
  よく考えたらこれは読み取りのコードなのでこのままで良い気がする。
  書きかけて削除したコードは以下に残しておく。

    | char* keys;
    | int keys_len;
    |
    | keys = keyseq;
    | keys_len = len;
    |
    | if (_rl_convert_meta_chars_to_ascii)
    |   {
    |     keys = (char *)xmalloc(len * 2 + 1);
    |     keys_len = 0;
    |     for (i = 0; keyseq && i < len; i++)
    |       {
    |         unsigned char ic = keyseq[i];
    |         if (META_CHAR (ic))
    |           {
    |             keys[keys_len++] = ESC;
    |             keys[keys_len++] = UNMETA (ic);
    |           }
    |         else
    |           keys[keys_len++] = ic;
    |       }
    |     keys[keys_len] = '\0';
    |   }

  bind.c:2588: rl_invoking_keyseqs_in_map
  これは正直 \M-? と出力しようが \e? と出力しようがどちらでも良い。
  \e が kmap に存在するかどうかで動作を分けるのも妙な気がするが。
  と思ったが、この構造を追うと map[ESC].type == ISKMAP は恒真ではないか。なので気にしない。

    | for (key = 0; key < KEYMAP_SIZE; key++)
    |   {
    |     switch (map[key].type)
    |       case ISKMAP:
    |         {
    |           for (i = 0; seqs[i]; i++)
    |             {
    |               if (key == ESC)
    |                   if (_rl_convert_meta_chars_to_ascii && map[ESC].type == ISKMAP)
    |                     sprintf (keyname, "\\M-");
    |                   else
    |                     sprintf (keyname, "\\e");

  readline.c:817: _rl_dispatch_subseq
  うーん。これは一体何をやっているか分からない。meta char が指定された時は、
  map に ESC がなければ rl_ding というのを実行している。
  これは実装を確認すると単にベルを鳴らすだけの話である。
  これは受け取った文字を使って kmap を辿る操作である。
  meta char は ESC と UNMETA (c) に分解して辿る。
  これはこのままで問題ない。

  取り敢えず patch を作った。

* report7: 序でなのでこれも報告する事にする [#D0005]
  ref ble.sh/memo.txt#D0920

* report8: 改めてバグ報告をする事にする [#D0004]
  ref ble.sh/memo.txt#D0918
  簡単なバグなのですぐ送ってしまう事にする。

2018-05-03

* report6: 月を跨いだので現在分かっている最後のバグについて patch を送る事にする [#D0003]
  このバグについてのメモは何処かにあるはずだと思ったが、
  確認してみると何処にも見つからない。
  仕方がないので改めて際限コードを作成する事にする。

  $ bash-4.4 --norc
  $ f1() { bind -x '"\C-t": f1'; }; f1
  bash-4.4: $'\317\003': command not found

2018-03-23

* READLINE_POINT が bytes 単位である事について [#D0002]

  これは ble.sh の方にメモがあるかと思ったら何もなかった。そういう仕様だという前提で書かれたのであろう。
  READLINE_POINT が bytes 単位である事を認識して書いているコードはどれぐらいあるだろうか。

  | 正しく実装する一つの方法は LC_CTYPE を設定してから文字列の長さを測るという物である。
  | [Search](https://github.com/search?utf8=%E2%9C%93&amp;q=LC_CTYPE+READLINE_POINT+NOT+LC_MESSAGES+NOT+rl_line_buffer&amp;type=Code)
  | →[dot/kingbash.script](https://github.com/billinux/dot/blob/986cc0b8df950687ff0b50aced6df5a755a9b9d3/bin/kingbash.script)
  |
  | もう一つの方法は LC_ALL を設定するという物。
  | [Search](https://github.com/search?q=LC_ALL+READLINE_POINT+NOT+LC_MESSAGES+NOT+rl_line_buffer+NOT+READLINE_LINE_BUFFER&amp;type=Code&amp;utf8=%E2%9C%93)
  |
  | 或いは wc -c でも数えられるかもしれない。
  | [Search](https://github.com/search?utf8=%E2%9C%93&amp;q=wc+%22READLINE_POINT%3D%22+NOT+LC_MESSAGES+NOT+rl_line_buffer+NOT+READLINE_LINE_BUFFER&amp;type=Code)

  他の検索

  | [Stack Overflow](https://stackoverflow.com/search?q=%22READLINE_POINT%22)

  結局、どうやら kingbash.script で対策されているだけで他には使われていない様である。
  [Bash/関数 - ArchWiki](https://wiki.archlinux.jp/index.php/Bash/%E9%96%A2%E6%95%B0)
  によると KingBash はメニュー補間を実現するスクリプト (2008) の様である。

  kingbash.script の場合には単に文字列末端にカーソルを移動するだけである (要確認)。
  LC_ALL=C LC_CTYPE=C で過大評価になるだけなので結局文字列末端に移動することは変わらない。

  とにかく初めに READLINE_POINT の修正案を提示する事が先である。
  先ず文字列の長さを数える方法について確認する。
  或いはパラメータ展開の offset, length をどの様に処理しているか。

  subst.c:4411: mb_getcharlens (string, len)
  subst.c:7639: mb_substring (string, s, e)
  lib/readline/mbutil.c:363: _rl_find_next_mbchar (char *string, int seed, int count, int flags)

  文字数からバイト位置に変換するのは _rl_find_next_mbchar で良さそうだ。flags = 0
  mb_getcharlens は調べてみると何処からも使われない。
  というか ifdef INCLUDE_UNUSED の中にあるというのはそういう事の様だ。
  他に類似の機能はないだろうか。というか ${#var} の場合に何れにしても数える必要があるので、
  何処かでその機能は存在しているはずである。

  subst.c:6967: parameter_brace_expand_length (name) の中の
	subst.c:7021:           number = MB_STRLEN (t); である。

  MB_STRLEN は incloude/shmbutil.h で定義されている。

  $ rl-insert () { READLINE_LINE=${READLINE_LINE::READLINE_POINT}$1${READLINE_LINE:READLINE_POINT}; ((READLINE_POINT+=${#1})); }
  $ bind -x '"\C-t": rl-insert AA'
  $ echo あ|いうえお

  ここで C-t を押してみるとあらぬ所に挿入される。更に続けて文字を入力すると文字が壊れる。

2018-03-21

* 改めて C-@ の問題について patch を送る事にした [#D0001]

  関連して他の問題もある。`rl_bind_keyseq_if_unbound_in_map' 287 lib/readline/bind.c で、
  引数 keyseq を rl_function_of_keyseq と rl_bind_keyseq_in_map に渡している。
  rl_function_of_keyseq は translated sequences を受け取る関数である。
  rl_bind_keyseq_in_map は untranslated sequences を受け取る関数である。

  rl_function_of_keyseq が translated sequences を受け取る関数であることの根拠

    o 実装がその様になっている (長さを受け取らないので欠陥であるが)。
    o bash_execute_unix_command で translated sequences を渡している。
    - initialize_readline (bashline.c) で null-terminated sequences を渡している…が、
      これは何とも言えない。

  rl_bind_keyseq_in_map が untranslated sequences を受け取る関数であることの根拠

    o 中で rl_translate_keyseq を呼び出している。
    o bind_keyseq_to_unix_command で bind -x '"...": ...' の最初の ... の部分を
      rl_bind_keyseq_in_map に渡している。

  rl_bind_keyseq_if_unbound_in_map が untranslated sequences であるべき理由

    o 長さを受け取っていないので、translated だと問題が起こる。
    - rl_bind_key_if_unbound_in_map から null-terminated で呼び出している。
    - rl_bind_key_if_unbound から null-terminated で呼び出している。
    - rl_bind_keyseq_if_unbound は等価な関数
    x bind_termcap_arrow_keys で使われている rl_bind_keyseq_if_unbound は
      translated sequences でなければならない。
      →これは keys, key_len 引数を受け取る様にしなければならない。
      もしこれに対応するとすると、
      - rl_bind_keyseq_if_unbound_in_map
      - rl_bind_keyseq_in_map
      - rl_generic_bind
      それぞれに対して keys, key_len を受け取る版を作成しなければならない。x

  ToDo:
    rl_bind_key_if_unbound_in_map: untranslate
    rl_bind_key_if_unbound       : untranslate

  以下は昔書きかけた bug report

  | From: murase
  | To: bug-bash@gnu.org
  | Subject: [50 character or so descriptive subject here (for reference)]
  |
  | Configuration Information [Automatically generated, do not change]:
  | Machine: i686
  | OS: linux-gnu
  | Compiler: gcc
  | Compilation CFLAGS:  -DPROGRAM='bash' -DCONF_HOSTTYPE='i686' -DCONF_OSTYPE='linux-gnu' -DCONF_MACHTYPE='i686-pc-linux-gnu' -DCONF_VENDOR='pc' -DLOCALEDIR='/home/murase/opt/bash-4.4/share/l\
  | ocale' -DPACKAGE='bash' -DSHELL -DHAVE_CONFIG_H   -I.  -I. -I./include -I./lib   -O2 -march=native -Wno-parentheses -Wno-format-security
  | uname output: Linux padparadscha 4.7.2-101.fc23.i686 #1 SMP Fri Aug 26 16:39:46 UTC 2016 i686 i686 i386 GNU/Linux
  | Machine Type: i686-pc-linux-gnu
  |
  | Bash Version: 4.4
  | Patch Level: 0
  | Release Status: release
  |
  | Description:
  |   [Detailed description of the problem, suggestion, or complaint.]
  |
  | Repeat-By:
  |
  |   $ LANG=C bash-4.4 --norc
  |   $ bind -x '"\C-@":echo hello'
  |   $
  |   # ----- type C-@ or C-space -----
  |   bash-4.4: bash_execute_unix_command: cannot find keymap for command
  |   $ bind -x '"\C-A":echo hello'
  |   # ----- type C-a -----
  |   hello # expected result for C-a
  |   $ exit
  |   $ LANG=C bash-4.3 --norc
  |   $ bind -x '"\C-@":echo hello'
  |   $
  |   # ----- type C-@ or C-space in the terminal -----
  |   bash-4.3: bash_execute_unix_command: cannot find keymap for command
  |   $ exit
  |   $ LANG=C bash-4.2 --norc
  |   $ bind -x '"\C-@":echo hello'
  |   # ----- type C-@ or C-space -----
  |   hello
  |   $ exit
  |
  | Fix:
  |   [Description of how to fix the problem.  If you don't know a
  |   fix for the problem, don't include this section.]

  以下はこれについての古い項目

  | 2016-11-09 C-@ に bind -x すると実行に失敗する原因は分かった。
  |
  | | 先ず bind -X するとちゃんと登録されている。
  | | よく分からないので登録時・読み取り時の kseq 変数の中身を printf で見てみる。
  | | どうやら登録時は bind に指定した引数 (の部分文字列) をそのまま渡している様だ。
  | | そして読み取り時は入力したキーの列がそのまま渡されている。
  | | これだと登録時と読み取り時で異なるシーケンスになるのが普通だがこれで良いのか?
  | | 試しに C-a で試してみると両者が異なっていてもちゃんと機能する様だ。
  | | というか、登録時の kseq と読み取り時の kseq は意味合いが異なるのだろう。
  | |
  | | と、ここで読み取り時に実際に入力したキーの列が格納されているのはヌル終端文字列である。
  | | ヌル終端文字列に C-@ を含ませる事は不可能である。
  | | これだと長さ 0 になってしまうのではないだろうか。
  | | そしてこの推測が正しければ、そもそも C-@ を一文字でも含む様なキーシーケンスは全然登録できない。
  | | 試してみることにする。
  | |
  | | C-@A で試してみた所やはり同様に
  | |   bash: bash_execute_unix_command: cannot find keymap for command
  | | のエラーが発生する様だ。(C-@ set-mark が残っているので、
  | | 素早く入力しないと set-mark の方が呼び出されてしまう事に注意する。
  | | # というか C-@ を解除する方法はないのだろうか…と思ったら普通に bind -r で良かった。
  |
  | [まとめ]
  |
  | cmd_xmap から読み出す時に rl_executing_keyseq (ヌル終端文字列) を使っているが、
  | そこに C-@ が含まれていると其処で文字列が終端していると見なされて読み出せない。
  |
  | さてではどの様に修正したら良いであろうか。
  | ヌル終端文字列を受け取る関数 rl_function_of_keyseq を見るといろいろな箇所で用いられている。
  | 何故これが問題にならないのであろう。。というかこの関数は本当にヌル終端文字列を受け取る関数なのか?
  | → bind -x '"\\\\": echo double bslash' として \ \ と入力したら rl_function_of_keyseq に "\\" が渡され、
  | 結果として正しく echo double bslash が実行された。つまり rl_function_of_keyseq は "\\" をちゃんと二文字の \ と認識している。
  | 勝手にエスケープされた一文字の \ という様に誤解釈したりはしない様だ。つまり、
  | rl_function_of_keyseq は本当にヌル終端文字列を受け取るという事である。
  |
  | ここで、その他の rl_function_of_keyseq で問題が生じないのかどうかを調べる必要がある。
  | 先ず rl_function_of_keyseq の実装を念のため確認する。やはり常に生のヌル終端文字列として取り扱っている。
  | 今度は呼び出し元について調べる。
  | - called by rl_bind_keyseq_if_unbound_in_map:
  |   % readline 内部での呼び出しは rl_bind_keyseq_if_unbound_in_map (bind.c) の引数をそのまま渡すもののみである。
  |   % rl_bind_keyseq_if_unbound_in_map は readline 内部 (bind.c) のみで使用されている。
  |   % - called by rl_bind_key_if_unbound_in_map:
  |   %   key から keyseq を作って渡している。
  |   %   rl_bind_key_if_unbound_in_map は initialize_readline (bashline.c) 内部でハードコートされた引数について呼び出されている。
  |   %   たまたまハードコートされたキーについては C-@ が含まれていないので問題が起こっていないという事だ。
  |   %   他の箇所では使われていない。従ってこれについては問題は生じない。
  |   % - called by rl_bind_key_if_unbound:
  |   %   この関数は誰も使っていない。
  |   %   また、中身は単に rl_bind_key_if_unbound_in_map(key, default_func, _rl_keymap) に置き換えられる。
  |   % - called by rl_bind_keyseq_if_unbound:
  |   %   rl_bind_keyseq_if_unbound_in_map(keyseq, default_func, _rl_keymap) であり、
  |   %   実際に使われている箇所はハードコートされた物と terminfo から読み取った制御シーケンスである。
  |   %   制御シーケンスには NUL は含まれない (ANSI規格に従えば)。従ってこれも問題は起こらない。
  |   これはよく見てみれば別のバグで rl_function_of_keyseq に keys を渡す時に翻訳を忘れているだけだった。
  |   その修正さえすれば何の問題もない。
  | - called by bashline.c (initialize_readline):
  |   四ヶ所から呼び出されているが全部ハードコードされた物であり NUL は含まれていない。
  | - called by bashline.c (bash_execute_unix_command):
  |   これは今問題になっている関数である。
  |
  | 結局今回問題になっている物以外は全てハードコードされた物であって (たまたま) 何も問題が生じていないという事の様だ。
  | さて rl_function_of_keyseq を拡張して長さを指定できる様にするとしたらどの様にするか。
  | 長さを取得する方法が必要である。
  | 調べると rl_key_sequence_length という変数に長さが入っている様だ。
  | 似た変数名として rl_executing_keyseq_size という物があるが、
  | これは buffer のサイズを保持しているのであって長さを保持している訳ではない事に注意する。
  | extern int rl_key_sequence_length は readline.h で公開されている。
  | という訳で
  |
  | さて似たような事が他で問題にならないのかというのは不思議である。
  | - rl_untranslate_keyseq この関数名は怪しいと思って確認した見たが、
  |   keyseq といいつつこれは1文字を文字列に変換するだけの関数である。
  | - というかそもそも keymap は終端をどの様に検知しているのだろう?
  |   うーん。というかそもそも kseq を保持する様な実装にはなっていなくて、
  |   keymap の chain を辿っていく仕組みになっていて、唯一長さを意識するのは bind 時であったが、
  |   これは ASCII rep で渡しているから問題ないということなのか。しかしそれでも rl_translate_keyseq に渡すから、
  |   問題になるのじゃないかと思ったが…rl_translate_keyseq はちゃんと int* len という引数に結果を格納する。
  | ★rl_bind_keyseq_if_unbound_in_map この関数は引数 keyseq の使い方が怪しい。
  |   keyseq を rl_function_of_keyseq と rl_bind_keyseq_in_map にそのまま渡している。
  |   rl_function_of_keyseq は keyseq を直接表現として取り扱う。
  |   rl_bind_keyseq_in_map は keyseq をASCII表現として取り扱う。
  |   ドキュメントによると keyseq は ASCII 表現でなければならない気がする。
  |   つまり変換が必要である。
