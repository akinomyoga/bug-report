

------------------------------------------------------------------------------
  Memo
------------------------------------------------------------------------------

2020-01-20

* newlib-cygwin コンパイルの時の注意

  1. setup.exe で cocom, xmlto, gendef, zlib-devel を入れる。

    コンパイルの途中で shilka が要求される。shilka は cocom に含まれている。
    他に xmlto が要求される。
    gendef は newlib-cygwin に含まれている気がするが念の為入れておく。
    zlib.h がないというエラーが出るので zlib-devel を入れてみたが効果はなかった。

  2. make distclean で綺麗にする。

    make clean をしてしまうと make distclean ができなくなるので注意する。
    もし make clean をした場合は手動で以下を実行する。
    $ rm -f $(find . -name config.cache) winsup/cygwin/cygwin.sc

  3. ./configure --prefix=$HOME/opt/cygwin/devel && make する。

  4. make -C x86_64-pc-cygwin/newlib/doc makedoc.exe; make する。

    途中で makedoc を作るルールがありません、と表示されるので、
    makedoc.exe と拡張子まで指定して生成させて make をやりなおす。

  * "ld: Unsupported PEI architecture: pei-i386"
    x86_64-pc-cygwin/winsup/cygwin でこのエラーが発生した時は
    古い cygwin.sc が残っている。特に x86 から x86_64 に切り替えた時。

  * "x86_64-pc-cygwin/winsup/cygwin/cygdll.a': そのようなファイルはありません"
    このエラーメッセージは上のエラーメッセージが出た後に
    改めて make すると出る。空の cygwin1.dll ができているので、
    次のステップに進もうとして、しかし implib である cygdll.a がないのでエラーになる。

2019-07-23

* Cygwin 3.1.0 以降では Takashi Yano によって 2019-04-01 に
  押し込まれた変更により、cygwin console の機能は使えなくなり、
  基本的に Windows のコマンドプロンプトによってエスケープシーケンスが処理される。
  古い Windows で動かした時にのみ fallback として cygwin console が起動する。

* Cygwin のやり取りを見ていたら Corinna Vinschen は
  git send-email を推奨している。調べてみる。ちゃんと Gmail の設定もできる様だ。
  http://masahir0y.blogspot.com/2013/06/git-send-email.html
  https://qiita.com/troter/items/3b4cd6972c338b95835d
  受け取り方が何だかよく分からないが。.mbox 形式?


------------------------------------------------------------------------------
  ToDo
------------------------------------------------------------------------------

2020-01-23

* ble.sh の補完の反応が悪い。
  途中で停止する為に使っている read -t 0 が動いていない?

2019-07-24

* 一つの方法は "DECSCUSR を復活させる" と称して
  24bit モードでもシーケンスの解釈をさせる様に変更するという事である。
  然し、そもそも既存の DECSCUSR だって、何だか振る舞いが他の端末と違ったし、
  本当に無理やり対応させる価値があるのかというと微妙である。

  まあ cygwin console は死んだと思って良いのである。
  或いは明示的に cygwin console を使う方法があっても良いのだとは思うが。。

  * 追記: 2020-01-18 Cygwin を更新して 3.1.2 にしたら色々トラブルが出ている。
    序でに調べてみた所、どうやら DECSCUSR には新しく対応し直した様だ。
    1..6 が他の端末と同じ振る舞いで 7 が下太下線。
    7以上でカーソルの大きさの%指定という機能は継承されなかった様だ。

  * 追記: 2020-01-20 今日 cygwin-patches を見たら、
    丁度古い cygwin console を使う為の CYGWIN 環境変数の設定が追加されていた。
    CYGWIN に disable_pcon を指定すれば良い。未だ merge はされていないが。

2019-07-23

* 気になるのは今まで cygwin console で対応していた全ての機能が
  Windows のコマンドプロンプトによって提供されているのか、という事である。
  或いは最早 cygwin コンソールではないので気にしなくても良いという事なのだろうか。
  まあその様な考え方もあるにはあると思われる。

  - 実際に試してみた所 DECSCUSR が使えなくなっている。

  - set scrolling region は OK

  - REP は cygwin も cmd も両方共変な実装になっている。
    元からそういう物だったのか? xterm がそうなのかもしれない。
    と思って xterm で試してみたがそんな事はなかった。
    xterm はちゃんと最後に入力された文字を繰り返している。

2019-07-22

* console: 観察していて気づいたのだが 24bit color 対応の箇所における
  con.nargs の使い方がまるで誤っている気がする。
  これだと単体の色設定の SGR しか使えない…。

* console: 新しい cygwin の console は fhandler_console とは独立に思われる。
  一方で fhandler_console は今も未だ変更の対象である。
  fhandler_console の振る舞いを今はテストできていないが、
  以下の問題が解決したとは思われない。

  - Cygwin は ED(2) "ESC [ 2 J" が駄目
  - Cygwin は RI の振る舞いがおかしい
  - Cygwin は最終行での DL "ESC [ M" が駄目
  - Cygwin は CUF() の行き先が行末 $ の時に何処にも移動しない。


------------------------------------------------------------------------------
  Done
------------------------------------------------------------------------------

2020-01-23

* shared_info::initialize: size of shared memory region changed from

  | 二分法で探索してみると別の pty に対する修正によって動かなくなっている。
  | 6cc299f0e - (2 days ago) Cygwin: pty: Revise code waiting for forwarding by master_fwd_thread. - Takashi Yano
  | 
  |   shared_info::initialize: size of shared memory region changed from
  | 
  | というエラーメッセージが出て bash も起動しないし dash も起動しないし、
  | cat も ls も起動しない。これは cygwin1.dll の互換性の問題だろう。
  | 例えば tty.h で端末の構造体の大きさを変更してしまったので
  | 共有メモリの配置が変化したなど? 何れにしても tty.h を弄ったら、
  | 他の多くのプログラムが再コンパイルになるというのは想像に難くない。
  | (本当だろうか? 直接触るのではなくて HANDLE で処理している限りは
  | 特に問題ないのではないだろうか?)
  | 
  | これについては気づく人がいれば気づくだろう。

  そもそも cygwin1.dll のテストの方法が悪いのだろうか。
  うーん。これについてもメールを書かなければならない。
  →取り敢えず質問を出したのでこれで満足

* contra を起動しても bash の反応がない。プロンプトを出した所で止まる。
  どうも bash との通信がうまく行っていない気がする。うーん。

  他の物が影響しているかもしれないので問題修正の commit だけ取り込んで試してみる。
  やはり再現する。bash との通信がうまく行っていない。
  x 1 直接 contra win を開くとプロンプトが表示された所で止まっている。
  o 2 mintty の中から contra win を開くと普通に使える。
  x 3 mintty の中から contra tty を開くと vi モードのモード表示が出た所で止まる。

  そもそも上の 1, 3 が同じ問題なのか別の問題なのかも分からないが、
  少なくとも、この commit を拾うと両方とも再現する様になるのである。

  →取り敢えず先に 3 について調べる事にする。これが駄目だという事は
    O_NONBLOCK が駄目という事だろうか。と思って minimal_openpt.cpp をコンパイルしてみる。
    実際にやってみるとちゃんと動いている。うーん。
    minimal_openpt.cpp が動くのに contra tty が動かないというのは不思議な事である。
    あー。やっぱり -mwindows が悪いんだろうか。。再度試してみる必要がある。

  * ble.sh なしでのチェック
    後もう一つ確認して置かなければならないのは。
    これは ble.sh が絡んでいるのかそうでないのかという事。
    ble.sh がある時にだけ再現するというのだとまた複雑である。

    →大丈夫。ble.sh がなくても再現する。.bashrc の先頭で return して確かめた。

  * そう言えば入力が全く処理されていないという事は。
    そもそもこちらからの入力を読み取れていないという事だろうか。
    だとすると、もっとプログラムを単純化する事ができるのではないか。

    然し、それとは別に contra win は問題を抱えている。うーん。

    何れにしても単純化を試してみる事にする。
    単純化させて思ったのは…。終了させる方法がないという事。
    termios.c_cc[VINTR] = 003; /* C-c */

  →どうも。そもそも nonblock を指定しなくても様子が変だ。
    うーん。これで取り敢えず報告を書く事にする。

  報告したら修正が入った。取り敢えずこれは動くようになった。
  一緒に起こっていた他の問題もちゃんと直った。

  というかミスが多すぎである。
  状況を調べる為だけに何時間も消えた。

* 2020-01-18 cygwin を update したら Cygwin 3.1.2 になっている。

  contra を動かすと何か変だ。物凄くぴかぴかして黒いウィンドウがちらつく。
  始め contra の問題かと思ってデバグをしていたがよく分からない。
  再現プログラムを作ろうとしたらどんどん小さくなっていく。
  結局 gcc -mwindows でコンパイルしたプログラムで端末に出力をすると、
  以降そのセッションでは spawn する度にコンソールが表示されるという事の様だ。

  例えば mintty --version すると以降そのセッションではぴかぴかして
  見づらいし、遅いし、CPU は食うし大変な事になる。

  というか報告する前に最新の Cygwin を確認しておく。
  と思って fetch したら Cygwin 3.1.2 が出てから
  Takashi Yano 氏が沢山修正している。
  色々問題が出てきて焦っているところだろうか。
  この一連の修正で直ったという事もあるかもしれない。様子見する。

  取り敢えず report を送った。
  と思ったら再現しない、という報告が帰ってきた。うーん。
  何か再現の条件があるのだろうか。
  というかもしかして Windows を再起動したら直ったりして。。
  →再起動してみたが未だ再現する。何がいけないのだろうか。
    もっと詳しく見てみなければならないだろうか。
    或いは locale の問題などの可能性はあるだろうか。
    うーん。何れにしてもこれは暫く様子見する。

  再現しないのは変だ。これに寄与しそうな事として他に何がある?
  もう一つの note pc で試しても再現した。
  locale が関係している? と思って試したら英語にしたら再現しなくなった。
  →再度 report を送った。

  原因を特定したという返事が来て修正が来た。
  新しい cygwin に push されるのを待ってコンパイルして試してみた。

  x と思ったらそもそも端末がどれも動かなくなっている。
    これについては新しい項目を立てて考える事にする。

  x さて、上の問題を起こしている commit は drop してコンパイルして当座は凌ごうと思ったら
    今度は contra を起動しても制御が渡ってこない。色々おかしい。

  これらはそれぞれの項目で対処する事にする。

2020-01-18

* Cygwin のビルドを試みる。
  1. setup.exe で cocom, xmlto, gendef, zlib-dev を入れる。
  2. make distclean ; rm -f $(find . -name config.cache) で綺麗にする。
  3. ./configure --prefix=$HOME/opt/cygwin/devel && make する。
  4. make -C x86_64-pc-cygwin/newlib/doc makedoc.exe; make する。

  Note: shilka は cocom に入っている。
    他に xmlto や gendef 等がビルド中に使われる様だ。
  Note: make distclean の前に make clean をすると Makefile が消えてしまう。
    これによって "find . -name config.cache -exec rm -f {} \; \;" を
    手動で実行しなければならなくなる。また cygwin.sc というファイルも消す。
    $ rm -f $(find . -name config.cache) winsup/cygwin/cygwin.sc

  x86_64-pc-cygwin/winsup/cygwin/cygdll.a': そのようなファイルはありません
  というエラーが出てコンパイルできない。winsup/cygwin/Makefile の中を見ると、
  どうも cygdll.a は cygwin0.dll を生成した時に一緒に出力される予定の気がする。
  そして cygwin0.dll を消してやり直してみると以下のエラーが表示されている。
  /usr/lib/gcc/x86_64-pc-cygwin/7.4.0/../../../../x86_64-pc-cygwin/bin/ld: Unsupported PEI architecture: pei-i386

  やりなおしても駄目。失敗するコマンドは以下の通り。怪しい物もない気がする。

  | g++ -L/home/murase/prog/ext/newlib-cygwin/x86_64-pc-cygwin/winsup/cygwin
  |   -isystem /home/murase/prog/ext/newlib-cygwin/winsup/cygwin/include
  |   -B/home/murase/prog/ext/newlib-cygwin/x86_64-pc-cygwin/newlib/
  |   -isystem /home/murase/prog/ext/newlib-cygwin/x86_64-pc-cygwin/newlib/targ-include
  |   -isystem /home/murase/prog/ext/newlib-cygwin/newlib/libc/include
  |   -O2 -g -mno-use-libstdc-wrappers -L/usr/lib/w32api
  |   -Wl,--gc-sections -nostdlib -Wl,-T../../.././winsup/cygwin/cygwin.sc -static
  |   -Wl,--heap=0 -Wl,--out-implib,cygdll.a -shared -o cygwin0.dll
  |   -e dll_entry cygwin.def
  |   advapi32.o aio.o arc4random_stir.o assert.o autoload.o base64.o
  |   bsdlib.o clock.o ctype.o cxx.o cygheap.o cygthread.o cygtls.o
  |   cygwait.o cygxdr.o dcrt0.o debug.o devices.o dir.o dlfcn.o
  |   dll_init.o dtable.o environ.o errno.o exceptions.o exec.o external.o
  |   fcntl.o fenv.o fhandler.o fhandler_clipboard.o fhandler_console.o
  |   fhandler_cygdrive.o fhandler_dev.o fhandler_disk_file.o
  |   fhandler_dsp.o fhandler_fifo.o fhandler_floppy.o fhandler_netdrive.o
  |   fhandler_nodevice.o fhandler_pipe.o fhandler_proc.o
  |   fhandler_process.o fhandler_process_fd.o fhandler_procnet.o
  |   fhandler_procsys.o fhandler_procsysvipc.o fhandler_random.o
  |   fhandler_raw.o fhandler_registry.o fhandler_serial.o
  |   fhandler_signalfd.o fhandler_socket.o fhandler_socket_inet.o
  |   fhandler_socket_local.o fhandler_socket_unix.o fhandler_tape.o
  |   fhandler_termios.o fhandler_timerfd.o fhandler_tty.o
  |   fhandler_virtual.o fhandler_windows.o fhandler_zero.o flock.o
  |   fnmatch.o fork.o forkable.o fts.o ftw.o getentropy.o getopt.o glob.o
  |   glob_pattern_p.o globals.o grp.o heap.o hookapi.o inet_addr.o
  |   inet_network.o init.o ioctl.o ipc.o kernel32.o ldap.o
  |   libstdcxx_wrapper.o loadavg.o localtime.o lsearch.o malloc_wrapper.o
  |   minires-os-if.o minires.o miscfuncs.o mktemp.o mmap.o mmap_alloc.o
  |   msg.o msgcat.o mount.o net.o netdb.o nfs.o nftw.o nlsfuncs.o ntea.o
  |   passwd.o path.o pinfo.o poll.o posix_ipc.o posix_timer.o
  |   pseudo-reloc.o pthread.o quotactl.o random.o regcomp.o regerror.o
  |   regexec.o regfree.o registry.o resource.o rexec.o rcmd.o scandir.o
  |   sched.o sec_acl.o sec_auth.o sec_helper.o sec_posixacl.o security.o
  |   select.o sem.o setlsapwd.o shared.o shm.o sigfe.o signal.o sigproc.o
  |   smallprint.o spawn.o strace.o strfmon.o strfuncs.o strptime.o
  |   strsep.o strsig.o sync.o syscalls.o sysconf.o syslog.o termios.o
  |   thread.o timerfd.o times.o tls_pbuf.o tty.o uinfo.o uname.o wait.o
  |   wincap.o window.o winf.o xsique.o malloc.o acoshl.o acosl.o asinhl.o
  |   asinl.o atan2l.o atanhl.o atanl.o cabsl.o cacosl.o cargl.o casinl.o
  |   catanl.o cbrtl.o ccosl.o ceill.o cephes_emath.o cexpl.o cimagl.o
  |   clog10l.o clogl.o conjl.o copysignl.o coshl.o cosl.o cosl_internal.o
  |   cossin.o cpowl.o cprojl.o creall.o csinl.o csqrtl.o ctanl.o erfl.o
  |   exp10l.o exp2l.o expl.o expm1l.o fabsl.o fdiml.o finite.o floorl.o
  |   fmal.o fmaxl.o fminl.o fmodl.o frexpl.o ilogbl.o internal_logl.o
  |   isinf.o isnan.o ldexpl.o lgammal.o llrint.o llrintf.o llrintl.o
  |   llroundl.o log10l.o log1pl.o log2l.o logbl.o logl.o lrint.o lrintf.o
  |   lrintl.o lroundl.o modfl.o nearbyint.o nearbyintf.o nearbyintl.o
  |   nextafterl.o nexttoward.o nexttowardf.o pow10l.o powil.o powl.o
  |   remainder.o remainderf.o remainderl.o remquol.o rint.o rintf.o
  |   rintl.o roundl.o scalbl.o scalbnl.o sinhl.o sinl.o sinl_internal.o
  |   sqrtl.o tanhl.o tanl.o tgammal.o truncl.o version.o winver.o
  |   /home/murase/prog/ext/newlib-cygwin/x86_64-pc-cygwin/winsup/cygserver/libcygserver.a
  |   /home/murase/prog/ext/newlib-cygwin/x86_64-pc-cygwin/newlib/libm/libm.a
  |   /home/murase/prog/ext/newlib-cygwin/x86_64-pc-cygwin/newlib/libc/libc.a
  |   -lgcc
  |   /usr/lib/gcc/x86_64-pc-cygwin/7.4.0/../../../../lib/w32api/libkernel32.a
  |   /usr/lib/gcc/x86_64-pc-cygwin/7.4.0/../../../../lib/w32api/libntdll.a -Wl,-Map,cygwin.map

  /usr/lib/gcc/x86_64-pc-cygwin/7.4.0/../../../../x86_64-pc-cygwin/bin/ld: Unsupported PEI architecture: pei-i386

  一つずつ消していったら -Wl,-T../../.././winsup/cygwin/cygwin.sc というオプションを
  消したらエラーが出なくなった。
  cygwin.sc を開いて中を覗くと確かに pei-i386 と書かれている。
  Makefile を覗くと cygwin.sc を生成するルールが在るので、
  一旦 cygwin.sc を待避して改めて cygwin.sc を生成してみる。

  make したらそのままコンパイルの続きが始まった。
  zlib がないというエラーが出る。/usr/include/zlib.h にちゃんとある。
  よく分からないが new-cygwin1.dll は既に生成されているので気にしない事にする。

  opt/cygwin/devel に環境を作ろうとしたが mintty が動かない。
  contra も試しに動かそうとしてみたがやはり動かない。

  仕方がないので /bin/cygwin1.dll を直接置き換える事にした。
  3.1 であれば特に問題もないだろうと期待する。
  →動かしてみた。動いている。

  結局最新の cygwin でも再現したのだった。


2019-07-23

* Cygwin console を起動させる方法?

  * うーん分からない。少なくとも Takashi Yano は fhandler_console
    で動く端末でテストできていた筈なのである。
    それが何故今できないのだろうか…。

  | 元々の cygwin1.dll を使うとちゃんと
  | fhandler_console 由来の端末で起動している。
  |
  | a 今度は自分でコンパイルしたバイナリを使ってみる事にした。
  |   然し、それでも矢張り謎のターミナルで起動する。
  |   取り敢えず terminfo や cyggcc に対する依存性はなくす事ができた。
  |
  | b どういう事だろう。或いは最近の更新で変更されたのだろうか。
  |   3.0.7 をビルドしてみる事にする。
  |   →何と自前で3.0.7をビルドした場合にはちゃんと cygwin console になった。
  |
  | c 或いは ./configure で適切なフラグを設定する必要があるのだろうか。
  |   ./configure --help で中を見てみたがそれっぽい物は見つからない。
  |   winsup の中の ./configure や winsup/cygwin の中の ./configure も確認してみたが、
  |   やはり関係のありそうな物は見つからない。
  |
  | d それとも cygwin の中でビルドすると色々と変な物を引っ掛けるという事なのだろうか。
  |   一応 cygwin1.dll について cygcheck で調べてみるとちゃんと kernel32 にだけに依存している。

  結局 b でちゃんと cygwin console になる事が確認できた。
  つまりビルドの仕方の問題というよりかは実際に変更が行われたのである。

  | うーん。二分法で何処から xterm-256color 的な変なターミナルになるのか調べる…。
  | checkout してビルドするだけかと期待したが駄目だった。
  | ./configure からやり直さなければならなかった。つまり、物凄く時間がかかる。
  | $ m clean; m; m -C i686-pc-cygwin/newlib/doc makedoc.exe; m
  | うーん。実は cygwin dll だけをコンパイルするという様にはできないだろうか。
  |
  |   6b7723a83 xterm-256color
  |   40b947e7d xterm-256color
  |   f527171a9 コンパイル失敗
  |     滅茶苦茶沢山のエラーが出ているので何か include が抜けているという事の気がする
  |   513f050cb xterm-256color
  |   6a06c6bc8 xterm-256color
  |     % コンパイル失敗 @ new-cygwin
  |     % うーん。また失敗した…。もしかするとこのリポジトリのファイル自体が壊れている?
  |     % 何と、空の winsup/cygwin/globals.h ファイルができていて、
  |     % これを削除してみたらちゃんと動き始めた。
  |     結局 Yano 氏の段階ではmasterは既にcygwin consoleではなくなっていたという事なのか。
  |   d1be0a59d cygwin
  |     うーん。もしかして bump が原因なのか?
  |     Bump するだけでバージョンの整合・不整合などの理由によって変化する?
  |
  |   あー。どうも分かった気がする。
  |   bd627864a で導入されたのは 24bit color ではない。
  |   ENABLE_VIRTUAL_TERMINAL_PROCESSING で検索してみると
  |   https://qiita.com/zetamatta/items/0c6130bd631491b97844 という記事が見つかった。
  |   結局既存の cygwin console のコードは使わなくなって、
  |   代わりにコマンドプロンプトのコードを使う事になったという事なのだろう…。
  |   つまり "24bit color に対応する" とか嘯いて実際は "cygwin console を捨てさせた" のである。
  |   これは分かりにくい。というかこれで良いのだろうか…。
  |
  |   更に言うと 256 色 / 24bit 色に対応している様に見えた部分は、fallback コードである。

  問題は結局 Takashi Yano によって導入された 24bit 対応だった。
  結局 "24bit 対応" と称してコマンドプロンプトに全部のシーケンスを横流ししているだけなのだ。
  問題の箇所は fhandler_console::write_normal の中にある while ループである。
  何れにしてもこれで cygwin console の端末としての機能はほぼ死んだという事。
  今後使われる事もないし今後メンテナンスされる事もない。

  | * [保留] Linux 上でクロスコンパイルできないか?
  |   うーん。linux 上でクロスコンパイルできないかと思って
  |   sudo dnf search cygwin 等としてみたが当たらない。
  |   というかそもそも cygwin をコンパイルするのに target が cygwin で良いのかも不明である。
  |   a 以下に macOS で i686-pc-cygwin-gcc を生成する方法が書かれている。
  |     http://fd0.hatenablog.jp/entry/20090204/p1
  |   b sudo dnf search で cross-compile で検索すると MinGW が色々出てくる。
  |     mingw32-gcc を入れてコンパイルしたらできたりするんだろうか。
  |     取り敢えず入れてみる。
  |     $ sudo dnf search install mingw32-{gcc,gcc-c++,binutils,headers,crt}
  |     然し、cygwin をクローンして ./configure して make すると何も起きない。
  |     ./configure の段階ではクロスコンパイラを認識している気がする。
  |     ./configure の出力を見ると何故か "checking whether we are cross compiling... no" になっている。
  |     どうも分かった。--target ではなくて --host を指定しなければならないのだ。
  |     うーん。気になるので追加で cross-compile 関係を入れる。
  |     $ sudo dnf install mingw32-{xz,gmp,gcc-gfortran,gcc-objc}
  |     $ sudo dnf install flex expect isl isl-devel
  |     駄目だ…結局何もコンパイルされない。
  |
  |     普通に linux 上で使う為にコンパイルでもしてみるかと思ったがそれも駄目だった。
  |     もうよく分からないので諦める事にした。削除した。

  Linux 上でのクロスコンパイルは難しそうである。

  * winsup/cygwin/how-to-debug-cygwin.txt というファイルを見つけた。
    中を覗いてみたがビルドの仕方については載っていない。単にデバッガを使う方法とか諸々。

2019-07-21

* 最新版における cygwin console の振る舞いのテスト

  | 取り敢えず printf で制御シーケンスを出力して変な振る舞いがないか見る。
  | と思ったら色々と直ってしまっている気がする。
  | これは本当に cygwin コンソールなのだろうか。
  | DA2 応答を見ようとしたら返事がない。変だ。
  |
  | 分からないので現状の cygwin1.dll をコピーしてみて同じ様に振る舞うのかを調べる。
  | 成る程…現行の cygwin1.dll だとやはり問題は再現する。DA2 応答もちゃんと帰ってくる。
  | 然し、自前でビルドした cygwin1.dll だと問題は発生していない。代わりにDA2が来ない。
  | 大幅に修正されたという事なのだろう…。
  | 或いはもしかすると完全に別の実装に切り替わってしまった?
  |
  | 何れにしても前にあった問題が全て解決したかどうかを確認したい。
  | 再び自前でビルドした cygwin1.dll に変えて試してみる。
  | - 念の為また DA2 応答を調べてみる。やはり全く何も返信していない様だ。
  | - RI は普通に戻っていた。CUF の問題も解決していた。
  | - \e[100H として物凄くスクロールする問題も解決していた。
  | - ED(2) が何も動かないという問題は解決している?
  |   然し、ED(2) で (0,0) に移動してしまうという振る舞いは変である。
  | - DL(n) が最終行まで削除する時に全然削除されないという問題も解決している。
  |
  | うーん。git blame してみても 2014 年ごろに幾らか振る舞いが変更されている以外は
  | 全然変更されていない。ED のコードもちゃんとカーソル位置を復元している様に見える。
  | うーん。これを思うと実は現在コンソールを表示しているコードは別にある?
  |
  | DA2 に対する応答は全然ないが DA1 に対する応答は存在している。
  | 確認してみると CSI ? 1 ; 0 c を返している。
  | これは cygwin console の CSI ? 6 c とは異なっている。
  | - 検索してみても怪しい所は見つからない。
  |   うーん。完全に異なるコードベースの上で動いているのだろうか。
  |   或いは ConPty を使う様になったという事なのかもしれない。
  | - conpty で検索しても何も見つからない。
  | - xterm-256color で検索してみると見つかった。
  |   cygwin/environ.cc にある win32env_to_cygenv (PWCHAR rawenv, bool posify) という関数。
  |   wincap.has_con_24bit_colors () という関数を呼び出して判定している。
  |   関数呼び出しだがこれは wincap.h で実装されていて実際には
  |   中に持っている構造体の同名のビットフィールドを返す様になっている。
  |   何れにしてもこれも判定は Windows のバージョンに従って行われている様子である。
  |   wincap.cc に各 Windows に対するフラグがそのまま記録されている。
  |
  | 実は Cygwin 3.0 branch は物凄く古いコードの上で動いているんだろうか。
  | と思ったがそんな事もなかった。現在見ている最新版と大差ないコードである。
  | というよりも DA2 応答を見る限りは今見ているコードはやはり cygwin の方である。
  | 最新版で動いているのはやはり謎ターミナルのきがする。
  | というか DA1 応答も今見ているコードは \e[?6c である。
  | そして他に terminal の様なコードは見当たらない。

  結論としては最新版でビルドされる cygwin1.dll を使って
  bash を直接起動すると cygwin console ではない謎の console で起動される。
  TERM=xterm-256color であり DA1 応答は \e[?1;0c である。DA2応答はない。
  実は他の端末が起動しているとしたらどの端末だろうか。
  - mintty は DA1R として \e[64;1;2;4;6;9;15;21;22;28;29c を返すので違う。
    そもそも mintty は ED(2) でちゃんとその場に留まる。
  - ConPTY の可能性…。検索したら以下に ConPTY のサンプルコードがある。
    https://devblogs.microsoft.com/commandline/windows-command-line-introducing-the-windows-pseudo-console-conpty/
    CreatePseudoConsole という API が存在する様だ。
    然しこの関数は cygwin の中では呼び出されていない。謎だ。

* 自前でビルドした Cygwin の上で bash を動かしてみるテスト。
  というか bash は単体で起動するんだろうか。

  $ cygcheck /usr/bin/bash
  C:\cygwin\bin\bash.exe
    C:\cygwin\bin\cygwin1.dll
      C:\WINDOWS\system32\KERNEL32.dll
        C:\WINDOWS\system32\ntdll.dll
        C:\WINDOWS\system32\KERNELBASE.dll
    C:\cygwin\bin\cygiconv-2.dll
    C:\cygwin\bin\cygintl-8.dll
    C:\cygwin\bin\cygreadline7.dll
      C:\cygwin\bin\cygncursesw-10.dll
    C:\cygwin\bin\cyggcc_s-1.dll

  駄目だ色々な物に依存している。
  これらをごっそりとコピーして試してみる…。
  $ mkdir test
  $ cd test
  $ mkdir bin
  $ cp /bin/cygなんとか.dll bin/

  と思ったが駄目だった。
  一応 bash は立ち上がる物のコマンド類が全く使えないのでまともに動かない。
  うーん。どうした物か。というか先ず terminfo が見つからない…。

  無理やり terminfo をコピーする。
  $ cd test
  $ mkdir -p usr/share
  $ cp -r /usr/share/terminfo usr/share/terminfo

  一応これで bash の行編集はまともに動く様になった。
  然し、echo $TERM を実行してみると xterm-256color を名乗っている…。
  さて、今から試したい事は先ず初めにこれが cygwin console である事の確認。
  うーん。分からない。

* Cygwin のビルド

  取り敢えず最新の cygwin をビルドする所から始める。

  * サブディレクトリに入ってから Cygwin のコンパイルを試すが通らない。
    gendef: command not found となる。
    検索すると MinGW 関連のバイナリの様である。
    Cygwin の setup.exe で探してみるが mingw-w64-tools 的な物はない。
    分からないと思って setup.exe の窓に gendef と入れてみたら
    gendef 単体で見つかった。入れる事にした。

    然し入れてから実行してみるとエラーになって動かない。
    gendef がファイルを開くのに失敗しましたと言っている。
    というか gendef に渡されている様々のオプション引数が
    全てファイル名として解釈されている様だ。gendef のバージョン等が違うのだろうか。

  全然分からない。以前 cygwin をデバグした時の記録を探してみる事にする。
  どうやら前回は色々と追加で入れる必要があった物のちゃんとコンパイルできていた様である。

  * うーん。改めて全体で configure した物を確認してみる。
    No rule to make target 'makedoc', needed by 'all-am'
    というエラーメッセージが発生している。うーん。これを無視する様に編集しようか。
    Makefile を覗いてみたらどうも makedoc.c なるファイルが存在する事になっている。
    と思って makedoc.c をコピーしてみても状況は変化しない。
    結局 make makedoc.exe を実行したら動いた。拡張子を指定しなければならなかったのである。
    もっと詳しく見ると all-am は $(DATA) を要求し $(DATA) は $(noinst_DATA) に展開される。
    一方でルールは $(MKDOC) に対してしか定義されていない。
    以下の部分が問題になっている様だ。"automake will add $(EXEEXT)" という部分が気になる。

      # We can't use noinst_PROGRAMS, because automake will add $(EXEEXT).
      noinst_DATA = makedoc
      MKDOC = makedoc$(EXEEXT_FOR_BUILD)

    うーん。元の Makefile.am を見てみても同様に書かれている。
    git blame Makefile.am として見たが 2000年からこの部分は全く変化していない様だ。
    また前にビルドした時(2017年3月)以降には変更はない様でもある。うーん。
    環境によって .exe をつけたりつけなかったりが色々なのだろうか。

  取り敢えず先に進む事にする。ビルドに結構時間がかかっている様だ。
  というより Build the listings... というメッセージの所でずっと固まっている。
  psforest がまたエラーになっていたのでそれを直したら new-cygwin1.dll が完成していた。
