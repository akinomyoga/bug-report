
------------------------------------------------------------------------------
  Memo
------------------------------------------------------------------------------

2019-02-11

* バグ報告の仕方

  git format-patch HEAD~ 等とする。


------------------------------------------------------------------------------
  Bugs
------------------------------------------------------------------------------

2016-11-09

* そもそも keymap に登録されたコマンドを実行しているのはどこだろう。

  色々探しまわってみると ISFUNC で関数を登録し、ISMACR でマクロ文字列を登録している様だ。
  lib/readline/bind.c の中を探しても呼び出している様な場所は見つからない。
  よく考えてみたらファイル名が bind である。つまり、ここには登録関係の関数しかない。
  検索で ISFUNC をしてみると readline に case ISFUNC: というものがある。
  其処に行ってみると取得した関数を実行している。_rl_dispatch_subseq という関数の中だ。

  cmd_xmap を廃止してデータを同じキーマップにまとめて登録するのだとしたら、
  この辺りの呼び出し方を調べる必要がある。
  先ず、現在の設計だと登録されているエントリへのポインタを
  呼びだされた関数が直接取得するのは難しそうだ。

  a readline 側のサポートが必要になる。しかし、cmd_xmap が readline 側ではなく
    bash 側で用意されていることなどから考えるに自由に関数を登録できるような仕組みはそもそも readline にはない。
    readline を拡張して cmd_xmap 埋め込みに対応できる様にするというのは readline の機能を大幅に拡張する事になり大げさである。

  b 従ってやはり bash 側で何とかいい感じに誤魔化して実装する必要がある。
    例えば現在の kmap と key 等を取得することができれば bash 側で同様に map[key].function から同一の情報を得られる。

    % しかし readline を見る限り _rl_dispatch_subseq で使われる map, key は動的に指定され外部から取得するのは難しいのではないかという気がする。
    % ちょっと調べてみた。大体の場合は map は _rl_dispatching_keymap に一致している様だ。
    % しかし _rl_dispatch_callback 経由で _rl_dispatch_subseq が呼び出される場合には予想できない。
    % やはり bash で独立に同じ kmap を取得するというのには難がある気がする。
    % それが理由で cmd_xmap という内部用の keymap を管理するという事になっているのであろう。
    % 
    % また改めて bash の cmd_xmap の参照の部分を確認してみる。
    % rl_executing_keyseq というのを参照している。これは何処で公開される物だろうか。
    % こでは readline.c で定義され readline.c で管理されている。readline.h で公開されている。
    % この rl_executing_keyseq と一緒に現在の keymap も公開すれば良いのではないだろうか。
    % うーん。と思って改めて readline.c を見てみると rl_executing_keymap という物がある。
    % 何だこれはと思って調べてみると丁度正に rl_dispatch_subseq で map を外に公開する為に
    % rl_executing_keymap = map となっていた。つまり、_rl_dispatch_subseq で使われる
    % map および key は普通に外部に公開されていたという事である。

    という訳で _rl_dispatch_subseq で使用された map 及び key は、
    rl_executing_keymap および rl_executing_key で取得することが可能である。
    つまり rl_executing_keymap[rl_executing_key].function とやれば良い。

  しかし此処でやはり問題が…。ISMACR の場合には登録されている内容は free の対象であったが、
  ISFUNC の場合には登録されている内容は関数へのポインタであって free の対象ではない。
  (というか初め ISMACR で関数が登録されているのかと考えて、関数へのポインタへのポインタだと勘違いしていた。)
  という事は勝手に新しい情報を ISFUNC に紐付けて登録する事はできないという事になる。

  或いは、keymap の entry に新しい項目を追加してしまうというのも手なのかもしれない。
  keymap は Keymap 型であり、Keymap 型は以下のように定義されている。
    typedef KEYMAP_ENTRY *Keymap;
  KEYMAP_ENTRY は struct _keymap_entry の typedef で、_keymap_entry は単純に
  char type と rl_command_func_t* function の二つのメンバを持つ。

  うーん。この _keymap_entry を改造する位ならば ISMACR, ISFUNC に代わる
  type を作成する方が見通しが良い気がする。うーん。
  或いは、cmd_xmap に登録する時に keymap も鍵として使用して登録してしまう?
  しかし問題が二点ある。

  1 keymap の同一性をどの様に判定するのか。
    単純にポインタで良いのか。
    もし realloc されるとポインタの値が変わってしまう事には注意しなければならない。
    keymap に対応する id 番号の様な物が存在すればそれが良いのであるが…。

    readline の中を grep する限りは keymap は realloc していない様な気がする。
    もっとちゃんと調べる必要がある。cmd_xmap は rl_make_bare_keymap で生成している。
    rl_make_bare_keymap は readline/keymaps.c に定義が存在して、
    rl_make_keymap 及び rl_copy_keymap から使用されている。
    rl_make_bare_keymap の実装を見る限り keymap の長さは固定であるので realloc はない。
    また rl_make_keymap 及び rl_copy_keymap は現状では誰も使っていない様だ。

    rl_make_bare_keymap を使っている箇所も特に見当たらない。cmd_xmap と、
    vi_mode.c の vi_replace_map だけだ。ではその他の keymap はどの様に確保されるのだろうか。
    様々の名前がついている keymap は何処なのかと思って探してみると、
    readline/bind.c の中に名前が定義されている。実体は各専用のファイルに定義されている様だ。
    例えば、"emacs", "emacs-standard" は emacs_standard_keymap という変数に紐付けられ、
    これは emacs_keymap.c で定義されている。そしてこれは何と静的な配列である。
    特にこれらの基本的な keymap に関して言うならばアドレスが変化するという事はなさそうだ。

    では複数のキーに紐付いて設定される keymap に関してはどうだろうか。
    一旦削除されてから再度確保し直されるとしても、
    前の keymap から新しい keymap への引き継ぎが為されていないのであればそれを追跡する必要はない。
    偶たま同じアドレスになるとしてもその場合には
    本体の keymap の方に改めて登録するときに一緒に cmd_xmap の方にも登録するので、
    その時に上書きされるので変な衝突が起こるという事もないだろう。

  2 keymap が消滅する時や unbind する時にどうやってエントリを削除するのか。
    しかし、よく考えて見ればこれは現在の実装でも問題になっている筈である。
    実装を見た感じ登録するコードは存在しても削除するコードが存在していない気がする。

    試してみたところ一度登録した bind -X は二度と解除されない様だ。。

    うーん。やはりこれに対応する為には bind/unbind の時に一緒に開放もしなければならず、
    その為には readline/bind.c を修正しなければならない。つまり、readline 側での特別な対応が必要である。
    もし ISFUNC において関数ポインタを格納する場所が動的に確保される領域であったならば、
    その動的確保される領域を勝手に拡張して後半に引数のデータを保持すれば良かった。
    しかし実際にはその様な実装にはなっていない様だ。
    代わりに ISMACR で格納する様にすれば追加のデータと関数ポインタを一緒に記録できるが、
    ISMACR は単にキーボードマクロとして処理されてしまうのでそのままでは使えない。

  結局 readline を弄らないとまともな対応は不可能に思われる。
  readline を拡張するとすれば param 付きの関数を登録できる様にするという手がある。
  param は一個で良い。関数ポインタ単体の時に何が問題かというと動的な機能を登録できないという事である。
  つまり、関数ポインタは通常は静的な関数からしか取得できないので静的な機能にならざるを得ない。

  要旨: bash_execute_unix_command の内部で元のエントリを取得する事は可能である。
  グローバル変数 rl_executing_keymap rl_executing_key を使えば良い。
  しかし一番問題になるのは登録されたデータの解放である。
  本体 keymap に対する unbind と共に行うのだとすればやはり readline を書き換えるのが易い。
  「readline 関数の呼び出し全てに介入して readline の処理を模倣して事前に cmd_xmap の更新を行う」
  という方法もできなくはないが結局 readline/bind.c を再実装しているだけに過ぎない気がする。

  もう readline を拡張する方向で行くしかない気がする。
  しかしその前に C-@ の原因について調べて置かなければならない。

------------------------------------------------------------------------------

* [bug] bind -x で登録された項目が内部的に残っている。
  更に bind -X で内部的に残っている項目まで全て出力される。

  $ LANG=C ./bash --norc
  $ bind -X
  $ bind -x '"A": echo hello'
  $ bind -X
  "A": "echo hello"
  $ bind '"A": self-insert'
  $ bind -X
  "A": "echo hello"  # <-- overwritten keyseq is still remained
  $ exit

  マクロの場合にはちゃんと消える。

  $ LANG=C ./bash --norc
  $ bind -s
  $ bind '"A":"hello"'
  $ bind -s
  "A": "hello"
  $ bind '"A": self-insert'
  $ bind -s # <-- nothing output, the entry was successfully removed
  $ exit

* [bug] cmd_xmap が keymap 間で共有されている。
  複数の異なる keymap に登録すると一方が他方を上書きする。

  $ LANG=C bash-4.4 --norc
  $ bind -m emacs -x '"A":echo emacs'
  # ----- type A -----
  emacs
  $ bind -m vi -x '"A":echo vi'
  # ----- type A -----
  vi
  $ exit

  $ LANG=C bash-4.4 --norc
  $ bind -m emacs '"A":"echo emacs"'
  # ----- type A -----
  $ echo emacs
  emacs
  $ bind -m vi '"A":"iecho vi"'
  # ----- type A -----
  $ echo emacs
  emacs
  $ set -o vi
  # ----- type ESC A -----
  $ echo vi
  vi
  $ exit

  $ LANG=C bash-4.4 --norc
  $ bind -m emacs -x '"A":echo emacs'
  # ----- type A -----
  emacs
  $ bind -m vi -x '"A":echo vi'
  # ----- type A -----
  vi
  $ set -o vi
  # ----- type A -----
  vi
  $ set -o emacs
  $ exit

* [bug] cmd_xmap には bind 時の文字列が全体の keyseq として登録される。
  例えば emacs-ctlx には C-x に続いて何かを入力した時の動作を指定する事ができるが、
  これに対して bind -x しようとしても正しく登録する事ができない。
  (とはいいつつこれは単に bind -m emacs -x '"\C-x?": ...' とすれば期待通りにできるので回避可能である。)

  $ LANG=C bash-4.4 --norc
  $ bind -m emacs -x '"A":echo hello'
  # ----- type A -----
  hello
  $ bind -m emacs-ctlx -x '"A":echo world'
  # ----- type C-x A -----
  bash-4.4: bash_execute_unix_command: cannot find keymap for command
  # ----- type A -----
  world
  $
  $ exit

  マクロの場合にはちゃんとできる。

  $ LANG=C ./bash --norc
  $ bind -m emacs-ctlx '"A":"hello world"'
  $ exit


2016-11-09

* sv_isrchterm

  - さて rl_translate_keyseq を使っている箇所を見てみたが、折角 len で長さを受け取っても
    結局それを null-terminated string に変換している。これだと意味ないのではないか。
    例えば sv_isrchterm という関数で _rl_isearch_terminators の更新を行っている。

  ★isearch-terminator に C-@ を指定しても使えない気がする。
  ★emacs-mode-string, vi-cmd-mode-string, vi-ins-mode-string にも似たような問題がある気がするが、
    これは単に出力するだけなので NUL がある場合に其処で途切れていても問題は生じない。


-------------------------------------------------------------------------------
  Done
-------------------------------------------------------------------------------

2019-02-11

* report9: convert-meta と unmeta について

  まとめ初めたが何だか分からなくなった。
  というか unmeta を if の中に入れるだけでは治らない。
  cmd_xmap と現在の kmap で map[ESC].type == ISKMAP の
  状態が異なる為に不一致が起こっている。

  _rl_convert_meta_chars_to_ascii を参照している箇所を確認して、
  全体としての一貫性がどうなっているのかを改めて確認する必要がある。

  bind.c:144: rl_bind_key に関しては、そもそも meta char を受け取って、
  現在の kmap[ESC] が存在していない場合には "out of range" の扱いだそうだ。

  bind.c:400: rl_generic_bind については、
  そもそも keys, keys_len を翻訳する時に工夫すれば良いのでは?

    →rl_translate_keyseq を修正したので変更不要の気がするが、
    使わないコードを残しておく理由もないので削除する。

  bind.c:523: rl_translate_keyseq は \M- の形式だけ \e に変換している。
  他の場所で meta chars を分解するぐらいであればそもそもこの場所で
  \e に分けて置いた方が良いのではないだろうか。

    →強制的に ESC と UNMETA (c) に分ける様に書き換えた。
    実装を見てみても最大バッファ長さは strlen(str)*2 + 1 で変わらないと思う。

  bind.c:799: _rl_function_of_keyseq_internal は書き換えかけたが…
  よく考えたらこれは読み取りのコードなのでこのままで良い気がする。
  書きかけて削除したコードは以下に残しておく。

    | char* keys;
    | int keys_len;
    |
    | keys = keyseq;
    | keys_len = len;
    |
    | if (_rl_convert_meta_chars_to_ascii)
    |   {
    |     keys = (char *)xmalloc(len * 2 + 1);
    |     keys_len = 0;
    |     for (i = 0; keyseq && i < len; i++)
    |       {
    |         unsigned char ic = keyseq[i];
    |         if (META_CHAR (ic))
    |           {
    |             keys[keys_len++] = ESC;
    |             keys[keys_len++] = UNMETA (ic);
    |           }
    |         else
    |           keys[keys_len++] = ic;
    |       }
    |     keys[keys_len] = '\0';
    |   }

  bind.c:2588: rl_invoking_keyseqs_in_map
  これは正直 \M-? と出力しようが \e? と出力しようがどちらでも良い。
  \e が kmap に存在するかどうかで動作を分けるのも妙な気がするが。
  と思ったが、この構造を追うと map[ESC].type == ISKMAP は恒真ではないか。なので気にしない。

    | for (key = 0; key < KEYMAP_SIZE; key++)
    |   {
    |     switch (map[key].type)
    |       case ISKMAP:
    |         {
    |           for (i = 0; seqs[i]; i++)
    |             {
    |               if (key == ESC)
    |                   if (_rl_convert_meta_chars_to_ascii && map[ESC].type == ISKMAP)
    |                     sprintf (keyname, "\\M-");
    |                   else
    |                     sprintf (keyname, "\\e");

  readline.c:817: _rl_dispatch_subseq
  うーん。これは一体何をやっているか分からない。meta char が指定された時は、
  map に ESC がなければ rl_ding というのを実行している。
  これは実装を確認すると単にベルを鳴らすだけの話である。
  これは受け取った文字を使って kmap を辿る操作である。
  meta char は ESC と UNMETA (c) に分解して辿る。
  これはこのままで問題ない。

  取り敢えず patch を作った。

* report7: 序でなのでこれも報告する事にする。
  ref ble.sh/memo.txt#D0920

* report8: 改めてバグ報告をする事にする。
  ref ble.sh/memo.txt#D0918
  簡単なバグなのですぐ送ってしまう事にする。

2018-05-03

* report6: 月を跨いだので現在分かっている最後のバグについて patch を送る事にする。
  このバグについてのメモは何処かにあるはずだと思ったが、
  確認してみると何処にも見つからない。
  仕方がないので改めて際限コードを作成する事にする。

  $ bash-4.4 --norc
  $ f1() { bind -x '"\C-t": f1'; }; f1
  bash-4.4: $'\317\003': command not found

2018-03-23

* READLINE_POINT が bytes 単位である事について。

  これは ble.sh の方にメモがあるかと思ったら何もなかった。そういう仕様だという前提で書かれたのであろう。
  READLINE_POINT が bytes 単位である事を認識して書いているコードはどれぐらいあるだろうか。

  | 正しく実装する一つの方法は LC_CTYPE を設定してから文字列の長さを測るという物である。
  | [Search](https://github.com/search?utf8=%E2%9C%93&amp;q=LC_CTYPE+READLINE_POINT+NOT+LC_MESSAGES+NOT+rl_line_buffer&amp;type=Code)
  | →[dot/kingbash.script](https://github.com/billinux/dot/blob/986cc0b8df950687ff0b50aced6df5a755a9b9d3/bin/kingbash.script)
  | 
  | もう一つの方法は LC_ALL を設定するという物。
  | [Search](https://github.com/search?q=LC_ALL+READLINE_POINT+NOT+LC_MESSAGES+NOT+rl_line_buffer+NOT+READLINE_LINE_BUFFER&amp;type=Code&amp;utf8=%E2%9C%93)
  | 
  | 或いは wc -c でも数えられるかもしれない。
  | [Search](https://github.com/search?utf8=%E2%9C%93&amp;q=wc+%22READLINE_POINT%3D%22+NOT+LC_MESSAGES+NOT+rl_line_buffer+NOT+READLINE_LINE_BUFFER&amp;type=Code)

  他の検索

  | [Stack Overflow](https://stackoverflow.com/search?q=%22READLINE_POINT%22)

  結局、どうやら kingbash.script で対策されているだけで他には使われていない様である。
  [Bash/関数 - ArchWiki](https://wiki.archlinux.jp/index.php/Bash/%E9%96%A2%E6%95%B0)
  によると KingBash はメニュー補間を実現するスクリプト (2008) の様である。

  kingbash.script の場合には単に文字列末端にカーソルを移動するだけである (要確認)。
  LC_ALL=C LC_CTYPE=C で過大評価になるだけなので結局文字列末端に移動することは変わらない。

  とにかく初めに READLINE_POINT の修正案を提示する事が先である。
  先ず文字列の長さを数える方法について確認する。
  或いはパラメータ展開の offset, length をどの様に処理しているか。

  subst.c:4411: mb_getcharlens (string, len)
  subst.c:7639: mb_substring (string, s, e)
  lib/readline/mbutil.c:363: _rl_find_next_mbchar (char *string, int seed, int count, int flags)

  文字数からバイト位置に変換するのは _rl_find_next_mbchar で良さそうだ。flags = 0
  mb_getcharlens は調べてみると何処からも使われない。
  というか ifdef INCLUDE_UNUSED の中にあるというのはそういう事の様だ。
  他に類似の機能はないだろうか。というか ${#var} の場合に何れにしても数える必要があるので、
  何処かでその機能は存在しているはずである。

  subst.c:6967: parameter_brace_expand_length (name) の中の
	subst.c:7021:           number = MB_STRLEN (t); である。

  MB_STRLEN は incloude/shmbutil.h で定義されている。

  $ rl-insert () { READLINE_LINE=${READLINE_LINE::READLINE_POINT}$1${READLINE_LINE:READLINE_POINT}; ((READLINE_POINT+=${#1})); }
  $ bind -x '"\C-t": rl-insert AA'
  $ echo あ|いうえお

  ここで C-t を押してみるとあらぬ所に挿入される。更に続けて文字を入力すると文字が壊れる。

2018-03-21

* 改めて C-@ の問題について patch を送る事にした。

  関連して他の問題もある。`rl_bind_keyseq_if_unbound_in_map' 287 lib/readline/bind.c で、
  引数 keyseq を rl_function_of_keyseq と rl_bind_keyseq_in_map に渡している。
  rl_function_of_keyseq は translated sequences を受け取る関数である。
  rl_bind_keyseq_in_map は untranslated sequences を受け取る関数である。

  rl_function_of_keyseq が translated sequences を受け取る関数であることの根拠

    o 実装がその様になっている (長さを受け取らないので欠陥であるが)。
    o bash_execute_unix_command で translated sequences を渡している。
    - initialize_readline (bashline.c) で null-terminated sequences を渡している…が、
      これは何とも言えない。

  rl_bind_keyseq_in_map が untranslated sequences を受け取る関数であることの根拠

    o 中で rl_translate_keyseq を呼び出している。
    o bind_keyseq_to_unix_command で bind -x '"...": ...' の最初の ... の部分を
      rl_bind_keyseq_in_map に渡している。

  rl_bind_keyseq_if_unbound_in_map が untranslated sequences であるべき理由

    o 長さを受け取っていないので、translated だと問題が起こる。
    - rl_bind_key_if_unbound_in_map から null-terminated で呼び出している。
    - rl_bind_key_if_unbound から null-terminated で呼び出している。
    - rl_bind_keyseq_if_unbound は等価な関数
    x bind_termcap_arrow_keys で使われている rl_bind_keyseq_if_unbound は
      translated sequences でなければならない。
      →これは keys, key_len 引数を受け取る様にしなければならない。
      もしこれに対応するとすると、
      - rl_bind_keyseq_if_unbound_in_map
      - rl_bind_keyseq_in_map
      - rl_generic_bind
      それぞれに対して keys, key_len を受け取る版を作成しなければならない。x

  ToDo:
    rl_bind_key_if_unbound_in_map: untranslate
    rl_bind_key_if_unbound       : untranslate

  以下は昔書きかけた bug report

  | From: murase
  | To: bug-bash@gnu.org
  | Subject: [50 character or so descriptive subject here (for reference)]
  | 
  | Configuration Information [Automatically generated, do not change]:
  | Machine: i686
  | OS: linux-gnu
  | Compiler: gcc
  | Compilation CFLAGS:  -DPROGRAM='bash' -DCONF_HOSTTYPE='i686' -DCONF_OSTYPE='linux-gnu' -DCONF_MACHTYPE='i686-pc-linux-gnu' -DCONF_VENDOR='pc' -DLOCALEDIR='/home/murase/opt/bash-4.4/share/l\
  | ocale' -DPACKAGE='bash' -DSHELL -DHAVE_CONFIG_H   -I.  -I. -I./include -I./lib   -O2 -march=native -Wno-parentheses -Wno-format-security
  | uname output: Linux padparadscha 4.7.2-101.fc23.i686 #1 SMP Fri Aug 26 16:39:46 UTC 2016 i686 i686 i386 GNU/Linux
  | Machine Type: i686-pc-linux-gnu
  | 
  | Bash Version: 4.4
  | Patch Level: 0
  | Release Status: release
  | 
  | Description:
  |   [Detailed description of the problem, suggestion, or complaint.]
  | 
  | Repeat-By:
  | 
  |   $ LANG=C bash-4.4 --norc
  |   $ bind -x '"\C-@":echo hello'
  |   $
  |   # ----- type C-@ or C-space -----
  |   bash-4.4: bash_execute_unix_command: cannot find keymap for command
  |   $ bind -x '"\C-A":echo hello'
  |   # ----- type C-a -----
  |   hello # expected result for C-a
  |   $ exit
  |   $ LANG=C bash-4.3 --norc
  |   $ bind -x '"\C-@":echo hello'
  |   $
  |   # ----- type C-@ or C-space in the terminal -----
  |   bash-4.3: bash_execute_unix_command: cannot find keymap for command
  |   $ exit
  |   $ LANG=C bash-4.2 --norc
  |   $ bind -x '"\C-@":echo hello'
  |   # ----- type C-@ or C-space -----
  |   hello
  |   $ exit
  | 
  | Fix:
  |   [Description of how to fix the problem.  If you don't know a
  |   fix for the problem, don't include this section.]

  以下はこれについての古い項目

  | 2016-11-09 C-@ に bind -x すると実行に失敗する原因は分かった。
  |
  | | 先ず bind -X するとちゃんと登録されている。
  | | よく分からないので登録時・読み取り時の kseq 変数の中身を printf で見てみる。
  | | どうやら登録時は bind に指定した引数 (の部分文字列) をそのまま渡している様だ。
  | | そして読み取り時は入力したキーの列がそのまま渡されている。
  | | これだと登録時と読み取り時で異なるシーケンスになるのが普通だがこれで良いのか?
  | | 試しに C-a で試してみると両者が異なっていてもちゃんと機能する様だ。
  | | というか、登録時の kseq と読み取り時の kseq は意味合いが異なるのだろう。
  | | 
  | | と、ここで読み取り時に実際に入力したキーの列が格納されているのはヌル終端文字列である。
  | | ヌル終端文字列に C-@ を含ませる事は不可能である。
  | | これだと長さ 0 になってしまうのではないだろうか。
  | | そしてこの推測が正しければ、そもそも C-@ を一文字でも含む様なキーシーケンスは全然登録できない。
  | | 試してみることにする。
  | | 
  | | C-@A で試してみた所やはり同様に
  | |   bash: bash_execute_unix_command: cannot find keymap for command
  | | のエラーが発生する様だ。(C-@ set-mark が残っているので、
  | | 素早く入力しないと set-mark の方が呼び出されてしまう事に注意する。
  | | # というか C-@ を解除する方法はないのだろうか…と思ったら普通に bind -r で良かった。
  |
  | [まとめ]
  |
  | cmd_xmap から読み出す時に rl_executing_keyseq (ヌル終端文字列) を使っているが、
  | そこに C-@ が含まれていると其処で文字列が終端していると見なされて読み出せない。
  |
  | さてではどの様に修正したら良いであろうか。
  | ヌル終端文字列を受け取る関数 rl_function_of_keyseq を見るといろいろな箇所で用いられている。
  | 何故これが問題にならないのであろう。。というかこの関数は本当にヌル終端文字列を受け取る関数なのか?
  | → bind -x '"\\\\": echo double bslash' として \ \ と入力したら rl_function_of_keyseq に "\\" が渡され、
  | 結果として正しく echo double bslash が実行された。つまり rl_function_of_keyseq は "\\" をちゃんと二文字の \ と認識している。
  | 勝手にエスケープされた一文字の \ という様に誤解釈したりはしない様だ。つまり、
  | rl_function_of_keyseq は本当にヌル終端文字列を受け取るという事である。
  |
  | ここで、その他の rl_function_of_keyseq で問題が生じないのかどうかを調べる必要がある。
  | 先ず rl_function_of_keyseq の実装を念のため確認する。やはり常に生のヌル終端文字列として取り扱っている。
  | 今度は呼び出し元について調べる。
  | - called by rl_bind_keyseq_if_unbound_in_map:
  |   % readline 内部での呼び出しは rl_bind_keyseq_if_unbound_in_map (bind.c) の引数をそのまま渡すもののみである。
  |   % rl_bind_keyseq_if_unbound_in_map は readline 内部 (bind.c) のみで使用されている。
  |   % - called by rl_bind_key_if_unbound_in_map:
  |   %   key から keyseq を作って渡している。
  |   %   rl_bind_key_if_unbound_in_map は initialize_readline (bashline.c) 内部でハードコートされた引数について呼び出されている。
  |   %   たまたまハードコートされたキーについては C-@ が含まれていないので問題が起こっていないという事だ。
  |   %   他の箇所では使われていない。従ってこれについては問題は生じない。
  |   % - called by rl_bind_key_if_unbound:
  |   %   この関数は誰も使っていない。
  |   %   また、中身は単に rl_bind_key_if_unbound_in_map(key, default_func, _rl_keymap) に置き換えられる。
  |   % - called by rl_bind_keyseq_if_unbound:
  |   %   rl_bind_keyseq_if_unbound_in_map(keyseq, default_func, _rl_keymap) であり、
  |   %   実際に使われている箇所はハードコートされた物と terminfo から読み取った制御シーケンスである。
  |   %   制御シーケンスには NUL は含まれない (ANSI規格に従えば)。従ってこれも問題は起こらない。
  |   これはよく見てみれば別のバグで rl_function_of_keyseq に keys を渡す時に翻訳を忘れているだけだった。
  |   その修正さえすれば何の問題もない。
  | - called by bashline.c (initialize_readline):
  |   四ヶ所から呼び出されているが全部ハードコードされた物であり NUL は含まれていない。
  | - called by bashline.c (bash_execute_unix_command):
  |   これは今問題になっている関数である。
  |
  | 結局今回問題になっている物以外は全てハードコードされた物であって (たまたま) 何も問題が生じていないという事の様だ。
  | さて rl_function_of_keyseq を拡張して長さを指定できる様にするとしたらどの様にするか。
  | 長さを取得する方法が必要である。
  | 調べると rl_key_sequence_length という変数に長さが入っている様だ。
  | 似た変数名として rl_executing_keyseq_size という物があるが、
  | これは buffer のサイズを保持しているのであって長さを保持している訳ではない事に注意する。
  | extern int rl_key_sequence_length は readline.h で公開されている。
  | という訳で
  |
  | さて似たような事が他で問題にならないのかというのは不思議である。
  | - rl_untranslate_keyseq この関数名は怪しいと思って確認した見たが、
  |   keyseq といいつつこれは1文字を文字列に変換するだけの関数である。
  | - というかそもそも keymap は終端をどの様に検知しているのだろう?
  |   うーん。というかそもそも kseq を保持する様な実装にはなっていなくて、
  |   keymap の chain を辿っていく仕組みになっていて、唯一長さを意識するのは bind 時であったが、
  |   これは ASCII rep で渡しているから問題ないということなのか。しかしそれでも rl_translate_keyseq に渡すから、
  |   問題になるのじゃないかと思ったが…rl_translate_keyseq はちゃんと int* len という引数に結果を格納する。
  | ★rl_bind_keyseq_if_unbound_in_map この関数は引数 keyseq の使い方が怪しい。
  |   keyseq を rl_function_of_keyseq と rl_bind_keyseq_in_map にそのまま渡している。
  |   rl_function_of_keyseq は keyseq を直接表現として取り扱う。
  |   rl_bind_keyseq_in_map は keyseq をASCII表現として取り扱う。
  |   ドキュメントによると keyseq は ASCII 表現でなければならない気がする。
  |   つまり変換が必要である。
